<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer-解题思路速记</title>
      <link href="/2024/09/01/%E5%89%91%E6%8C%87offer-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E9%80%9F%E8%AE%B0/"/>
      <url>/2024/09/01/%E5%89%91%E6%8C%87offer-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分类目录必填 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode热题-解题思路速记</title>
      <link href="/2024/09/01/LeetCode%E7%83%AD%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E9%80%9F%E8%AE%B0/"/>
      <url>/2024/09/01/LeetCode%E7%83%AD%E9%A2%98-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E9%80%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codeTop.cc">来源CodeTop</a></p><h1>按照热度顺序</h1><h2 id="字节的to题目">字节的to题目</h2><h2 id="1-10">1-10</h2><h3 id="3-无重复字符的最长子串">3.无重复字符的最长子串</h3><pre><code>滑动窗口，临时变量，hash表记录最近一次出现的下标临时变量记录已经遍历过的最长的不重复子串遍历数组：一旦发现有重复的，就重置滑动窗口的起始位置到当前位置</code></pre><h3 id="146、LRU缓存机制">146、LRU缓存机制</h3><pre><code>1、hashmap + Deque    使用deque来保存最近使用的元素，每次读写、，都调整deque的元素        peekFirst、pollFirst2、LinkedHashMap  + 自定义removeEldestEntry</code></pre><h3 id="25、K个一组反转链表">25、K个一组反转链表</h3><pre><code>k个一组，反转多次最后判断反转的节点个数若不等于k，则在翻转一次，转回来</code></pre><h3 id="206-反转链表">206.反转链表</h3><h3 id="215、数组中的第K个最大元素">215、数组中的第K个最大元素</h3><pre><code>手写快排？三路快排？</code></pre><h3 id="15、三数之和">15、三数之和</h3><pre><code>先排序，然后再从左到右遍历，每个小于0的数字target，在右边找到两个相加和等于-target的和，此刻的三个数字，即为一个结果</code></pre><h3 id="103、二叉树的锯齿形层次遍历">103、二叉树的锯齿形层次遍历</h3><pre><code>用两个栈、两个队列，都行</code></pre><h3 id="200、岛屿数量">200、岛屿数量</h3><pre><code>用一个二维数组，保存是否已经被访问过用一个dfs，表示当前坐标是否是未被访问过的陆地，向上下左右深度搜索</code></pre><h3 id="121、买卖股票的最佳时机">121、买卖股票的最佳时机</h3><pre><code>找到当前的最小值，遍历过程中更新，然后求利润，并求利润最大值</code></pre><h3 id="33、搜索旋转排序数组">33、搜索旋转排序数组</h3><pre><code>二分查找 l、r，针对target 和 mid值，进行区分相等，则找到，返回不相等，则具体判断target和mid值、左边界、右边界的大小，调整l、r最后，需要对l、r相等的情况判断</code></pre><h2 id="11-20">11-20</h2><h3 id="1、两数之和">1、两数之和</h3><pre><code>暴力搜索使用hash表</code></pre><h3 id="236、二叉树的最近公共祖先">236、二叉树的最近公共祖先</h3><pre><code>用两个队列，保存两个节点的访问路径然后依次弹出，找最后一个相等的节点，即为所求</code></pre><h3 id="42、接雨水-困难">42、接雨水  (困难)</h3><pre><code>解法1:    leftMax[i]：表示height[i]左侧的最大高度    rightMax[i]:表示height[i]右侧的最大高度    每个点的接雨水量，等于 min(leftMax[i] ,rightMax[i]) - height[i]    然后累加即可解法2： 单调栈    栈中保存的，应该是上一个『山头』，即递减的第一个元素        栈为空：入栈        栈顶元素大于当前元素，累加这一层的雨水量        栈顶元素等于当前元素：不累计，不出入栈        栈顶元素小于当前元素：累加这一层的雨水量，栈顶元素出栈，当前元素入栈</code></pre><h3 id="54、螺旋矩阵">54、螺旋矩阵</h3><pre><code>四个方向，写四个打印函数，依次打印即可</code></pre><h3 id="5、最长回文子串">5、最长回文子串</h3><pre><code>解法1：动态规划    dp[i][j] :字符串中从 【i, j】的子串是否为回文子串        一次遍历，求出长度为1的回文子串        一次遍历，求出长度为2的回文子串        预设长度从3开始，扩散求最长的回文子串中心扩散    对每个字符，求从此字符开始，能扩展到的最长回文子串长度</code></pre><h3 id="160、相交链表">160、相交链表</h3><pre><code>分别遍历，求长度，求长度差然后长的先走，慢的后走，最终会相遇的</code></pre><h3 id="53、最大子数组和">53、最大子数组和</h3><pre><code>简单do</code></pre><h3 id="46、全排列">46、全排列</h3><pre><code>用递归</code></pre><h3 id="31、下一个排列">31、下一个排列</h3><p>TODO<br>先从右向左，找第一个nums[i] &gt; nums[i-1]的下标i，<br>然后在i 的右边，找第一个刚大于nums[i-1]的元素下标j<br>交换nums[i-1],nums[j]<br>最后逆序nums[i:n-1]即可</p><h3 id="23、合并K个排序链表">23、合并K个排序链表</h3><hr><h2 id="21-30">21-30</h2><h3 id="300-最长上升子序列">300. 最长上升子序列</h3><pre><code>用一个数组dp，dp[len] 表示最长上升子序列最长的时候，对应的最后一个数字是多少，遇到比当前元素大的，直接设值，len+1，否则，二分查找，找第一个大于当前元素的dp位置，更新进去</code></pre><h3 id="199-二叉树的右视图">199. 二叉树的右视图</h3><pre><code>使用两个队列，使用add、poll操作</code></pre><h3 id="143-重排链表">143. 重排链表</h3><pre><code>方法1：遍历，使用list保存节点内容，再遍历，改变节点指向方法2：先求中点、在反转右边的链表、最后合并左半边和右半边的链表，记得最后避免出现环</code></pre><h3 id="20-有效的括号">20. 有效的括号</h3><pre><code>使用栈，进行匹配消消乐</code></pre><h3 id="102-二叉树的层序遍历">102. 二叉树的层序遍历</h3><pre><code>一个队列 + 一个遍历报错当前层次的元素个数</code></pre><h3 id="88-合并两个有序数组">88. 合并两个有序数组</h3><pre><code>从尾部开始合并</code></pre><h3 id="21-合并两个有序链表">21. 合并两个有序链表</h3><pre><code>简单题目</code></pre><h3 id="92-反转链表-II">92. 反转链表 II</h3><pre><code>遍历加反转</code></pre><h3 id="141-环形链表">141. 环形链表</h3><pre><code>快慢指针，判断是否有环</code></pre><h3 id="415-字符串相加">415. 字符串相加</h3><pre><code>模拟即可，记得处理最后的进位</code></pre><h2 id="31-40">31-40</h2><h3 id="124-二叉树中的最大路径和">124. 二叉树中的最大路径和</h3><pre><code>递归，针对当前节点，考虑一下三种情况仅考虑本节点的值考虑左右子节点中其中任一个节点的和本节点值的和考虑左右子节点和本节点值的和，取最大值，作为本节点的结果最后去全局的最大和</code></pre><h3 id="41-缺失的第一个正数-困难-放弃">41. 缺失的第一个正数     (困难)放弃</h3><h3 id="72-编辑距离-困难-放弃">72. 编辑距离            (困难)放弃</h3><h3 id="56-合并区间">56. 合并区间</h3><pre><code>对每个区间，按照开始字段start进行排序，然后依次判断是否可以合并需要自定义排序方法</code></pre><h3 id="221-最大正方形">221. 最大正方形</h3><pre><code>猜测，使用dp[i][j]，表示以i,j 为右下角时候的正方形中，最大的正方形边长      转移方程为：dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1    还需要考虑边界情况</code></pre><h3 id="148-排序链表">148. 排序链表</h3><pre><code>合并排序1、快慢指针，分成两段2、对左右两段，进行合并排序记得断开两段之间的链接，避免出现环</code></pre><h3 id="69-x-的平方根">69. x 的平方根</h3><pre><code>二分查找    mid * mid 后和x比较注意需要先转换为long，再比较，避免int相乘后溢出为负数</code></pre><h3 id="165-比较版本号">165. 比较版本号</h3><pre><code>逗号分割，转换为数字，进行比较双指针，遇到.的时候，暂停，进行比较</code></pre><h3 id="129-求根到叶子节点数字之和">129. 求根到叶子节点数字之和</h3><pre><code>深度优先搜索，需要将根节点的临时结果带到下一层的子节点中需要注意，递归结束返回后，需要将结果*10，再进行后续处理</code></pre><h3 id="105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</h3><pre><code>先在根据前序的结果，求在中序中的中间位置，分成左右两部分然后再依次构建二叉树</code></pre><h2 id="41-50">41-50</h2><h3 id="101-对称二叉树">101. 对称二叉树</h3><pre><code>简单递归即可迭代的话,用两个队列，对称入队，依次进行比较</code></pre><h3 id="补充题4-手撕快速排序">补充题4. 手撕快速排序</h3><pre><code>leetcode上说，需要针对基本有序的数组进行优化</code></pre><h3 id="32-最长有效括号-困难">32. 最长有效括号  (困难)</h3><pre><code>用栈，栈中保存遍历过程中，未匹配上的）的下标</code></pre><h3 id="22-括号生成">22. 括号生成</h3><pre><code>用深度优先搜索，特殊情况：只有当剩余（ 的个数 小于 ） 的时候，才可以继续dfs进行匹配</code></pre><h3 id="93-复原IP地址">93. 复原IP地址</h3><pre><code>回溯 + 剪枝</code></pre><h3 id="4-寻找两个正序数组的中位数">4. 寻找两个正序数组的中位数</h3><pre><code>若两个数组长度为n、m,则等价于求第(n+m)/2小的数使用二分查找的方法，依次在两个数组中移动指针，并比较大小</code></pre><h3 id="76-最小覆盖子串-困难">76. 最小覆盖子串  (困难)</h3><pre><code>滑动窗口 + hash表</code></pre><h3 id="39-组合总和">39. 组合总和</h3><h3 id="142-环形链表-II">142. 环形链表 II</h3><h3 id="78-子集">78. 子集</h3><h2 id="51-60">51-60</h2><h3 id="322-零钱兑换">322. 零钱兑换</h3><pre><code>TODO </code></pre><h3 id="1143-最长公共子序列">1143. 最长公共子序列</h3><pre><code>使用动态规划</code></pre><h3 id="82-删除排序链表中的重复元素-II">82. 删除排序链表中的重复元素 II</h3><h3 id="162-寻找峰值">162. 寻找峰值</h3><pre><code>二分查找，找到任意一个峰值即可</code></pre><h3 id="232-用栈实现队列">232. 用栈实现队列</h3><pre><code>容易</code></pre><h3 id="112-路径总和">112. 路径总和</h3><h3 id="94-二叉树的中序遍历">94. 二叉树的中序遍历</h3><h3 id="2-两数相加">2. 两数相加</h3><h3 id="394-字符串解码">394. 字符串解码</h3><h3 id="19-删除链表的倒数第N个节点">19. 删除链表的倒数第N个节点</h3>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK11升级</title>
      <link href="/2024/09/01/JDK11%E5%8D%87%E7%BA%A7/"/>
      <url>/2024/09/01/JDK11%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1>为什么要升级</h1><h2 id="业界">业界</h2><ul><li>Oracle Java 8 的 Support 已经到期，目前每两年出 1 个 LTS 版本，发布节奏快</li><li>Spring、Netty、Jetty、Kafka 等在 Java 生态非常流行的软件逐渐不兼容 JDK8</li><li>从相对权威的生态报告上看，JDK11 的使用占比超过了 JDK8</li></ul><h2 id="升级带来的好处">升级带来的好处</h2><ul><li>相对JDK 8，11/17 有超过 100+ 新特性，覆盖性能、安全、语法等多个角度</li><li>性能方面，在内存、GC、RAS、启动以及新架构 AArch64领域都有明显的优化</li><li>对云原生支持更友好，包括 Serverless Java Runtime启动更快，JFR可观测性更优及更多容器支持</li></ul><h2 id="新版JDK的特性">新版JDK的特性</h2><ul><li><p>压缩String（JDK9）</p><p>String 底层结构优化，使用 byte[]，提高内存利用率</p></li><li><p>CodeCache（JDK9）</p><p>除了hotspot中的JIT（C1、C2）外，还有解释器也会生成动态代码</p><p>所有生成的代码会存储在CodeCache里，按照类型划分在不同的区域里，利用cache的局部性对指令进行缓存</p><p>进而降低内存碎片</p></li><li><p>可伸缩元空间（JDK16）</p><p>降低元空间使用率和碎片化，将空闲的空间归还给OS</p></li><li><p>G1（JDK9）</p><p>高吞吐量、低延迟的GC实现</p></li><li><p>统一的GC日志（JDK9）</p></li><li><p>高性能的JFR（JDK11）</p><p>超低开销下的JVM可观测性能力<br>关联分析实现方法、对象分配、IO、锁竞争等多维度的热点分析</p></li><li><p>更精准的NP报错（JDK4）</p><p>在a.b.c这样的链式调用情况下，能更清晰的给出报错的信息</p></li><li><p>模块化（JDK9）</p><p>目前来看，用处不大</p></li><li></li></ul><h1>升级挑战</h1><p>以下是从JDK 8升级到JDK 11会遇到的一些困难：<br>1.移除的API和功能：自JDK 9以来，一些API和功能已经被弃用并最终在JDK 11中移除，例如Nashorn JavaScript引擎和Java Applets。</p><p>2.模块化系统：JDK 9引入了Java平台模块系统（JPMS），这可能会导致依赖问题，需要重新组织代码和库依赖。</p><p>3.第三方库和框架的兼容性：可能会遇到第三方库或框架与JDK 11不兼容的情况。需要检查和升级这些依赖项。</p><p>4.性能问题：新版本可能会引入性能变化，需要对应用程序做性能测试和调优。</p><p>5.工具和插件支持：开发和构建工具可能需要更新以支持JDK 11，例如Maven或Gradle。</p><p>6.新的垃圾收集器：JDK 11引入了新的垃圾收集器，例如ZGC和Epsilon。需要理解这些新特性并根据需要调整JVM参数。</p><p>7.语法和特性变更：虽然从JDK 8到JDK 11的源代码兼容性相对较好，但一些新特性和改进（如本地变量类型推断）可能需要代码更改来充分利用。</p><p>8.安全性和TLS：JDK 11提高了安全性要求，包括对TLS的更新，可能需要调整安全配置。</p><p>9.升级成本：升级可能涉及代码更改、测试和部署，这些都增加了工作量和成本。</p><p>为了成功升级，您需要执行以下步骤：</p><ul><li>更新并测试所有的依赖项以确保兼容性。</li><li>使用JDK 11重新编译代码并处理任何编译错误。</li><li>对应用进行彻底测试，包括单元测试、集成测试和性能测试。</li><li>阅读JDK 8到JDK 11之间所有版本的发布说明，了解重要更改和潜在的影响。</li><li>考虑使用工具（如jdeps）分析依赖关系和模块。</li></ul><p>升级总是需要仔细规划和执行，但从长远来看，迁移到更现代的Java版本可以带来更好的性能、新特性和改进的安全性。</p><h1>如何升级</h1><h2 id="二方包打包问题">二方包打包问题</h2><p>jdk11的项目打出来的二方包，为了给其他jdk8的项目用，需要将打出来的包的级别设置为jdk8</p><p>在 pom中设置 变量 <em><strong>maven.compiler.source</strong></em> 为8 即可</p><h2 id="基础环境配置">基础环境配置</h2><ul><li>maven需要升级到3.5.0以上，maven-compiler-plugin升级到3.6.1以上<br>待升级的maven项目的pom配置如下</li></ul><pre><code class="language-shell">&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;useIncrementalCompilation&gt;false&lt;/useIncrementalCompilation&gt; &lt;/configuration&gt;&lt;/plugin&gt;</code></pre><pre><code class="language-shell">  &lt;java.version&gt;11&lt;/java.version&gt;  &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;  &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;</code></pre><ul><li>Idea 版本要求：intellij版本在2018.2以上</li><li>Idea的JDK也要升级（使用Idea自己的JDK版本管理功能，下载jdk11即可）</li><li>Spring 升级<br>JDK11对于spring最低版本要求是5.0</li><li>GC参数改变</li></ul><pre><code class="language-shell">  SERVICE_OPTS="${SERVICE_OPTS} -XX:+UseG1GC"  SERVICE_OPTS="${SERVICE_OPTS} -XX:G1HeapRegionSize=8m"  SERVICE_OPTS="${SERVICE_OPTS} -XX:+G1BarrierSkipDCQ"  SERVICE_OPTS="${SERVICE_OPTS} -XX:ErrorFile=/home/admin/logs/hs_err_pid%p.log"  SERVICE_OPTS="${SERVICE_OPTS} -Xlog:gc*:/home/admin/logs/gc.log" # SETENV NEW OPTS  SERVICE_OPTS="${SERVICE_OPTS} -XX:ReservedCodeCacheSize=256m"  SERVICE_OPTS="${SERVICE_OPTS} -noverify -DdefaultHsfClientTimeout=3000 -Dpandora.ignore.packaged.plugins=false"  SERVICE_OPTS="${SERVICE_OPTS} -Djava.awt.headless=true -Dcom.sun.management.jmxremote.port=1090 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Djava.rmi.server.hostname=$LOCAL_IP"  SERVICE_OPTS="${SERVICE_OPTS} --add-exports java.base/jdk.internal.ref=ALL-UNNAMED"</code></pre><ul><li>无效的包，需要排除</li><li>框架版本要求<br>ASM &gt;= 7.0</li></ul><p>Guice &gt;= 4.2</p><p>guava &gt;= 18.0</p><p>lombok &gt;= 1.18.22</p><p>MapStruct &gt;= 1.5.5.Final</p><p>Kotlin &gt;= 1.3.30</p><p>dagger &gt;= 2.24</p><p>Mockito &gt;= 2.22.0</p><p>Jacoco &gt;= 0.8.3</p><p>JMockit &gt;= 1.49</p><p>aspectj &gt;= 1.14.0</p><p>groovy &gt;= 2.5.6</p><h2 id="升级常见问题">升级常见问题</h2><ol><li>缺少javax相关的包<br>JDK11及以上版本,已经没有这些rt.jar了,而用.so文件代替了.<br>添加依赖</li></ol><pre><code class="language-shell">&lt;dependency&gt;    &lt;groupId&gt;javax.annotation&lt;/groupId&gt;    &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>lombok问题</li></ol><p>升级lombok版本到1.18.22及以上版本.</p><ol start="3"><li>无法远程debug</li></ol><p>JDK11的DEBUG端口变成了*:PORT的SOCKET形式.</p><p>将</p><pre><code class="language-shell">-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n</code></pre><p>改为</p><pre><code class="language-shell">-agentlib:jdwp=transport=dt_socket,address=*:8000,server=y,suspend=n</code></pre><h1>参考</h1><p>1、<a href="https://grow.alibaba-inc.com/course/4800015674472669/section/1800015674472769">https://grow.alibaba-inc.com/course/4800015674472669/section/1800015674472769</a><br>2、<a href="https://ata.atatech.org/articles/11020147240?spm=ata.23639746.0.0.753d21b8aGbM4p">https://ata.atatech.org/articles/11020147240?spm=ata.23639746.0.0.753d21b8aGbM4p</a><br>3、<a href="https://ata.atatech.org/articles/11020153233">https://ata.atatech.org/articles/11020153233</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK升级 </tag>
            
            <tag> JDK11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/01/Web-HTTPS(%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%EF%BC%89/"/>
      <url>/2024/09/01/Web-HTTPS(%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>待完善</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC-Lock</title>
      <link href="/2024/09/01/JUC-Lock/"/>
      <url>/2024/09/01/JUC-Lock/</url>
      
        <content type="html"><![CDATA[<h1>顶层接口：</h1><ul><li>lock()// 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放</li><li>lockInterruptibly() // 和 lock()方法相似, 但阻塞的线程可中断，抛出 java.lang.InterruptedException异常</li><li>tryLock() // 非阻塞获取锁;尝试获取锁，如果成功返回true</li><li>newCondition()</li><li>unlock()</li></ul><h1>Condition:</h1><p>为线程提供了等待、通知机制（wait、signal）</p><ol><li><strong><font style="background-color:rgb(247, 249, 253);">等待（Await）</font></strong><font style="background-color:rgb(247, 249, 253);">:</font><ul><li><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">当一个线程持有相关的</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">Lock</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">但希望暂时释放锁，并等待某个条件变为真时，它可以调用</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">Condition</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">的</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">await()</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">方法。这类似于</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">Object</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">的</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">wait()</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">方法。调用</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">await()</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">会使当前线程进入等待状态直到它被通知或被中断。</font></li></ul></li><li><strong><font style="background-color:rgb(247, 249, 253);">通知（Signal）</font></strong><font style="background-color:rgb(247, 249, 253);">:</font><ul><li><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">另一个线程可以通过调用Condition的signal()或signalAll()方法来唤醒一个或所有等待的线程。这类似于Object的notify()或notifyAll()方法。调用signal()会唤醒一个等待在Condition上的线程，而signalAll()会唤醒所有等待的线程。</font></li></ul></li></ol><p>await():</p><p>将当前线程加入condition的等待队列</p><p>释放当前condition对应的锁</p><p>当前线程被挂起（阻塞）（使用LockSupport.park）</p><p>signal：</p><p>使用LockSupport.unpark，进行解锁</p><h2 id="常见用法">常见用法</h2><p>1、生产者、消费者</p><p>一个锁，分两个condition</p><ul><li>notFull</li><li>notEmpty</li></ul><p>生产者等notFull</p><p>消费者等notEmpty</p><p>Q:为什么不用两个锁</p><p>A:</p><p>1、因为消费队列是同一个，用一个锁可以更好的保证共享数据的一致性</p><p>2、通知更加精确，不会通知到无关的线程</p><p>3、简化了代码逻辑</p><p>4、性能优化</p><p>5、避免信号丢失</p><h1>常见实现</h1><p><font style="color:rgb(25, 27, 31);">1、ReentrantLock</font></p><p><font style="color:rgb(25, 27, 31);">2、ReentrantReadWriteLock</font></p><p><font style="color:rgb(25, 27, 31);">3、StampedLock</font></p><p><font style="color:rgb(25, 27, 31);"></font></p><p><font style="color:rgb(25, 27, 31);">参考：</font></p><p><font style="color:rgb(25, 27, 31);">1、</font><a href="https://zhuanlan.zhihu.com/p/492481897">https://zhuanlan.zhihu.com/p/492481897</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-常见面试题</title>
      <link href="/2024/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/09/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>1、按序打印</h1><pre><code class="language-plain">给你一个类：public class Foo {  public void first() { print("first"); }  public void second() { print("second"); }  public void third() { print("third"); }}三个不同的线程 A、B、C 将会共用一个 Foo 实例。线程 A 将会调用 first() 方法线程 B 将会调用 second() 方法线程 C 将会调用 third() 方法请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。提示：尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。你看到的输入格式主要是为了确保测试的全面性。 示例 1：输入：nums = [1,2,3]输出："firstsecondthird"解释：有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。正确的输出是 "firstsecondthird"。示例 2：输入：nums = [1,3,2]输出："firstsecondthird"解释：输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。正确的输出是 "firstsecondthird"。 提示：nums 是 [1, 2, 3] 的一组排列</code></pre><pre><code class="language-java">class Foo {    public Foo() {    }    public void first(Runnable printFirst) throws InterruptedException {        // printFirst.run() outputs "first". Do not change or remove this line.        printFirst.run();    }    public void second(Runnable printSecond) throws InterruptedException {        // printSecond.run() outputs "second". Do not change or remove this line.        printSecond.run();    }    public void third(Runnable printThird) throws InterruptedException {        // printThird.run() outputs "third". Do not change or remove this line.        printThird.run();    }}</code></pre><h2 id="分析：">分析：</h2><p>不同函数需要按照预订的顺序执行，因此，可以使用信号量、锁等工具来控制不同函数的等待关系</p><p>方法 1：</p><p>一个锁  +  两个用作屏障的变量（可以是 boolean、int 等任意变量,主要是用来判断是否执行了 first、second 函数）</p><p>锁可以用 synchriozed 来实现</p><h1>2、交替打印</h1><p>多个函数，按照指定的顺序运行</p><pre><code class="language-java">给你一个类：class FooBar {  public void foo() {    for (int i = 0; i &lt; n; i++) {      print("foo");    }  }  public void bar() {    for (int i = 0; i &lt; n; i++) {      print("bar");    }  }}两个不同的线程将会共用一个 FooBar 实例：线程 A 将会调用 foo() 方法，而线程 B 将会调用 bar() 方法请设计修改程序，以确保 "foobar" 被输出 n 次。 示例 1：输入：n = 1输出："foobar"解释：这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，"foobar" 将被输出一次。示例 2：输入：n = 2输出："foobarfoobar"解释："foobar" 将被输出两次。 提示：1 &lt;= n &lt;= 1000</code></pre><h1>总结:</h1><h2 id="不同线程之间有依赖关系">不同线程之间有依赖关系</h2><p>使用信号量 Semaphore、Lock、Synchronized</p><h2 id="多个线程之间，需要等待共同结束">多个线程之间，需要等待共同结束</h2><p>可以使用 CycleBarrier</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized</title>
      <link href="/2024/09/01/Synchronized/"/>
      <url>/2024/09/01/Synchronized/</url>
      
        <content type="html"><![CDATA[<p>JVM自带的</p><p>在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。</p><p>关于偏向锁多补充一点：由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK15 中，偏向锁被默认关闭（仍然可以使用 -XX:+UseBiasedLocking 启用偏向锁），在 JDK18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p><p>基于对象监视器，在对象头中的mark word里</p><p>wait、notify也依赖对象监视器，因此，synchronized和wait、notify要配合使用</p><p>仅保障执行结果的有序性，而不保障指令重排序的有序性</p><h1>关键字</h1><p>monitorenter、monitorexit 实现修饰代码块</p><p>ACC_SYNCHRONIZED 实现修饰同步方法</p><p><font style="color:#DF2A3F;">均是基于 Monitor 实现的</font></p><h3 id="Monitor-（内部锁）">Monitor （内部锁）</h3><p>两个队列：</p><p>_WaitSet、_EntryList</p><p>_owner:</p><h1>锁升级</h1><p>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><p>MarkWord 变化</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1723974786599-67346480-8f29-4b6a-92fa-ee712089462b.png" alt=""></p><h2 id="偏向锁：（jdk18-中被废除）">偏向锁：（jdk18 中被废除）</h2><p>markword中记录偏向的线程id</p><h2 id="轻量级锁：">轻量级锁：</h2><p>检测偏向线程id不是当前的线程，立即撤销</p><p><font style="color:rgb(0, 0, 0);">每个线程生成LockRecord ( LR )，并尝试自旋cas设置到markword中的线程id</font></p><h2 id="重量级锁：-即-Monitor-的内部锁）">重量级锁：(即 Monitor 的内部锁）</h2><p>轻量级锁cas次数达到阈值 or 线程个数超过阈值，则升级到重量级锁</p><p>需要请求操作系统介入，内核管控</p><h2 id="Synchronized-的锁优化">Synchronized 的锁优化</h2><ul><li>适应性自旋</li></ul><p>即上面的自旋锁</p><ul><li>锁消除</li></ul><p>编译期的优化</p><ul><li>锁粗化</li></ul><p>应该 也是编译期的优化</p><h1>参考文档：</h1><p>1、<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E4%B9%90%E8%A7%82%E9%94%81%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E4%B9%90%E8%A7%82%E9%94%81%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98</a><br>2、<a href="https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw">https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2024/09/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/09/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1720252492671-f4d85326-032b-4029-863b-1aea8da41d0e.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_950%2Climit_0" alt=""></p><h1>关键字：</h1><p>Executor顶层接口 -&gt; ExecutorService -&gt; <font style="color:#080808;background-color:#ffffff;">AbstractExecutorService 抽象类</font></p><p><font style="color:#080808;background-color:#ffffff;">RunnableFuture顶层任务类 -&gt; 任务包装类：FutureTask</font></p><p><font style="color:#080808;background-color:#ffffff;">代表了一个一次性的计算过程，内部 有一个volatile的字段state，来表示任务的状态</font></p><p><font style="color:#080808;background-color:#ffffff;">ThreadPoolExecutor：最常用的线程池，有七个参数：最小核心数、最大核心数、保活时间、保活时间单位，线程工厂，任务队列、丢弃策略</font></p><p><font style="color:#080808;background-color:#ffffff;">Worker：ThreadPoolExecutor 中的线程包装类，继承了 Runnable 接口 ，用来封装线程池中的工作线程</font></p><p><font style="color:#080808;background-color:#ffffff;"></font></p><h2 id="font-style-color-080808-background-color-ffffff-线程状态-font"><font style="color:#080808;background-color:#ffffff;">线程状态</font></h2><p>线程的状态转换图</p><h2 id="线程池状态">线程池状态</h2><p>线程池的状态转换图</p><h2 id="线程池原理">线程池原理</h2><h3 id="线程添加、运行原理">线程添加、运行原理</h3><h2 id="ForkJoin-线程池">ForkJoin 线程池</h2><h1><font style="color:#080808;background-color:#ffffff;">组件的内容简单讲解</font></h1><h2 id="ExecutorService：顶层抽象类">ExecutorService：顶层抽象类</h2><p>只有一个 execute 的方法，在具体的实现类中实现</p><h2 id="ExecutorService：接口类">ExecutorService：接口类</h2><p>定义了线程提交（submit）、批量提交（invokeAll）、关闭（shutdown）的方法定义</p><h2 id="font-style-color-080808-background-color-ffffff-AbstractExecutorService：线程池的抽象类-font"><font style="color:#080808;background-color:#ffffff;">AbstractExecutorService：线程池的抽象类</font></h2><p>模板方法，定义了线程池ExecutorService的基本操作流程，将具体的 execute 方法的实现，放到具体的子类中实现</p><p>使用newTaskFor方法，对Runnable、Callable进行了包装，包装为一个<font style="color:#080808;background-color:#ffffff;">RunnableFuture</font></p><p>�的实现类：FutureTask对象</p><h2 id="font-style-color-080808-background-color-ffffff-FutureTask-font"><font style="color:#080808;background-color:#ffffff;">FutureTask</font></h2><p>内部有一个<font style="color:#080808;background-color:#ffffff;">Callable的对象，由RunnableAdapter包装，用于封装返回值</font></p><p><font style="color:#080808;background-color:#ffffff;"></font></p><p><font style="color:#080808;background-color:#ffffff;">代表了一个一次性的计算过程，来表示任务的状态</font></p><ul><li><font style="color:#080808;background-color:#ffffff;">volatile  </font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">int </font><font style="color:#080808;background-color:#ffffff;">state：状态字段,表示当前任务的状态</font></li><li><font style="color:#080808;background-color:#ffffff;">volatile </font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">WaitNode </font><font style="color:rgb(51, 51, 51);">waiters：</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">用来存储那些正在等待任务结果的线程的，链表结构</font></li><li><font style="color:#080808;background-color:#ffffff;">volatile outcome:</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">来存储任务执行的结果或抛出的异常。当任务完成时，结果会存储在这个字段中，供后续调用get()方法时返回。</font></li><li><font style="background-color:rgb(247, 249, 253);">Callable<v> callable：这是任务的实际计算逻辑，FutureTask在构造时接收一个Callable对象，并在后台线程中执行它的call()方法。</v></font></li><li><font style="background-color:rgb(247, 249, 253);">volatile Thread runner：这个字段用来记录哪个线程正在执行任务。这是为了确保任务只被执行一次，并且在取消任务时可能需要中断这个线程。</font></li><li><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">stateOffset、runnerOffset、waitersOffset：几个使用Unsafe机制可以直接进行原子操作的偏移量，直接使用硬件级别的原子操作来控制并发，</font><font style="color:#DF2A3F;background-color:rgb(247, 249, 253);">这样可以在某些场景下提供更好的性能</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">。但是，这种方式写出的代码可读性较差，且容易出错，因此在日常开发中并不推荐使用。</font></li></ul><h2 id="font-style-color-080808-background-color-ffffff-font"><font style="color:#080808;background-color:#ffffff;"></font></h2><h2 id="font-style-color-080808-background-color-ffffff-AbstractExecutorService-的实现类：四个-font"><font style="color:#080808;background-color:#ffffff;">AbstractExecutorService 的实现类：四个</font></h2><h4 id="Executors：工具类-，对下面几个实现的封装">Executors：工具类 ，对下面几个实现的封装</h4><h4 id="ForkJoinPool：合并拆分的线程池">ForkJoinPool：合并拆分的线程池</h4><h4 id="font-style-color-080808-background-color-ffffff-ScheduledThreadPoolExecutor：定时调度的线程池-font"><font style="color:#080808;background-color:#ffffff;">ScheduledThreadPoolExecutor：定时调度的线程池</font></h4><h4 id="font-style-color-080808-background-color-ffffff-ThreadPoolExecutor：最常用的线程池-font"><font style="color:#080808;background-color:#ffffff;">ThreadPoolExecutor：最常用的线程池</font></h4><p>添加了动态修改最大核心数、最小核心数、保活时间、线程工厂、拒绝策略等参数的能力</p><p>实现了 shutdown()、shutdowmNow()、execute/submit 等抽象类中的方法</p><p>提供了扩展方法：<font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">beforeExecute、afterExecute、terminated 等方法，可以在任务运行前后，做一些扩展</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">核心方法：</font><font style="color:#080808;background-color:#ffffff;">runWorker(Worker)</font></p><p><font style="color:#080808;background-color:#ffffff;"></font></p><p><font style="color:#080808;background-color:#ffffff;">�</font></p><h2 id="Worker-font-style-color-080808-background-color-ffffff-ThreadPoolExecutor-的内部类，-font-实现了-Runnable">Worker:<font style="color:#080808;background-color:#ffffff;">ThreadPoolExecutor 的内部类，</font>实现了 Runnable</h2><p>继承了 AQS,用于对线程的状态进行加锁，用来判断可以中断</p><p>构造函数为 firstTask，在构造函数里，会调用线程工厂，去 new 一个线程 Thread，runnable 对象为自己</p><h1>重点：<font style="color:rgb(44, 62, 80);">ThreadPoolExecutor</font></h1><p>构造参数：7个</p><p>核心线程数、最大线程数</p><p>睡眠时间、睡眠时间单位</p><p>线程工厂、任务队列、拒绝策略</p><p>线程池的构造方法：</p><p>1、直接创建<font style="color:rgb(44, 62, 80);">ThreadPoolExecutor</font></p><p><font style="color:rgb(44, 62, 80);">2、通过Excutor的工具类</font><strong><font style="color:rgb(44, 62, 80);">Executors</font></strong><font style="color:rgb(44, 62, 80);">来创建（阿里巴巴开发规范不允许使用这种方式）</font></p><p><font style="color:rgb(44, 62, 80);"></font></p><h2 id="font-style-color-rgb-44-62-80-原理-font"><font style="color:rgb(44, 62, 80);">原理</font></h2><p>组成部分：</p><p><font style="color:#080808;background-color:#ffffff;">ctl：一个 AtomicInteger 变量，高位代表线程池的状态，低位代表当前活跃的线程数</font></p><p><font style="color:#080808;background-color:#ffffff;">�mainLock：用来控制线程状态的锁</font></p><p><font style="color:#080808;background-color:#ffffff;">HashSet<worker> workers ：</worker></font></p><p><font style="color:#080808;background-color:#ffffff;">Worker：封装了的执行线程</font></p><p><font style="color:#080808;background-color:#ffffff;"></font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1709653974278-3cb688aa-17d5-4031-a6bb-3fb60a909672.png" alt=""></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1720252492671-f4d85326-032b-4029-863b-1aea8da41d0e.png" alt=""></p><p>submit操作：</p><p><font style="color:#080808;background-color:#ffffff;">newTaskFor</font></p><p><font style="color:#080808;background-color:#ffffff;">使用FutureTask包装任务</font></p><p><font style="color:#080808;background-color:#ffffff;">execute：交由具体的子类实现</font></p><h2 id="锁">锁</h2><h3 id="每个-Worker-自己的锁">每个 Worker 自己的锁</h3><h3 id="线程池的全局锁">线程池的全局锁</h3><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">mainLock，是个ReentrantLock（可重入锁），是个</font></p><h2 id="中断">中断</h2><h3 id="可能发生中断的情况">可能发生中断的情况</h3><p>1 、调用了 shutdownNow()</p><p>设置线程池的状态为 stop，停止添加新的任务，对现有的所有线程，设置其中断位，由各个线程自己去检查处理</p><p>2、任务取消</p><p>对于提交的 Future 类型的任务，可以通过其 cancel 方法取消</p><p>3、线程被中断，在应用中手动调用 interrupt(),导致线程被中断</p><p>线程被中断后，应该及时检查终端标志位，及时清理资源，并退出</p><p>还应该注册关闭钩子：<font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">Runtime.getRuntime().addShutdownHook(Thread hook)，在JVM退出时优雅地关闭线程池</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">在里面调用 shuwdownNow()、shutdown()，及时关闭线程，并根据需要，等待线程执行完毕</font></p><h2 id="重点流程">重点流程</h2><h3 id="execute：添加线程的主要方法">execute：添加线程的主要方法</h3><p>判断当前线程池的大小，若小于 coreSize，则尝试通过 addWorker 添加线程</p><p>否则，若向阻塞队列中添加任务失败</p><p>则也通过 addWorker 创建线程</p><p>若创建向队列添加成功</p><p>则再次检线程数，若线程数为 0，则 调用 addWorker，则补充 worker（firstTask 为 null)</p><p>添加 worker 失败，则调用拒绝策略进行处理</p><h3 id="addWorker（提交任务时候用）">addWorker（提交任务时候用）</h3><pre><code class="language-json"> private boolean addWorker(Runnable firstTask, boolean core) {        retry:        for (;;) {            int c = ctl.get();            int rs = runStateOf(c);            // Check if queue empty only if necessary.            if (rs &gt;= SHUTDOWN &amp;&amp;                ! (rs == SHUTDOWN &amp;&amp;                   firstTask == null &amp;&amp;                   ! workQueue.isEmpty()))                return false;            for (;;) {                int wc = workerCountOf(c);                if (wc &gt;= CAPACITY ||                    wc &gt;= (core ? corePoolSize : maximumPoolSize))                    return false;                if (compareAndIncrementWorkerCount(c))                    break retry;                c = ctl.get();  // Re-read ctl                if (runStateOf(c) != rs)                    continue retry;                // else CAS failed due to workerCount change; retry inner loop            }        }        boolean workerStarted = false;        boolean workerAdded = false;        Worker w = null;        try {            w = new Worker(firstTask);            final Thread t = w.thread;            if (t != null) {                final ReentrantLock mainLock = this.mainLock;                mainLock.lock();                try {                    // Recheck while holding lock.                    // Back out on ThreadFactory failure or if                    // shut down before lock acquired.                    int rs = runStateOf(ctl.get());                    if (rs &lt; SHUTDOWN ||                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {                        if (t.isAlive()) // precheck that t is startable                            throw new IllegalThreadStateException();                        workers.add(w);                        int s = workers.size();                        if (s &gt; largestPoolSize)                            largestPoolSize = s;                        workerAdded = true;                    }                } finally {                    mainLock.unlock();                }                if (workerAdded) {                    t.start();                    workerStarted = true;                }            }        } finally {            if (! workerStarted)                addWorkerFailed(w);        }        return workerStarted;    }</code></pre><p>流程概述：</p><p>1、判断线程数是否大于 coreSize、MxSize</p><p>2、生成 Worker，插入 workers，启动线程</p><h4 id="ThreadPoolExecutor中添加worker的流程">ThreadPoolExecutor中添加worker的流程</h4>      <div class="plantuml-container">        <!--?xml version="1.0" encoding="UTF-8" standalone="no"?--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentscripttype="application/ecmascript" contentstyletype="text/css" height="1466px" preserveAspectRatio="none" style="width:471px;height:1466px;" version="1.1" viewBox="0 0 471 1466" width="471px" zoomAndPan="magnify"><defs><filter height="300%" id="fxnhufe" width="300%" x="-1" y="-1"><feGaussianBlur result="blurOut" stdDeviation="2.0"></feGaussianBlur><feColorMatrix in="blurOut" result="blurOut2" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 .4 0"></feColorMatrix><feOffset dx="4.0" dy="4.0" in="blurOut2" result="blurOut3"></feOffset><feBlend in="SourceGraphic" in2="blurOut3" mode="normal"></feBlend></filter></defs><g><ellipse cx="262.375" cy="20" fill="#000000" filter="url(#fxnhufe)" rx="10" ry="10" style="stroke: none; stroke-width: 1.0;"></ellipse><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="81" x="221.875" y="50"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="61" x="231.875" y="71.6016">获取ctl状态</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="166.375,104.1328,358.375,104.1328,370.375,116.1328,358.375,128.1328,166.375,128.1328,154.375,116.1328,166.375,104.1328" style="stroke: #A80036; stroke-width: 1.5;"></polygon><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="192" x="166.375" y="120.29">线程池是否正在停止且不满足添加条件?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="18" x="136.375" y="113.8125">yes</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="14" x="370.375" y="113.8125">no</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="71" x="108.875" y="138.1328"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="51" x="118.875" y="159.7344">返回false</text><ellipse cx="144.375" cy="204.6992" fill="none" filter="url(#fxnhufe)" rx="10" ry="10" style="stroke: #000000; stroke-width: 1.0;"></ellipse><ellipse cx="144.875" cy="205.1992" fill="#000000" filter="url(#fxnhufe)" rx="6" ry="6" style="stroke: none; stroke-width: 1.0;"></ellipse><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="140" x="192.375" y="234.6992"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="120" x="202.375" y="256.3008">检查工作线程数量限制</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="166.375,288.832,358.375,288.832,370.375,300.832,358.375,312.832,166.375,312.832,154.375,300.832,166.375,288.832" style="stroke: #A80036; stroke-width: 1.5;"></polygon><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="192" x="166.375" y="304.9893">工作线程计数超过CAPACITY或池大小?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="18" x="136.375" y="298.5117">yes</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="14" x="370.375" y="298.5117">no</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="71" x="108.875" y="322.832"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="51" x="118.875" y="344.4336">返回false</text><ellipse cx="144.375" cy="389.3984" fill="none" filter="url(#fxnhufe)" rx="10" ry="10" style="stroke: #000000; stroke-width: 1.0;"></ellipse><ellipse cx="144.875" cy="389.8984" fill="#000000" filter="url(#fxnhufe)" rx="6" ry="6" style="stroke: none; stroke-width: 1.0;"></ellipse><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="164" x="180.375" y="419.3984"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="144" x="190.375" y="441">尝试原子增加工作线程计数</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="237.875,473.5313,286.875,473.5313,298.875,485.5313,286.875,497.5313,237.875,497.5313,225.875,485.5313,237.875,473.5313" style="stroke: #A80036; stroke-width: 1.5;"></polygon><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="49" x="237.875" y="489.6885">是否成功?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="18" x="207.875" y="483.2109">yes</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="14" x="298.875" y="483.2109">no</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="81" x="304.375" y="507.5313"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="61" x="314.375" y="529.1328">重新读取ctl</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="292.875,561.6641,396.875,561.6641,408.875,573.6641,396.875,585.6641,292.875,585.6641,280.875,573.6641,292.875,561.6641" style="stroke: #A80036; stroke-width: 1.5;"></polygon><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="104" x="292.875" y="577.8213">线程池状态是否改变?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="18" x="262.875" y="571.3438">yes</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="14" x="408.875" y="571.3438">no</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="92" x="224.875" y="595.6641"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="72" x="234.875" y="617.2656">继续外层循环</text><ellipse cx="270.875" cy="659.7969" fill="none" filter="url(#fxnhufe)" rx="10" ry="10" style="stroke: #000000; stroke-width: 1.0;"></ellipse><ellipse cx="271.375" cy="660.2969" fill="#000000" filter="url(#fxnhufe)" rx="6" ry="6" style="stroke: none; stroke-width: 1.0;"></ellipse><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="92" x="372.875" y="595.6641"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="72" x="382.875" y="617.2656">继续内层循环</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="262.375,679.7969,274.375,691.7969,262.375,703.7969,250.375,691.7969,262.375,679.7969" style="stroke: #A80036; stroke-width: 1.5;"></polygon><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="133" x="195.875" y="723.7969"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="113" x="205.875" y="745.3984">创建新的Worker对象</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="92" x="216.375" y="777.9297"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="72" x="226.375" y="799.5313">尝试获取主锁</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="212.875,832.0625,311.875,832.0625,323.875,844.0625,311.875,856.0625,212.875,856.0625,200.875,844.0625,212.875,832.0625" style="stroke: #A80036; stroke-width: 1.5;"></polygon><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="99" x="212.875" y="848.2197">再次检查线程池状态</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="44" x="156.875" y="841.7422">满足条件</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="55" x="323.875" y="841.7422">不满足条件</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="128" x="115.75" y="866.0625"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="108" x="125.75" y="887.6641">检查线程是否已启动</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="149.75,920.1953,209.75,920.1953,221.75,932.1953,209.75,944.1953,149.75,944.1953,137.75,932.1953,149.75,920.1953" style="stroke: #A80036; stroke-width: 1.5;"></polygon><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="60" x="149.75" y="936.3525">线程已启动?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="18" x="119.75" y="929.875">yes</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="14" x="221.75" y="929.875">no</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="203" x="10" y="954.1953"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="183" x="20" y="975.7969">抛出IllegalThreadStateException</text><ellipse cx="111.5" cy="1020.7617" fill="none" filter="url(#fxnhufe)" rx="10" ry="10" style="stroke: #000000; stroke-width: 1.0;"></ellipse><ellipse cx="112" cy="1021.2617" fill="#000000" filter="url(#fxnhufe)" rx="6" ry="6" style="stroke: none; stroke-width: 1.0;"></ellipse><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="179" x="90.25" y="1050.7617"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="159" x="100.25" y="1072.3633">将Worker添加到workers集合</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="128" x="115.75" y="1104.8945"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="108" x="125.75" y="1126.4961">更新最大线程池大小</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="120" x="119.75" y="1159.0273"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="100" x="129.75" y="1180.6289">标记worker已添加</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="104" x="293" y="866.0625"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="84" x="303" y="887.6641">释放主锁并退出</text><ellipse cx="345" cy="930.1953" fill="none" filter="url(#fxnhufe)" rx="10" ry="10" style="stroke: #000000; stroke-width: 1.0;"></ellipse><ellipse cx="345.5" cy="930.6953" fill="#000000" filter="url(#fxnhufe)" rx="6" ry="6" style="stroke: none; stroke-width: 1.0;"></ellipse><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="68" x="228.375" y="1213.1602"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="48" x="238.375" y="1234.7617">释放主锁</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="92" x="216.375" y="1267.293"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="72" x="226.375" y="1288.8945">启动工作线程</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="204.875,1321.4258,319.875,1321.4258,331.875,1333.4258,319.875,1345.4258,204.875,1345.4258,192.875,1333.4258,204.875,1321.4258" style="stroke: #A80036; stroke-width: 1.5;"></polygon><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="115" x="204.875" y="1337.583">工作线程是否成功启动?</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="18" x="174.875" y="1331.1055">yes</text><text fill="#000000" font-family="sans-serif" font-size="11" lengthAdjust="spacingAndGlyphs" textLength="14" x="331.875" y="1331.1055">no</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="67" x="149.375" y="1355.4258"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="47" x="159.375" y="1377.0273">返回true</text><rect fill="#FEFECE" filter="url(#fxnhufe)" height="34.1328" rx="12.5" ry="12.5" style="stroke: #A80036; stroke-width: 1.5;" width="92" x="295.875" y="1355.4258"></rect><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacingAndGlyphs" textLength="72" x="305.875" y="1377.0273">处理启动失败</text><polygon fill="#FEFECE" filter="url(#fxnhufe)" points="262.375,1395.5586,274.375,1407.5586,262.375,1419.5586,250.375,1407.5586,262.375,1395.5586" style="stroke: #A80036; stroke-width: 1.5;"></polygon><ellipse cx="262.375" cy="1449.5586" fill="none" filter="url(#fxnhufe)" rx="10" ry="10" style="stroke: #000000; stroke-width: 1.0;"></ellipse><ellipse cx="262.875" cy="1450.0586" fill="#000000" filter="url(#fxnhufe)" rx="6" ry="6" style="stroke: none; stroke-width: 1.0;"></ellipse><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="30" y2="50"></line><polygon fill="#A80036" points="258.375,40,262.375,50,266.375,40,262.375,44" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="144.375" x2="144.375" y1="172.2656" y2="194.6992"></line><polygon fill="#A80036" points="140.375,184.6992,144.375,194.6992,148.375,184.6992,144.375,188.6992" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="154.375" x2="144.375" y1="116.1328" y2="116.1328"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="144.375" x2="144.375" y1="116.1328" y2="138.1328"></line><polygon fill="#A80036" points="140.375,128.1328,144.375,138.1328,148.375,128.1328,144.375,132.1328" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="370.375" x2="380.375" y1="116.1328" y2="116.1328"></line><polygon fill="#A80036" points="376.375,164.6992,380.375,174.6992,384.375,164.6992,380.375,168.6992" style="stroke: #A80036; stroke-width: 1.5;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="380.375" x2="380.375" y1="116.1328" y2="219.6992"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="380.375" x2="262.375" y1="219.6992" y2="219.6992"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="219.6992" y2="234.6992"></line><polygon fill="#A80036" points="258.375,224.6992,262.375,234.6992,266.375,224.6992,262.375,228.6992" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="84.1328" y2="104.1328"></line><polygon fill="#A80036" points="258.375,94.1328,262.375,104.1328,266.375,94.1328,262.375,98.1328" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="144.375" x2="144.375" y1="356.9648" y2="379.3984"></line><polygon fill="#A80036" points="140.375,369.3984,144.375,379.3984,148.375,369.3984,144.375,373.3984" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="154.375" x2="144.375" y1="300.832" y2="300.832"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="144.375" x2="144.375" y1="300.832" y2="322.832"></line><polygon fill="#A80036" points="140.375,312.832,144.375,322.832,148.375,312.832,144.375,316.832" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="370.375" x2="380.375" y1="300.832" y2="300.832"></line><polygon fill="#A80036" points="376.375,349.3984,380.375,359.3984,384.375,349.3984,380.375,353.3984" style="stroke: #A80036; stroke-width: 1.5;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="380.375" x2="380.375" y1="300.832" y2="404.3984"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="380.375" x2="262.375" y1="404.3984" y2="404.3984"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="404.3984" y2="419.3984"></line><polygon fill="#A80036" points="258.375,409.3984,262.375,419.3984,266.375,409.3984,262.375,413.3984" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="268.832" y2="288.832"></line><polygon fill="#A80036" points="258.375,278.832,262.375,288.832,266.375,278.832,262.375,282.832" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="270.875" x2="270.875" y1="629.7969" y2="649.7969"></line><polygon fill="#A80036" points="266.875,639.7969,270.875,649.7969,274.875,639.7969,270.875,643.7969" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="280.875" x2="270.875" y1="573.6641" y2="573.6641"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="270.875" x2="270.875" y1="573.6641" y2="595.6641"></line><polygon fill="#A80036" points="266.875,585.6641,270.875,595.6641,274.875,585.6641,270.875,589.6641" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="408.875" x2="418.875" y1="573.6641" y2="573.6641"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="418.875" x2="418.875" y1="573.6641" y2="595.6641"></line><polygon fill="#A80036" points="414.875,585.6641,418.875,595.6641,422.875,585.6641,418.875,589.6641" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="418.875" x2="418.875" y1="629.7969" y2="691.7969"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="418.875" x2="274.375" y1="691.7969" y2="691.7969"></line><polygon fill="#A80036" points="284.375,687.7969,274.375,691.7969,284.375,695.7969,280.375,691.7969" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="344.875" x2="344.875" y1="541.6641" y2="561.6641"></line><polygon fill="#A80036" points="340.875,551.6641,344.875,561.6641,348.875,551.6641,344.875,555.6641" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="225.875" x2="179.875" y1="485.5313" y2="485.5313"></line><polygon fill="#A80036" points="175.875,579.6641,179.875,589.6641,183.875,579.6641,179.875,583.6641" style="stroke: #A80036; stroke-width: 1.5;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.875" x2="179.875" y1="485.5313" y2="691.7969"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.875" x2="250.375" y1="691.7969" y2="691.7969"></line><polygon fill="#A80036" points="240.375,687.7969,250.375,691.7969,240.375,695.7969,244.375,691.7969" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="298.875" x2="344.875" y1="485.5313" y2="485.5313"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="344.875" x2="344.875" y1="485.5313" y2="507.5313"></line><polygon fill="#A80036" points="340.875,497.5313,344.875,507.5313,348.875,497.5313,344.875,501.5313" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="453.5313" y2="473.5313"></line><polygon fill="#A80036" points="258.375,463.5313,262.375,473.5313,266.375,463.5313,262.375,467.5313" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="703.7969" y2="723.7969"></line><polygon fill="#A80036" points="258.375,713.7969,262.375,723.7969,266.375,713.7969,262.375,717.7969" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="757.9297" y2="777.9297"></line><polygon fill="#A80036" points="258.375,767.9297,262.375,777.9297,266.375,767.9297,262.375,771.9297" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="111.5" x2="111.5" y1="988.3281" y2="1010.7617"></line><polygon fill="#A80036" points="107.5,1000.7617,111.5,1010.7617,115.5,1000.7617,111.5,1004.7617" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="137.75" x2="111.5" y1="932.1953" y2="932.1953"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="111.5" x2="111.5" y1="932.1953" y2="954.1953"></line><polygon fill="#A80036" points="107.5,944.1953,111.5,954.1953,115.5,944.1953,111.5,948.1953" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="221.75" x2="248" y1="932.1953" y2="932.1953"></line><polygon fill="#A80036" points="244,980.7617,248,990.7617,252,980.7617,248,984.7617" style="stroke: #A80036; stroke-width: 1.5;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="248" x2="248" y1="932.1953" y2="1035.7617"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="248" x2="179.75" y1="1035.7617" y2="1035.7617"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.75" x2="179.75" y1="1035.7617" y2="1050.7617"></line><polygon fill="#A80036" points="175.75,1040.7617,179.75,1050.7617,183.75,1040.7617,179.75,1044.7617" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.75" x2="179.75" y1="900.1953" y2="920.1953"></line><polygon fill="#A80036" points="175.75,910.1953,179.75,920.1953,183.75,910.1953,179.75,914.1953" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.75" x2="179.75" y1="1084.8945" y2="1104.8945"></line><polygon fill="#A80036" points="175.75,1094.8945,179.75,1104.8945,183.75,1094.8945,179.75,1098.8945" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.75" x2="179.75" y1="1139.0273" y2="1159.0273"></line><polygon fill="#A80036" points="175.75,1149.0273,179.75,1159.0273,183.75,1149.0273,179.75,1153.0273" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="345" x2="345" y1="900.1953" y2="920.1953"></line><polygon fill="#A80036" points="341,910.1953,345,920.1953,349,910.1953,345,914.1953" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="200.875" x2="179.75" y1="844.0625" y2="844.0625"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.75" x2="179.75" y1="844.0625" y2="866.0625"></line><polygon fill="#A80036" points="175.75,856.0625,179.75,866.0625,183.75,856.0625,179.75,860.0625" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="323.875" x2="345" y1="844.0625" y2="844.0625"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="345" x2="345" y1="844.0625" y2="866.0625"></line><polygon fill="#A80036" points="341,856.0625,345,866.0625,349,856.0625,345,860.0625" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.75" x2="179.75" y1="1193.1602" y2="1198.1602"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="179.75" x2="262.375" y1="1198.1602" y2="1198.1602"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="1198.1602" y2="1213.1602"></line><polygon fill="#A80036" points="258.375,1203.1602,262.375,1213.1602,266.375,1203.1602,262.375,1207.1602" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="812.0625" y2="832.0625"></line><polygon fill="#A80036" points="258.375,822.0625,262.375,832.0625,266.375,822.0625,262.375,826.0625" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="1247.293" y2="1267.293"></line><polygon fill="#A80036" points="258.375,1257.293,262.375,1267.293,266.375,1257.293,262.375,1261.293" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="192.875" x2="182.875" y1="1333.4258" y2="1333.4258"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="182.875" x2="182.875" y1="1333.4258" y2="1355.4258"></line><polygon fill="#A80036" points="178.875,1345.4258,182.875,1355.4258,186.875,1345.4258,182.875,1349.4258" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="331.875" x2="341.875" y1="1333.4258" y2="1333.4258"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="341.875" x2="341.875" y1="1333.4258" y2="1355.4258"></line><polygon fill="#A80036" points="337.875,1345.4258,341.875,1355.4258,345.875,1345.4258,341.875,1349.4258" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="182.875" x2="182.875" y1="1389.5586" y2="1407.5586"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="182.875" x2="250.375" y1="1407.5586" y2="1407.5586"></line><polygon fill="#A80036" points="240.375,1403.5586,250.375,1407.5586,240.375,1411.5586,244.375,1407.5586" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="341.875" x2="341.875" y1="1389.5586" y2="1407.5586"></line><line style="stroke: #A80036; stroke-width: 1.5;" x1="341.875" x2="274.375" y1="1407.5586" y2="1407.5586"></line><polygon fill="#A80036" points="284.375,1403.5586,274.375,1407.5586,284.375,1411.5586,280.375,1407.5586" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="1301.4258" y2="1321.4258"></line><polygon fill="#A80036" points="258.375,1311.4258,262.375,1321.4258,266.375,1311.4258,262.375,1315.4258" style="stroke: #A80036; stroke-width: 1.0;"></polygon><line style="stroke: #A80036; stroke-width: 1.5;" x1="262.375" x2="262.375" y1="1419.5586" y2="1439.5586"></line><polygon fill="#A80036" points="258.375,1429.5586,262.375,1439.5586,266.375,1429.5586,262.375,1433.5586" style="stroke: #A80036; stroke-width: 1.0;"></polygon></g></svg>      </div><h3 id="runWorker（Worker中调用，运行线程）">runWorker（Worker中调用，运行线程）</h3><p>run 方法中，是调用 addWorker(this),开启循环 loop：</p><p>while 循环捞取任务</p><p>加锁锁，设置不允许被其他线程中断</p><p>当捞取的任务为 null 时，表示当前线程可以被销毁了，则执行<font style="color:#080808;background-color:#ffffff;">processWorkerExit 方法，退出线程</font></p><p><font style="color:#080808;background-color:#ffffff;">当捞取的任务不为 bull</font></p><p><font style="color:#080808;background-color:#ffffff;">若线程池已经被中断，则也中断当前的线程</font></p><p>执行前置处理函数<font style="color:#080808;background-color:#ffffff;">beforeExecute</font></p><p><font style="color:#080808;background-color:#ffffff;">执行目标任务的 run 方法</font></p><p><font style="color:#080808;background-color:#ffffff;">执行后置处理函数</font><font style="color:#080808;background-color:#ffffff;">afterExecute</font></p><p>释放锁，设置可以被其他线程中断</p><h1>最佳实践</h1><h2 id="线程数设置">线程数设置</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1709654497659-4c3a1750-8736-4c35-80bb-742b52fc8d3b.png" alt=""></p><h3 id="N-1-CPU密集型">N+1(CPU密集型)</h3><p>1 是指为了避免CPU缺页中断，导致的CPU空闲，所以多了一个线程，去执行</p><h3 id="2N（IO密集型）">2N（IO密集型）</h3><h2 id="和ThreadLocal一起使用的坑">和ThreadLocal一起使用的坑</h2><p>由于线程池会共享线程，因此，从ThreadLocal中获取到数据，可能是上一个使用线程的场景留下的数据，有坑，需要及时remove掉</p><p>父子线程无法继承ThreadLocal中的值，可以使用<font style="color:#080808;background-color:#ffffff;">InheritableThreadLocal，但也只能在首次设置的时候，才能给子线程设值</font></p><h1></h1><h1>参考文档：</h1><p>1、硬核干货：4W字从源码上分析JUC线程池ThreadPoolExecutor的实现原理<a href="https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/">https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/</a></p><p>2、虚拟线程</p><p><a href="https://javaguide.cn/java/concurrent/virtual-thread.html">https://javaguide.cn/java/concurrent/virtual-thread.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future相关</title>
      <link href="/2024/09/01/Future%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/09/01/Future%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>JDK8 才引入的</p><h1>Future</h1><h1><font style="color:rgb(44, 62, 80);">CompletableFuture</font></h1><p>相当于一个task任务的编排工具</p><h2 id="font-style-color-rgb-44-62-80-CompletionStage-font"><font style="color:rgb(44, 62, 80);">CompletionStage</font></h2><p>异步计算阶段的接口，即被编排的任务内容</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK21新并发组件</title>
      <link href="/2024/09/01/JDK21%E6%96%B0%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/"/>
      <url>/2024/09/01/JDK21%E6%96%B0%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1>虚拟线程-概述</h1><p>JDK19实验、JDK21 以后上线 的新功能</p><p>基于ForkJoinPool，支持ThreadLocal、线程中断</p><h2 id="注意事项">注意事项</h2><p>仅适合运行有大量io阻塞的任务，不适合CPU密集型任务</p><p>避免使用ThreadLocal</p><p>注意虚拟线程固定（pinned）的情况（使用Synchorized、使用native方法）</p><p>平迁虚拟线程，不会影响现有现成逻辑的正确性，但可能会影响性能</p><h2 id="原理">原理</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1720254183956-c5dabf7b-1e4b-41ce-a2f3-66a4b24560ea.png" alt=""></p><h2 id="线程模型">线程模型</h2><p><font style="color:rgb(37, 41, 51);">线程需要被调度才能执行任务，本质上是分配到CPU上执行。对于由操作系统线程实现的平台线程，JDK 依赖于操作系统中的调度程序；而对于虚拟线程，JDK 先将虚拟线程分配给平台线程，然后平台线程按照通常的方式由操作系统进行调度。</font></p><p><font style="color:rgb(37, 41, 51);">JDK 的虚拟线程调度器是一个以 FIFO 模式运行的 </font><font style="color:#DF2A3F;">ForkJoinPool</font><font style="color:rgb(37, 41, 51);">，调度器的默认并行度是可用于调度虚拟线程的平台线程数量，并行度可以通过设置启动参数调整。</font></p><h2 id="基于ForkJoinPool">基于ForkJoinPool</h2><h1>StructuredTaskScope</h1><h2 id="原理-2">原理</h2><h1><font style="color:rgb(37, 41, 51);">参考</font></h1><p>1、<a href="https://juejin.cn/post/7280746515526058038?searchId=20240706160706A3E3F95BE22DA3D11B4E">https://juejin.cn/post/7280746515526058038?searchId=20240706160706A3E3F95BE22DA3D11B4E</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ForkJoinPool</title>
      <link href="/2024/09/01/ForkJoinPool/"/>
      <url>/2024/09/01/ForkJoinPool/</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p>对大任务，分而治之</p><p>适合CPU密集型</p><p>工作现成之间可以窃取任务</p><p><font style="color:rgb(51, 51, 51);">都实现了Executor和ExecutorService接口，并继承了AbstractExecutorService抽类</font></p><p><font style="color:rgb(51, 51, 51);">两种任务类型：</font><strong><font style="color:rgb(62, 175, 124);">RecursiveAction（无结果）</font></strong><font style="color:rgb(51, 51, 51);">和</font><strong><font style="color:rgb(62, 175, 124);">RecursiveTask（有结果）</font></strong></p><p><strong><font style="color:rgb(62, 175, 124);"></font></strong></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1720254632230-a60be1e0-4395-4638-9e79-c9e7b3a4584e.png" alt=""></p><h1>原理</h1><h2 id="线程池：-font-style-color-rgb-51-51-51-commonPool-font">线程池：<font style="color:rgb(51, 51, 51);">commonPool</font></h2><h2 id="四个参数：">四个参数：</h2><p><strong><font style="color:rgb(62, 175, 124);">并行数</font></strong><font style="color:rgb(51, 51, 51);">、</font><strong><font style="color:rgb(62, 175, 124);">工作线程的创建</font></strong><font style="color:rgb(51, 51, 51);">、</font><strong><font style="color:rgb(62, 175, 124);">异常处理</font></strong><font style="color:rgb(51, 51, 51);">和</font><strong><font style="color:rgb(62, 175, 124);">模式指定</font></strong><font style="color:rgb(51, 51, 51);">等</font></p><h2 id="抽象任务：ForkJoinTask">抽象任务：ForkJoinTask</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1720254846747-11a0b7a5-8e5c-47ed-8349-67983cddf8e7.png" alt=""></p><h2 id="核心方法：fork、join">核心方法：fork、join</h2><h2 id="任务窃取">任务窃取</h2><p>允许从任务队列的双端，窃取任务进行执行</p><p>双端队列：pop、push、<font style="color:#DF2A3F;">poll</font></p><p>从队列尾部窃取：降低多线程的对队列的竞争</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1720255020303-59b04ab1-10d7-4424-a887-e41427e6a566.png" alt=""></p><h3 id="两个假设：">两个假设：</h3><p>队列中较旧的任务，可能颗粒度比较大，仍然需要进一步拆分-&gt; 工作线程从头部获取任务来执行</p><p>最近提交的任务，缓存命中率可能较高-&gt; 始终选择最近提交的任务去执行</p><h1>用处：</h1><p>1、JDK8中的**<font style="color:rgb(62, 175, 124);">CompletableFuture、并行流</font>**</p><p>2、JDK21中的**<font style="color:rgb(62, 175, 124);">虚拟线程</font>**</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2024/09/01/ThreadLocal/"/>
      <url>/2024/09/01/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<p><font style="color:rgb(52, 53, 65);">ThreadLocal 是 Java 中的一个类，用于实现线程封闭（Thread-local）的数据存储机制。</font><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">每个线程都有自己的 ThreadLocalMap，其中 ThreadLocal 对象充当键，线程的变量副本作为对应键的值。使用 ThreadLocal 的 </font><strong><font style="background-color:rgb(247, 247, 248);">set()</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 方法将数据存储在当前线程的 ThreadLocalMap 中，而使用 </font><strong><font style="background-color:rgb(247, 247, 248);">get()</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 方法则是从当前线程的 ThreadLocalMap 中获取数据副本。</font></p><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">这种机制</font><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">为每个线程维护独立的变量副本</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">，这样可以实现线程之间的数据隔离，从而有效地避免了线程安全问题。</font><font style="color:rgb(52, 53, 65);">这对于需要在线程内部存储线程特定数据的情况非常有用，例如数据库连接、用户会话信息等。但需要谨慎使用 ThreadLocal，确保在不再需要时及时清理变量副本，以避免潜在的内存泄漏问题。这种机制提供了一种有效的方式来确保线程级别的数据隔离和线程安全性。</font></p><p><font style="color:rgb(52, 53, 65);"></font></p><p><font style="color:rgb(52, 53, 65);"></font></p><h1><font style="color:rgb(52, 53, 65);">关键字</font></h1><h2 id="ThreadLocalMap">ThreadLocalMap</h2><h2 id="维护的-threadLocals-数组">维护的 threadLocals 数组</h2><h1>内部的Hash表（开放定址法）</h1><p>单独实现的一个hashtable，使用数据的方式，开放探测的方法解决hash冲突</p><h2 id="探测式清理：">探测式清理：</h2><p><font style="color:rgb(37, 41, 51);">探测式清理是以当前</font><font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">Entry</font><font style="color:rgb(37, 41, 51);"> 往后清理，遇到值为</font><font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">null</font><font style="color:rgb(37, 41, 51);">则结束清理，属于</font><strong><font style="color:rgb(37, 41, 51);">线性探测清理</font></strong><font style="color:rgb(37, 41, 51);">。</font></p><h2 id="启发式清理：">启发式清理：</h2><p><font style="color:rgb(51, 51, 51);">从当前节点开始，进行do-while循环检查清理过期key，结束条件是连续</font><font style="color:rgb(192, 52, 29);background-color:rgb(251, 229, 225);">n</font><font style="color:rgb(51, 51, 51);">次未发现过期key就跳出循环，n是经过位运算计算得出的，可以简单理解为数组长度的2的多少次幂 次，</font></p><h2 id="扩容逻辑：">扩容逻辑：</h2><p>大于 3/4 的容量，就扩容</p><p>创建新数组，迁移完毕后，就更新 table 的指向</p><h1>ThreadLocal 与InheritableThreadLocal</h1><p>ThreadLocal：子线程无法共享父线程的本地变量</p><p>InheritableThreadLocal：子线程可以共享父线程的本地变量，在创建线程的时候：new Thread() 的时候，但是在线程池中，无法很好的支持</p><p><font style="color:#DF2A3F;">仅共享初始值</font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1723973313200-1ac2e8cb-3c33-4270-92f2-6aade7c4e756.jpeg" alt="画板"></p><p>内部类Entry设置为WeakReference的原因，是为了当用户使用完ThreadLocal后，将Threadlocal变量设置为null后，GC能够回收掉ThreahlocalMap中的空间</p><h3 id="font-style-color-rgb-51-51-51-2-1-为什么ThreadLocal的key要使用弱引用？-font"><font style="color:rgb(51, 51, 51);">2.1 为什么ThreadLocal的key要使用弱引用？</font></h3><p><font style="color:#DF2A3F;">线程池的情况下，可能一直无法回收 key 对应的内存</font></p><p><font style="color:rgb(51, 51, 51);">🐸</font><font style="color:rgb(51, 51, 51);"> ThreadLocalMap 是线程的成员变量，只要线程还未结束，则会一直被</font><font style="color:rgb(192, 52, 29);background-color:rgb(251, 229, 225);">Thread</font><font style="color:rgb(51, 51, 51);">强引用着，假设 Entry 对象的 key 是对 ThreadLocal 对象的强引用，如果在其他地方都没有对这个 ThreadLocla 对象的引用了，然后在使用</font><font style="color:rgb(192, 52, 29);background-color:rgb(251, 229, 225);">ThreadLocalMap</font><font style="color:rgb(51, 51, 51);">的过程中又没有正确地在用完后就调用 remove 方法，</font><strong><font style="color:rgb(51, 51, 51);">所以这个 ThreadLocal 对象和所关联的 value 对象就会跟随着线程一直存在，这样可能会造成OOM。</font></strong></p><h3 id="font-style-color-rgb-51-51-51-2-2-为什么ThreadLocal的value不能使用弱引用？-font"><font style="color:rgb(51, 51, 51);">2.2 为什么ThreadLocal的value不能使用弱引用？</font></h3><p><font style="color:#DF2A3F;">避免获取到的值为 null，引起逻辑异常</font></p><p><font style="color:rgb(51, 51, 51);">🐸</font><strong><font style="color:rgb(51, 51, 51);">【假设Entry 的 value 是弱引用】</font></strong><font style="color:rgb(51, 51, 51);">：假设 key 所引用的 ThreadLocal 对象还被其他的引用对象强引用着，那么这个 ThreadLocal 对象就不会被 GC 回收，但如果 value 是弱引用且不被其他引用对象引用着，那 GC 的时候就被回收掉了，那线程通过 ThreadLocal 来获取 value 的时候就会获得 null，对我们来说，value 才是我们想要保存的数据，ThreadLcoal 只是用来关联 value 的，如果 value 都没了，还要 ThreadLocal 干嘛呢？</font><strong><font style="color:rgb(51, 51, 51);">所以 value 不能是弱引用</font></strong><font style="color:rgb(51, 51, 51);">。</font></p><h1>使用场景：</h1><p>1、链路监控，如阿里内部的鹰眼</p><p>2、分布式链路的日志记录</p><p>3、通用的登录功能</p><h1>缺点：</h1><p>1、没有权限控制</p><p>2、有内存泄露风险</p><h1>JDK21替代品：ScopedValue</h1><p>优点：</p><p>有生命周期</p><p>有作用域</p><h1>阿里巴巴的开源组件：<font style="color:rgb(44, 62, 80);">TransmittableThreadLocal</font></h1><p>原理：</p><p>1、有一个static final InheritableThreadLocal 的holder，value是一个WeakHashMap</p><p>map的key 是 <font style="color:rgb(44, 62, 80);">TransmittableThreadLocal </font>，value是 具体的对象</p><p>2、线程池，使用自己的方法，包了一层，在run的时候，会做一些操作，将InheritableThreadLocal的值进行传递</p><h1>参考文档：</h1><p>1、<a href="https://juejin.cn/post/6844904151567040519#heading-15">https://juejin.cn/post/6844904151567040519#heading-15</a></p><p>2、ThreadLocal为什么使用弱应用</p><p><a href="https://zhuanlan.zhihu.com/p/304240519?utm_id=0">https://zhuanlan.zhihu.com/p/304240519?utm_id=0</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/402856377">https://zhuanlan.zhihu.com/p/402856377</a></p><p>4、ScopedValue：<a href="https://juejin.cn/post/7287241480770928655">https://juejin.cn/post/7287241480770928655</a></p><p>5、<a href="https://www.cnblogs.com/lihw/p/17214194.html">https://www.cnblogs.com/lihw/p/17214194.html</a></p><p>6、<font style="color:rgb(44, 62, 80);">TransmittableThreadLocal</font></p><p><a href="https://www.cnblogs.com/sglx/p/16018266.html">https://www.cnblogs.com/sglx/p/16018266.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC-ReentrantReadWriteLock</title>
      <link href="/2024/09/01/JUC-ReentrantReadWriteLock/"/>
      <url>/2024/09/01/JUC-ReentrantReadWriteLock/</url>
      
        <content type="html"><![CDATA[<p>可重入读写锁</p><p>内部有</p><ul><li>1个读锁</li><li>1个写锁</li><li>1个sync</li></ul><h1>Sync</h1><p>属性：</p><ul><li><font style="color:#080808;background-color:#ffffff;">transient ThreadLocalHoldCounter readHolds;</font></li><li><font style="color:#080808;background-color:#ffffff;">Thread firstReader</font></li><li><font style="color:#080808;background-color:#ffffff;">HoldCounter cachedHoldCounter;</font></li><li><font style="color:#080808;background-color:#ffffff;">int firstReaderHoldCount;</font></li></ul><p><font style="color:#080808;background-color:#ffffff;"></font></p><h2 id="内部类：">内部类：</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/2366181/1709453774315-ab2592c5-bbe5-4c77-a46a-d10ad58ce05b.jpeg" alt="画板"></p><h3 id="font-style-color-080808-background-color-ffffff-HoldCounter-font"><font style="color:#080808;background-color:#ffffff;">HoldCounter</font></h3><p>保存线程id和应用次数�</p><h3 id="font-style-color-080808-background-color-ffffff-ThreadLocalHoldCounter-font"><font style="color:#080808;background-color:#ffffff;">ThreadLocalHoldCounter</font></h3><p>继承自ThreadLocal，用于记录<font style="color:#080808;background-color:#ffffff;">HoldCounter</font></p><p><font style="color:#080808;background-color:#ffffff;">用来记录各个线程获得读锁的次数，有threadLocal的方式去保存</font></p><p>�</p><h2 id="font-style-color-080808-background-color-ffffff-NonfairSync-font"><font style="color:#080808;background-color:#ffffff;">NonfairSync</font></h2><h2 id="font-style-color-080808-background-color-ffffff-FairSync-font"><font style="color:#080808;background-color:#ffffff;">FairSync</font></h2><p>�</p><h1><font style="color:#080808;background-color:#ffffff;">ReadLock</font></h1><p>支持重入的共享锁</p><h1><font style="color:#080808;background-color:#ffffff;">WriteLock</font></h1><p>支持重入的排他锁�</p><p>�</p><h1>锁升降级问题</h1><h2 id="没有锁升级">没有锁升级</h2><p>为了保证数据可见性。因此不允许获得读锁后，在获得写锁</p><h2 id="有锁降级">有锁降级</h2><p>先获取写锁，在获取读锁，</p><h1>参考文档：</h1><p>1、<a href="https://www.cnblogs.com/monco-sxy/p/13258508.html">https://www.cnblogs.com/monco-sxy/p/13258508.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC-StampedLock</title>
      <link href="/2024/09/01/JUC-StampedLock/"/>
      <url>/2024/09/01/JUC-StampedLock/</url>
      
        <content type="html"><![CDATA[<p>面试中问的少</p><p>jdk1.8中引入的，性能更好的读写锁，不可重入，且不支持condition</p><p>不直接基于AQS，而是另实现了一套AQS</p><p>使用不当易引发cpu飙高</p><p>和ReentrantReadWriteLock一样，用在读多写少的场景，但是比ReentrantReadWriteLock 性能更好点</p><p>参考文档：</p><p>1、<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#stampedlock-%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF">https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#stampedlock-%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF</a></p><p>2、专讲StampedLock的</p><p><a href="https://segmentfault.com/a/1190000015808032">https://segmentfault.com/a/1190000015808032</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC-ReentrantLock</title>
      <link href="/2024/09/01/JUC-ReentrantLock/"/>
      <url>/2024/09/01/JUC-ReentrantLock/</url>
      
        <content type="html"><![CDATA[<p>默认非公平</p><p>可重入锁，基于AQS</p><p>1、静态内部类Sync</p><p>实现了<font style="color:#080808;background-color:#ffffff;">tryRelease方法</font></p><p><font style="color:#080808;background-color:#ffffff;">自定义了nonfairTryAcquire() ：非公平的加锁</font></p><p>2、实现了Sync的两个子类</p><p><font style="color:#080808;background-color:#ffffff;">NonfairSync：</font></p><p><font style="color:#080808;background-color:#ffffff;">直接继承了Sync</font></p><p><font style="color:#080808;background-color:#ffffff;">FairSync：</font></p><p><font style="color:#080808;background-color:#ffffff;">覆写了tryAcquire，里面多了两个判断</font></p><p><font style="color:#080808;background-color:#ffffff;">即：若state等于0，再判断等待队列中是否有其他线程，</font></p><p>整体比较简单，都是使用setState和compareAndSetState，进行判断</p><h1>关键字</h1><h2 id="state：用来表示持有锁的次数，用于可重入">state：用来表示持有锁的次数，用于可重入</h2><h2 id="自定义的AQS：Sync">自定义的AQS：Sync</h2><p>内部实现了<font style="color:#080808;background-color:#ffffff;">tryRelease</font></p><h2 id="加锁：复写tryAcquire">加锁：复写tryAcquire</h2><p>通过cas加锁，尝试设置state为1</p><p>若成功，则加锁成功</p><p>若失败，则使用AQS的<font style="color:#080808;background-color:#ffffff;">acquire，阻塞地加锁</font></p><p><font style="color:#080808;background-color:#ffffff;">锁为非公平锁</font></p><h2 id="解锁：">解锁：</h2>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC-LockSupport</title>
      <link href="/2024/09/01/JUC-LockSupport/"/>
      <url>/2024/09/01/JUC-LockSupport/</url>
      
        <content type="html"><![CDATA[<p>AQS的基础，线程阻塞、唤醒的底层基础</p><p>有个凭证的概念</p><h2 id="面试题">面试题</h2><p>为什么可以先唤醒线程后阻塞线程？</p><p>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞。</p><p>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</p><p>因为凭证的数量最多为1（不能累加），连续调用两次 unpark和调用一次 unpark效果一样，只会增加一个凭证；而调用两次park却需要消费两个凭证，证不够，不能放行。</p><p>AQS的基础，线程阻塞、唤醒的底层基础</p><h1>基础方法</h1><ul><li>parkXXX()：阻塞当前线程<ul><li>增加了park(blockerObject): 用于可以获取阻塞在等待的对象，便于排查问题</li></ul></li><li>unpark(Thread)：唤醒指定线程</li></ul><h1>易错点：</h1><p>1、先unpark，后park，会怎样</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/2366181/1709355321007-acec57df-7b3b-4ef7-a090-1ed03a0ad20b.png" alt=""></p><h1>参考：</h1><p>1、<a href="https://blog.csdn.net/xushiyu1996818/article/details/103528041">https://blog.csdn.net/xushiyu1996818/article/details/103528041</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC-AQS原理</title>
      <link href="/2024/09/01/JUC-AQS%E5%8E%9F%E7%90%86/"/>
      <url>/2024/09/01/JUC-AQS%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>大量使用CAS进行操作</p><h1>关键字：</h1><h2 id="volatile-int-state-同步状态">volatile int state: 同步状态</h2><h2 id="等待队列（链表）：head、tail">等待队列（链表）：head、tail</h2><h2 id="等待节点Node-链表结构中的节点">等待节点Node:链表结构中的节点</h2><h2 id="acquire：尝试一次加锁，失败则入队列">acquire：尝试一次加锁，失败则入队列</h2><p>cas循环尝试，添加到队列尾</p><h2 id="acquireShared-加锁的操作">acquireShared:加锁的操作</h2><h2 id="tryAcquire、tryAcquireShared-需要被子类实现的方法">tryAcquire、tryAcquireShared:需要被子类实现的方法</h2><h2 id="release、releaseShared：解锁的操作">release、releaseShared：解锁的操作</h2><h2 id="tryRelease、tryReleaseShared：需要被子类实现的方法">tryRelease、tryReleaseShared：需要被子类实现的方法</h2><h1>AQS基本原理</h1><p>AQS（AbstractQueuedSynchronizer）是Java并发编程中的一个重要组件，它是一个抽象类，提供了线程同步的底层实现机制。AQS的作用是实现线程的同步和互斥操作，它提供了两种主要的锁机制，分别是排他锁和共享锁。<br>排他锁也称为独占锁，<strong>在多个线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源</strong>，即多个线程中只有一个线程获得锁资源。</p><p>在AQS中，排他锁是通过内置的同步状态来实现的。</p><ul><li>当同步状态为0时，表示锁是未被获取的；</li><li>当同步状态大于0时，表示锁已经被获取且被占用；</li><li>当同步状态小于0时，表示锁已经被获取但是处于等待状态。</li></ul><p>**共享锁允许多个线程同时获得锁资源，但是在同一时刻只有一个线程可以获取到锁的拥有权，其他线程需要等待该线程释放锁**。在AQS中，共享锁的实现与排他锁类似，也是通过内置的同步状态来实现的。<br>AQS通过一个内置的FIFO（先进先出）等待队列来实现线程的排队和调度。当线程需要获取锁资源时，如果锁已经被其他线程获取，则该线程会被加入到等待队列中等待。当锁被释放时，等待队列中的第一个线程会获得锁资源并继续执行。<br>在实现AQS时，需要继承自AQS类并实现其抽象方法。其中比较重要的方法包括：</p><ul><li>tryAcquire()和tryRelease()方法，用于实现锁的获取和释放；</li><li>acquire()和release()方法，用于实现阻塞和唤醒操作；isHeldExclusively()方法，用于判断是否是排他锁。</li></ul><p>总之，AQS是Java并发编程中的重要组件之一，它提供了线程同步的底层实现机制。在使用AQS时，需要根据具体的应用场景选择合适的锁机制来实现线程的同步和互斥操作。</p><h2 id="基本结构">基本结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/2366181/1709354555123-dc27a08f-8ef1-4f1e-870d-a3b22c68ddfb.jpeg" alt="画板"></p><p>int state:代表锁的状态（独占、非独占，取决于不同的实现子类）</p><p>队列：head节点代表当前加锁成功的线程；其余节点代表等待的线程</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/2366181/1709191582988-8fbb60b0-c295-443e-a3ff-d2128a07780f.png" alt=""></p><h3 id="基础API">基础API</h3><p>getState()</p><p>setState()</p><p>compareAndSetState()</p><h3 id="底层API">底层API</h3><p>enq():死循环，入等待队列，CAS实现</p><h4 id="属性架构">属性架构</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/2366181/1709353133838-bb133b3b-2ce3-4d3c-91cd-ef947c44c34a.png" alt=""></p><h3 id="Node">Node</h3><h4 id="节点的状态">节点的状态</h4><p><font style="color:rgb(0, 0, 0);">Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等</font></p><ul><li><strong><font style="color:rgb(0, 0, 255);">CANCELLED</font></strong><font style="color:rgb(0, 0, 0);">(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</font></li><li><strong><font style="color:rgb(0, 0, 255);">SIGNAL</font></strong><font style="color:rgb(0, 0, 0);">(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</font></li><li><strong><font style="color:rgb(0, 0, 255);">CONDITION</font></strong><font style="color:rgb(0, 0, 0);">(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将</font><strong><font style="color:rgb(0, 0, 0);">从等待队列转移到同步队列中</font></strong><font style="color:rgb(0, 0, 0);">，等待获取同步锁。</font></li><li><strong><font style="color:rgb(0, 0, 255);">PROPAGATE</font></strong><font style="color:rgb(0, 0, 0);">(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</font></li><li><strong><font style="color:rgb(0, 0, 255);">0</font></strong><font style="color:rgb(0, 0, 0);">：新结点入队时的默认状态。</font></li></ul><p><strong><font style="color:rgb(0, 0, 255);">负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</font></strong><font style="color:rgb(0, 0, 0);">。</font></p><h2 id="加锁">加锁</h2><p>判断是否有头结点</p><p>若有，则封装当前线程为Node，加入队列，并使用park()阻塞当前线程</p><h2 id="解锁">解锁</h2><p>由获取到锁的_线程，设置head节点到后一个节点，并断开head节点的链接，供回收_</p><p><em>然后唤醒下一个节点的线程，unpark()</em></p><h2 id="独占锁">独占锁</h2><p>AQS和子类合作实现独占锁，则子类Sync必须实现【<strong>tryAcquire() &amp;&amp; tryRelease()</strong>】</p><h3 id="acquire">acquire</h3><ul><li>acquire 是【<strong>独占模式</strong>】获取资源的方式</li></ul><p><font style="color:rgb(38, 38, 38);">流程分析</font></p><p><font style="color:rgb(38, 38, 38);">1、调用自定义同步器 tryAcquire()尝试获取资源，成功则直接返回<br></font><font style="color:rgb(38, 38, 38);">2、没成功，则addWaiter()将线程节点加入等待队列<br></font><font style="color:rgb(38, 38, 38);">3、acquireQueue 在等待队列中自旋尝试获取资源。unpark()时，则自旋获取。park(),则进入阻塞<br></font><font style="color:rgb(38, 38, 38);">4、只有资源获取后进行自我中断selfInterpt(),如果获取资源过程中线程中断，则selfInterpt()不相应</font></p><h4 id="font-style-color-rgb-38-38-38-tryAcquire-font"><font style="color:rgb(38, 38, 38);">tryAcquire</font></h4><p><font style="color:rgb(38, 38, 38);"></font></p><ul><li><font style="color:rgb(38, 38, 38);">getState() == 0 检测资源是否上锁</font></li><li><font style="color:rgb(38, 38, 38);">如果locked（state=1） ,则unlock ： 流程如下</font></li><font style="color:rgb(38, 38, 38);"></font></ul><font style="color:rgb(38, 38, 38);"></font><p><font style="color:rgb(38, 38, 38);"></font><font style="color:rgb(38, 38, 38);">1setExclusiveOwnerThread(null)解绑线程<br></font><font style="color:rgb(38, 38, 38);">2state=0逻辑解锁 </font></p><h4 id="font-style-color-rgb-38-38-38-acquireQueued-font"><font style="color:rgb(38, 38, 38);">acquireQueued()</font></h4><ul><li><font style="color:rgb(38, 38, 38);">在等待队列中获取资源，【</font><strong>自旋直到获取资源返回为止</strong><font style="color:rgb(38, 38, 38);">】</font></li></ul><pre><code class="language-java">    final boolean acquireQueued(final Node node, int arg) {        boolean failed = true;// 标记是否取得资源，默认未false        try {            boolean interrupted = false;// 标记等待过程中是否被中断            for (;;) {//自旋 尝试获取资源                final Node p = node.predecessor();                if (p == head &amp;&amp; tryAcquire(arg)) {                 // 当前线程节点node为首节点 &amp;&amp; 尝试获取资源成功                    setHead(node);// 将node设置为head                    p.next = null; // help GC                    failed = false;                    return interrupted;                }                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    // 根据prev.waitStatus 决定 park() &amp; 调用parkAndInterpt()实现park() 并检测是否interpt()                    interrupted = true;            }        } finally {        // 中断则跳转至finally 将节点从等待队列中取出            if (failed)                cancelAcquire(node);        }    }</code></pre><h5 id="font-style-color-rgb-38-38-38-流程分析-font"><font style="color:rgb(38, 38, 38);">流程分析</font></h5><ol><li><font style="color:rgb(38, 38, 38);">节点进入队尾后，检测prev.waitStatus，寻找安全休息点</font></li><li><font style="color:rgb(38, 38, 38);">通过park()进入waiting状态，等待unpark() || interpt()唤醒</font></li><li><font style="color:rgb(38, 38, 38);">if(自身是等待队列首节点 &amp;&amp; 尝试获取资源) </font><ul><li><font style="color:rgb(38, 38, 38);">资源获取成功则head指向当前节点，并return interpt ;即 [获取资源流程中是否被中断过]</font></li><li><font style="color:rgb(38, 38, 38);">否则，根据prev.waitStatus判断是否park() 跳转至流程1循环</font></li></ul></li></ol><h4 id="font-style-color-rgb-38-38-38-shouldParkAfterFailedAcquire-p-node-font"><font style="color:rgb(38, 38, 38);">shouldParkAfterFailedAcquire(p, node)</font></h4><ul><li><font style="color:rgb(38, 38, 38);">判断prev.waitStatus，对当前节点做出不同操作</font></li><li><font style="color:rgb(38, 38, 38);">整个流程中，prev.waitStatus != Node.SIGNAL;则不能park()安心休息。需要不断寻找安心的休息点，同时尝试自己是否能否获取资源。</font></li></ul><p><font style="color:rgb(38, 38, 38);"></font></p><pre><code class="language-java">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {        int ws = pred.waitStatus;        if (ws == Node.SIGNAL)            // prev节点处于 通知状态（release资源后会通知当前节点） ，则可进入waiting()            return true;        if (ws &gt; 0) {             // prev节点被CANCELLED，则不断跳过prev，直到寻找到最近【正常等待】的前驱节点            do {                node.prev = pred = pred.prev;            } while (pred.waitStatus &gt; 0);            pred.next = node;        } else {             // prev节点正常，则prev.waitStatus = Node.SIGNAL 设置为通知状态            compareAndSetWaitStatus(pred, ws, Node.SIGNAL); // 设置prev.waitStatus = Node.SIGNAL                   }        return false;    }</code></pre><h4 id="font-style-color-rgb-38-38-38-font-parkAndCheckInterrupt"><font style="color:rgb(38, 38, 38);"></font>parkAndCheckInterrupt()</h4><ul><li>【<strong>阻塞当前当前线程，并检测是否被中断</strong>】</li><li>park() 使当前线程进入waiting状态。<ul><li>解除waiting状态方法 ： unpark()唤醒 || interupt() 中断</li></ul></li></ul><h4 id="addWaiter-Node-model">addWaiter(Node model)</h4><ul><li>将该线程加入【<strong>等待队列尾部</strong>】，并【<strong>标记独占模式</strong>】</li><li>参数 Node model 含义： &nbsp;Node.EXCLUSIVE【独占模式】 || Node.SHARED【共享模式】</li></ul><h5 id="Q：addWaiter-功能和-enq十分相似，为什么特地调用addwaiter呢？">Q：<a href="https://www.zhihu.com/question/65591522">addWaiter 功能和 enq十分相似，为什么特地调用addwaiter呢？</a></h5><ul><li>【<strong>并发编程中，将最可能成功执行代码写在最常用处，优先执行</strong>】而不是先执行不太可能的代码，白白判断</li><li>调用enq需要方法调用、进入循环，执行和null比较等一系列指令，然后才到【最可能执行的代码处】</li></ul><pre><code class="language-java">  private Node addWaiter(Node mode) {        Node node = new Node(Thread.currentThread(), mode);               Node pred = tail;        if (pred != null) {         // 尝试enq的最快路径：Try the fast path of enq; backup to full enq on failure            node.prev = pred;            if (compareAndSetTail(pred, node)) {                pred.next = node;                return node;            }        }        enq(node);//如果不是【队列不空，在尾部成功添加节点】的常规情况，则调用enq插入当前线程节点        return node;    }</code></pre><h5 id="enq-node">enq(node)</h5><ul><li>enq(node)意义：【<strong>自旋添加节点，直到成功添加为止</strong>】，如果队列为空，则初始化队列</li><li><strong>for(;;)实现自旋</strong></li></ul><pre><code class="language-java">    private Node enq(final Node node) {        for (;;) {        // 如果队列为空，则至少两次for循环。第一次初始化队列，第二次插入当前线程节点        // for(;;)实现自旋            Node t = tail;            if (t == null) { // Must initialize                if (compareAndSetHead(new Node()))                    tail = head;            } else {                node.prev = t;                if (compareAndSetTail(t, node)) {                    t.next = node;                    return t;                }            }        }    }</code></pre><h4 id="font-style-color-rgb-38-38-38-selfInterrupt-font"><font style="color:rgb(38, 38, 38);">selfInterrupt()</font></h4><p><font style="color:rgb(38, 38, 38);">等待过程中断则不起作用，获取资源后selfInterrupt 中断<br></font></p><h3 id="font-style-color-rgb-38-38-38-release-int-font"><font style="color:rgb(38, 38, 38);">release(int )</font></h3><pre><code class="language-java">public final boolean release(int arg) {    if (tryRelease(arg)) {        Node h = head;//找到头结点        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);//唤醒等待队列里的下一个线程        return true;    }    return false;}</code></pre><h4 id="unparkSuccessor-Node">unparkSuccessor(Node)</h4><ul><li>用unpark()唤醒等待队列中最前边的那个未放弃线程</li></ul><pre><code class="language-java"> private void unparkSuccessor(Node node) {     //这里，node一般为当前线程所在的结点。     int ws = node.waitStatus;     if (ws &lt; 0)//置零当前线程结点状态，允许失败。         compareAndSetWaitStatus(node, ws, 0);      Node s = node.next;//找到下一个需要唤醒的结点s     if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消         s = null;         for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 从后向前找。             if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。                 s = t;     }     if (s != null)         LockSupport.unpark(s.thread);//唤醒 }</code></pre><h1>使用场景</h1><p><img src="https://cdn.nlark.com/yuque/0/2024/png/2366181/1709353015539-8f0b3ef2-ce7c-4314-846d-52c5510d1b2f.png" alt=""></p><h1>公平锁和非公平锁</h1><p>公平非公平，区别在于，加锁是否先来先到（<font style="color:#DF2A3F;">队列中的线程</font>和<font style="color:#DF2A3F;">非队列中的其他线程  </font>竞争锁的时候）</p><p><strong><font style="color:rgb(0, 0, 0);">非公平锁</font></strong><font style="color:rgb(0, 0, 0);">和</font><strong><font style="color:rgb(0, 0, 0);">公平锁</font></strong><font style="color:rgb(0, 0, 0);">的区别：</font><strong><font style="color:rgb(0, 0, 0);">非公平锁</font></strong><font style="color:rgb(0, 0, 0);">性能高于</font><strong><font style="color:rgb(0, 0, 0);">公平锁</font></strong><font style="color:rgb(0, 0, 0);">性能。</font><strong><font style="color:rgb(0, 0, 0);">非公平锁</font></strong><font style="color:rgb(0, 0, 0);">可以减少</font><font style="color:rgb(30, 107, 184);">CPU</font><font style="color:rgb(0, 0, 0);">唤醒线程的开销，整体的吞吐效率会高点，</font><font style="color:rgb(30, 107, 184);">CPU</font><font style="color:rgb(0, 0, 0);">也不必取唤醒所有线程，会减少唤起线程的数量</font></p><p><strong><font style="color:rgb(0, 0, 0);">非公平锁</font></strong><font style="color:rgb(0, 0, 0);">性能虽然优于</font><strong><font style="color:rgb(0, 0, 0);">公平锁</font></strong><font style="color:rgb(0, 0, 0);">，但是会存在导致</font><strong><font style="color:rgb(0, 0, 0);">线程饥饿</font></strong><font style="color:rgb(0, 0, 0);">的情况。在最坏的情况下，可能存在某个线程</font><strong><font style="color:rgb(0, 0, 0);">一直获取不到锁</font></strong><font style="color:rgb(0, 0, 0);">。不过相比性能而言，饥饿问题可以暂时忽略，这可能就是</font><font style="color:rgb(30, 107, 184);">ReentrantLock</font><font style="color:rgb(0, 0, 0);">默认创建非公平锁的原因之一了。</font></p><h1>Condition</h1><p><font style="color:rgb(0, 0, 0);">Condition是在java 1.5中才出现的，它用来</font><font style="color:#DF2A3F;">替代传统的Object的wait()、notify()实现线程间的协作</font><font style="color:rgb(0, 0, 0);">，相比使用Object的wait()、notify()，使用Condition中的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition。且不会产生死锁（原因？？？）</font></p><p><font style="color:rgb(0, 0, 0);">其中</font><font style="color:rgb(30, 107, 184);">AbstractQueueSynchronizer</font><font style="color:rgb(0, 0, 0);">中实现了</font><font style="color:rgb(30, 107, 184);">Condition</font><font style="color:rgb(0, 0, 0);">中的方法，主要对外提供</font><font style="color:rgb(30, 107, 184);">awaite(Object.wait())</font><font style="color:rgb(0, 0, 0);">和</font><font style="color:rgb(30, 107, 184);">signal(Object.notify())</font><font style="color:rgb(0, 0, 0);">调用。</font></p><p><font style="color:rgb(0, 0, 0);">wait()/waitAll():   需要和synchronized一起使用</font></p><p><font style="color:rgb(0, 0, 0);">nitify()/notifyAll():需要和synchronized一起使用</font></p><p><font style="color:rgb(0, 0, 0);"></font></p><p><font style="color:rgb(0, 0, 0);">await():挂起当前线程，并释放锁</font></p><p><font style="color:rgb(0, 0, 0);">signal():唤醒线程</font></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/2366181/1709350509497-0a2b53aa-55c0-49a6-bc6c-f244d322d718.png" alt=""></p><p>Condition不会产生死锁：</p><pre><code>- &lt;font style="color:black;"&gt;Condition 需要使用 Lock 进行控制，使用的时候要注意 lock() 后及时的 unlock()，Condition 有类似于 await 的机制，因此不会产生加锁方式而产生的死锁出现，同时底层实现的是 park/unpark 的机制，因此也不会产生先唤醒再挂起的死锁，一句话就是不会产生死锁，但是 wait/notify 会产生先唤醒再挂起的死锁。&lt;/font&gt;</code></pre><h1><font style="color:black;">子类使用需要重写的方法</font></h1><ul><li>protected boolean tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>protected boolean tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>protected boolean tryAcquireShared(int)//共享方式。尝试获取资源。<font style="color:#DF2A3F;">负数表示失败</font>；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>protected boolean tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>protected boolean isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。</li></ul><h1><font style="color:black;">设计模式：</font></h1><p>1、模板方法</p><p>AQS顶层的各种设计，模板已经固定，将具体的实现交由子类去实现</p><h1><font style="color:black;">AQS依赖的底层API：LockSupport</font></h1><p><font style="color:black;"></font></p><p><font style="color:black;">参考文档：</font></p><p>1、<a href="https://mp.weixin.qq.com/s/trsjgUFRrz40Simq2VKxTA">https://mp.weixin.qq.com/s/trsjgUFRrz40Simq2VKxTA</a></p><p>2、<a href="https://blog.csdn.net/xushiyu1996818/article/details/103528041">https://blog.csdn.net/xushiyu1996818/article/details/103528041</a>  （更详细）</p><p>3、<a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC基础理论</title>
      <link href="/2024/09/01/JUC%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
      <url>/2024/09/01/JUC%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>并发编程的基础</h1><h2 id="原子性、有序性、可见性">原子性、有序性、可见性</h2><h2 id="指令重排序">指令重排序</h2><h2 id="happens-before-规则">happens-before 规则</h2><p>主要是指<font style="color:#DF2A3F;"> 动作之间的依赖</font></p><p>有传递性</p><p>几个子规则：</p><p>程序顺序规则、监视器规则、volatile 规则、start()规则、join 规则</p><h2 id="as-if-serial-规则">as-if-serial 规则</h2><p>无论如何重排序，单线程的执行结果不能被改变</p><p>主要的规则对象是<font style="color:#DF2A3F;">单线程内部</font>的 <font style="color:#DF2A3F;">数据之间的依赖</font></p><h1>JMM 内存模型</h1><h2 id="概念">概念</h2><p>Java内存模型（JMM）是一种抽象的概念，用于描述在Java程序中，一组线程如何通过共享内存进行交互。JMM并不真实存在，它是一种规范，规定了程序中变量在内存中的访问方式。</p><p>在JMM中，内存主要划分为两种类型：<strong>主内存和工作内存</strong>。主内存存储了所有的对象实例和静态变量，而工作内存存储了每个线程的局部变量、栈中的部分区域以及寄存器的内容。</p><p><strong>JMM定义了一系列规则来规范线程之间的内存访问</strong>。其中最重要的规则是：当一个线程想要访问一个共享变量的值时，它必须先将其本地内存中的值更新到主内存中，然后再从主内存中读取该变量的值。这个过程被称为“主内存的一致性”。</p><p><strong>JMM的作用主要是屏蔽底层硬件和操作系统的内存访问差异</strong>，实现平台一致性，使得Java程序在不同平台下能达到一致的内存访问结果。同时，JMM也规范了JVM如何与计算机内存进行交互，从而保证并发程序的正确性和可靠性。</p><p>在实践中，为了更好地利用JMM，程序员需要了解一些内存访问的规则和约束。例如，JMM允许编译器对指令进行重排序，但这种重排序必须符合原子性、可见性和有序性等规则。此外，程序员还需要注意避免出现数据竞争和死锁等问题，这些问题可能会导致程序的正确性受到影响。</p><h2 id="读写屏障">读写屏障</h2><p>Happen before、Happen After</p><h2 id="volatile">volatile</h2><p>volatile是Java虚拟机提供的轻量级的同步机制，具有以下特点：</p><ol><li><font style="color:#DF2A3F;">保证可见性</font>：volatile保证了多个线程对共享变量的操作是可见的。当一个线程修改了共享变量的值，其他线程会立即看到这个改变。</li><li><font style="color:#DF2A3F;">禁止指令重排</font>：volatile通过禁止指令重排来保证顺序性。在多线程环境下，为了提高程序执行效率，编译器和处理器可能会对指令进行重新排序。但是，如果一个变量被volatile修饰，就禁止了指令重排，确保每个线程都能看到正确的操作顺序。</li></ol><p>总的来说，volatile可以确保多个线程对共享变量的操作一致，避免了数据不一致的问题。但是它不能保证原子性，因此对于需要保证原子性的操作，还需要使用其他同步机制，如synchronized关键字或java.util.concurrent.atomic包中的原子类。</p><h4 id="原理：">原理：</h4><p>通过插入 StoreStore、StoreLoad、LoadStore、LoadLoad 屏障实现</p><h2 id="不可变对象">不可变对象</h2><p>不可变对象（Immutable object）是一种一旦创建后其状态就不能被修改的对象。在Java中，不可变对象包括String、基本类型的包装类（如Integer、Double等）等。<br>不可变对象对写并发有如下帮助：<br>1<strong>线程安全</strong>：不可变对象是线程安全的，因为它们不会被其他线程修改。因此，多个线程可以同时使用不可变对象，无需额外的同步措施。<br>2<strong>减少锁竞争</strong>：由于不可变对象的状态不能被修改，因此不需要使用锁来保护对它的访问。这减少了锁竞争的可能性，从而提高了程序的性能。<br>3<strong>缓存优化</strong>：由于不可变对象一旦创建后其状态就不能被修改，因此可以将它们用作缓存项。这是因为缓存项的值不会在缓存和使用之间发生改变，从而避免了因缓存项状态被修改而导致的缓存失效问题。<br>需要注意的是，虽然不可变对象有以上优点，但它们也有一些缺点。例如，创建新的不可变对象比创建可变对象需要更多的内存，因为每次状态改变都需要创建新的对象。因此，在设计并发应用时，应根据具体需求和性能要求来决定是否使用不可变对象</p><h1>多线程基础</h1><h2 id="font-style-color-rgb-52-53-65-并发和并行-font"><font style="color:rgb(52, 53, 65);">并发和并行</font></h2><p><strong><font style="color:rgb(52, 53, 65);">并发</font></strong><font style="color:rgb(52, 53, 65);">针对单核 CPU 而言，它指的是 多个任务交替执行，每个任务都会在一段时间内执行一部分，然后切换到另一个任务，因为单核 CPU 一次只能执行一个任务。并发的目的是提高系统的响应性和吞吐量，允许多个任务在同一个处理器上共享时间片。</font><br><strong><font style="color:rgb(52, 53, 65);">并行</font></strong><font style="color:rgb(52, 53, 65);">针对多核 CPU 而言，它指的是多个任务真正同时执行，每个任务都有自己的处理器核心，它们可以在同一时刻执行不同的指令。并行的目的是提高计算能力和性能，允许多个任务同时处理，以加快任务完成的速度。</font><br><font style="color:rgb(52, 53, 65);"> 单核 CPU 只能并发，无法并行；换句话说，</font><strong><font style="color:rgb(52, 53, 65);">并行只可能发生在多核 CPU 中</font></strong><font style="color:rgb(52, 53, 65);">。</font><strong><font style="color:rgb(52, 53, 65);">在多核 CPU 中，并发和并行通常会同时存在。</font></strong><font style="color:rgb(52, 53, 65);">多个任务可以在不同的核心上并行执行，并且每个任务内部可能也包含并发的逻辑，以处理不同的子任务。这样可以最大程度地提高系统的性能和响应性。</font></p><h2 id="进程和线程">进程和线程</h2><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">当一个程序在计算机上运行时，通常会创建至少一个进程。进程被认为是操作系统分配资源的最小单元，每个进程都拥有独立的内存空间和系统资源，包括文件句柄和网络连接等。操作系统通常使用进程来表示独立的应用程序实例。比如，你的计算机上可能同时运行着浏览器、文本编辑器、音乐播放器等多个进程。</font><br><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">每个进程至少包含一个线程，通常被称为主线程。线程被视为操作系统调度的最小单元，它们共享相同的进程内存空间和系统资源。在一个进程内，多个线程可以协同工作，执行不同的任务，共享数据。这种多线程的使用方式有助于提高程序的并发性和性能。例如，一个文字处理软件的进程可能包括一个主线程，用于处理用户界面响应，同时还有一个后台线程，负责自动保存文件。</font></p><h2 id="守护线程和本地线程">守护线程和本地线程</h2><p><strong><font style="background-color:rgb(247, 247, 248);">守护线程</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">，可以看作是为其他线程提供服务的辅助工具。它们通常执行一些后台任务，比如垃圾回收、定期检查、日志记录等。一个重要的特点是它们不会阻止JVM的退出。当所有的本地线程都执行完毕后，JVM会自动退出，不会等待守护线程。</font></p><p><strong><font style="background-color:rgb(247, 247, 248);">本地线程</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">，则是应用程序的主力军，执行着应用的核心逻辑。它们的存在会阻止JVM退出，因为只要还有本地线程在运行，JVM会继续工作。</font></p><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">至于如何创建它们，守护线程需要通过设置 </font><strong><font style="background-color:rgb(247, 247, 248);">setDaemon(true)</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 来告诉JVM它是守护线程。而本地线程则是默认的线程类型，不需要额外设置。</font></p><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"></font></p><h2 id="font-style-color-rgb-55-65-81-background-color-rgb-247-247-248-多线程通信-font"><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">多线程通信</font></h2><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">当我们处理线程通信时，通常有两种主要的实现方式，每种方式都有其独特的机制和优势：</font></p><p><strong><font style="background-color:rgb(247, 247, 248);">共享内存：</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 这是一种常见的方式，多个线程可以访问同一个共享内存区域，通过读取和写入共享内存中的数据来进行通信和同步。在Java中，我们可以使用共享变量或共享数据结构来实现共享内存通信。例如，可以使用 </font><strong><font style="background-color:rgb(247, 247, 248);">volatile</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 关键字来确保共享变量的可见性，以及使用等待和通知机制，即 </font><strong><font style="background-color:rgb(247, 247, 248);">wait()</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 和 </font><strong><font style="background-color:rgb(247, 247, 248);">notify()</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 方法，来实现线程之间的协作。这种方式适用于需要高效共享数据的场景，但需要谨慎处理数据竞争和同步问题。</font></p><p><strong><font style="background-color:rgb(247, 247, 248);">消息传递：</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 另一种方式是消息传递，多个线程之间通过消息队列、管道、信号量等机制来传递信息和同步状态。这种方式通常涉及线程之间的显式消息发送和接收操作，使线程能够协调它们的工作。例如，我们可以使用信号量机制，通过获取和释放许可证来控制线程的访问。又或者使用栅栏机制，通过等待所有线程达到栅栏点来同步它们的执行。此外，锁机制也是一种重要的消息传递方式，通过获取和释放锁来实现线程之间的互斥和同步。消息传递的优点在于可以实现更松散的耦合，线程之间不需要直接共享内存，从而减少了潜在的竞争条件。</font></p><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"></font></p><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"></font></p><h2 id="font-style-color-rgb-55-65-81-background-color-rgb-247-247-248-线程调度算法-font"><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">线程调度算法</font></h2><p><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">在Java中，线程调度采用的是一种抢占式调度模型。</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">这就像在一个抢夺战中，有较高优先级的线程将首先占用CPU资源。如果线程具有相同的优先级，那么Java虚拟机会随机选择一个线程来执行，以保持公平竞争的原则。一旦一个线程获得了CPU，它将一直运行，直到自愿放弃CPU资源，或者由于某些情况（比如等待I/O操作、等待锁等）被迫放弃CPU，从而让其他线程有机会执行。</font></p><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">这种抢占式调度模型的目标是确保具有较高优先级的线程在争夺CPU资源时具有优势，但仍然让较低优先级的线程有机会执行，以避免它们被永远地忽略。Java的多线程调度机制有助于平衡线程之间的竞争和公平性，从而提高了多线程程序的响应速度和效率。</font></p><h1>锁原理</h1><h2 id="活锁与死锁，如何避免死锁">活锁与死锁，如何避免死锁</h2><p><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">死锁</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">是指多个线程相互等待对方释放资源，导致它们都无法继续执行下去。这是一种静止状态，这种情况会导致所有线程都被永久性地阻塞，没有一个线程能够继续执行。就像交通堵塞一样，没有车辆能够前进。</font></p><p><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">活锁</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">是指多个线程不断地改变自己的状态以回应对方，但最终无法取得进展，导致线程不断重试相同的操作，却无法成功。这是一种运行时状态，线程在持续地执行，但任务不会向前推进。活锁通常发生在线程在避免冲突时不断改变状态，但却没有成功，就像两个人在狭窄的道路上不断让对方走，却无法通过一样。</font></p><p><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">饥饿</font></strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">是指一个或多个线程或进程由于某种原因无法获得所需的资源或执行机会，因此无法适时地执行。这是一种动态问题，通常由资源分配不合理或线程优先级设置不当等原因导致。在饥饿中，线程不一定被永久性地阻塞，但是它们可能长时间无法获得所需的资源。就像一个人在繁忙的自助餐厅排队等待很长时间，但一直无法获得</font></p><h2 id="font-style-color-rgb-55-65-81-background-color-rgb-247-247-248-死锁的四个条件-font"><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">死锁的四个条件</font></h2><p>1、互斥不可破坏</p><p>2、请求与保持可以破坏，一次性申请所有资源</p><p>3、不可剥夺若申请不到需要的资源，则主动是否已占用的资源</p><p>4、循环等待按照按顺申请资源来预防</p><h2 id="死锁检测">死锁检测</h2><h2 id="银行家算法">银行家算法</h2><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">避免死锁</font></p><p><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">死锁是多线程编程中的一种常见问题，它发生在两个或多个线程相互等待对方释放资源的情况下，导致程序无法继续执行。为了避免死锁，我们可以采用以下策略：</font><br>1**<font style="background-color:rgb(247, 247, 248);">锁顺序：</font><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 定义一个固定的锁获取顺序，并要求所有线程都按照相同的顺序获取锁。这可以减少不同线程之间资源争夺的可能性。</font><br>2</strong><font style="background-color:rgb(247, 247, 248);">超时机制：</font><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 在获取锁时，设置一个超时时间。如果超过指定时间仍然无法获取锁，线程应该释放已经持有的锁并重试，或者采取其他适当的措施。这有助于避免线程无限期地等待锁。</font><br>3</strong><font style="background-color:rgb(247, 247, 248);">避免嵌套锁：</font><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 尽量避免在一个锁的持有期间再次尝试获取其他锁。如果确实需要获取多个锁，请确保获取的顺序是固定的，以减少死锁风险。</font><br>4</strong><font style="background-color:rgb(247, 247, 248);">使用锁机制：</font><strong><font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);"> 比如Java中的</font></strong><font style="background-color:rgb(247, 247, 248);">ReentrantLock</font>**<font style="color:rgb(55, 65, 81);background-color:rgb(247, 247, 248);">，它支持可中断的锁获取和条件等待，有助于避免死锁。</font></p><h2 id="锁优化机制">锁优化机制</h2><p>是的，锁的优化机制是Java等编程语言中常见的一种提高并发性能的方法。锁的优化旨在减少锁的竞争，从而提高程序的性能。以下是一些常见的锁优化机制：<br>1<strong>偏向锁</strong>（Biased Locking）：偏向锁是一种针对无竞争情况的锁优化机制。它通过消除无谓的获取锁和释放锁的操作，提高了程序的性能。偏向锁会记录哪个线程正在访问某个对象，并且后续的访问请求如果是同一个线程，就可以直接访问，而不需要加锁。<br>2<strong>轻量级锁</strong>（Lightweight Locking）：轻量级锁是一种针对单线程访问的情况的锁优化机制。它通过使用标记位或者CAS操作来对共享资源进行加锁和解锁，避免了使用重量级锁时的上下文切换和内核态切换等开销。<br>3<strong>自旋锁</strong>（Spin Lock）：自旋锁是一种非阻塞的锁机制，当线程无法立即获取锁时，它会持续检查锁是否被释放，直到获取到锁为止。自旋锁可以减少线程的上下文切换开销，但在锁持有时间较长的情况下，会浪费CPU资源。<br>4<strong>适应性自旋锁</strong>（Adaptive Spin Lock）：适应性自旋锁是一种结合了自旋锁和阻塞锁的锁机制。在刚开始时，线程会采用自旋的方式来等待锁的释放，但随着时间的推移，如果锁仍然没有被释放，线程会逐渐切换到阻塞状态，从而减少CPU资源的浪费。<br>5<strong>分段锁</strong>（Segmented Locking）：分段锁是一种针对共享资源过多的情况下的锁优化机制。它将共享资源分成多个段，每个线程只需要对其中一部分进行加锁和解锁操作，从而减少了锁的竞争和开销。<br>6<strong>乐观锁</strong>（Optimistic Locking）：乐观锁是一种基于冲突检测的锁机制。它假设多个线程同时访问和修改同一个数据的概率较小，因此在读取数据时不会加锁，而是在提交修改时检测是否存在冲突。如果存在冲突，则进行回滚或重试操作。乐观锁适用于读操作较多的场景。<br>7<strong>锁粗化</strong>（Lock Coarsening）：锁粗化是一种针对长时间持有锁的场景的优化策略。如果一个线程在短时间内需要连续多次加锁和解锁，那么可以将这些加锁和解锁操作合并成一个较大的加锁和解锁操作，从而减少了加锁和解锁的次数，提高了效率。<br>这些锁的优化机制都有各自的适用场景和优缺点，需要根据具体的业务需求和性能要求来选择合适的锁机制。</p><h2 id=""></h2><h2 id="基础方法">基础方法</h2><h3 id="CAS算法">CAS算法</h3><h4 id="ABA问题">ABA问题</h4><p>解决办法：</p><p><font style="color:rgb(44, 62, 80);">AtomicStampedReference</font></p><h4 id="1、加版本号">1、加版本号</h4><h4 id="2、加时间戳">2、加时间戳</h4><h2 id="只能保证一个变量的原子操作">只能保证一个变量的原子操作</h2><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/01/Spring%E5%A4%A7%E5%9B%BE/"/>
      <url>/2024/09/01/Spring%E5%A4%A7%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1725159625287-790e58c1-7bbb-4419-9c4d-a224c7a3ebce.jpeg" alt="画板"></p><h2 id="bean的生命周期">bean的生命周期</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1713771486439-3b0202a5-ef04-490b-9531-909ddc67a4dc.jpeg" alt="画板"></p><h2 id="缓存依赖">缓存依赖</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1713950858402-220e7083-2045-4f1f-937f-5b721f5bb634.png" alt=""></p><p>普通Bean：在容器启动的时候就加载</p><p>懒加载的Bean：在第一次context.getBean的时候加载</p><p>singtletonFactorys：三级缓存</p><h1>设计模式</h1><p><strong><font style="color:rgba(25, 26, 31, 0.9);">单例设计模式 :</font></strong><font style="color:rgba(25, 26, 31, 0.9);"> </font><font style="color:rgba(25, 26, 31, 0.9);">Spring 中的 Bean 默认都是单例的。</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">⼯⼚设计模式 :</font></strong><font style="color:rgba(25, 26, 31, 0.9);"> </font><font style="color:rgba(25, 26, 31, 0.9);">Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">代理设计模式 :</font></strong><font style="color:rgba(25, 26, 31, 0.9);"> </font><font style="color:rgba(25, 26, 31, 0.9);">Spring AOP 功能的实现。</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">观察者模式：</font></strong><font style="color:rgba(25, 26, 31, 0.9);"> </font><font style="color:rgba(25, 26, 31, 0.9);">Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">适配器模式：</font></strong><font style="color:rgba(25, 26, 31, 0.9);">Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC知识大图</title>
      <link href="/2024/09/01/JUC%E7%9F%A5%E8%AF%86%E5%A4%A7%E5%9B%BE/"/>
      <url>/2024/09/01/JUC%E7%9F%A5%E8%AF%86%E5%A4%A7%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1725170039990-8d7e8b89-2564-4cbf-afa5-db8edba8c0ec.jpeg" alt="画板"></p><h1>锁</h1><h1>并发工具</h1><h1>多线程</h1><h1>JUC 下类概览</h1><table><thead><tr><th>模块</th><th>类名</th></tr></thead><tbody><tr><td>Atomic</td><td>AtomicBoolean<br>AtomicInteger<br>AtomicIntegerArray<br>AtomicIntegerFieldUpdater<br>AtomicLong<br>AtomicLongArray<br>AtomicLongFieldUpdater<br>AtomicMarkableReference<br>AtomicReference<br>AtomicReferenceArray<br>AtomicReferenceFieldUpdater<br>AtomicStampedReference<br>DoubleAccumulator<br>DoubleAdder<br>LongAccumulator<br>LongAdder<br>Striped64</td></tr><tr><td>lock基础</td><td>AbstractOwnableSynchronizer<br>AbstractQueuedLongSynchronizerAbstractQueuedSynchronizer<br>Condition<br>Lock<br>LockSupport<br>ReadWriteLock<br>ReentrantLockReentrantReadWriteLock<br>StampedLock<br></td></tr><tr><td>线程池</td><td>AbstractExecutorService<br>CompletionService<br>Executor<br>ExecutorCompletionService<br>Executors<br>ExecutorService<br>ForkJoinPool<br>ForkJoinWorkerThread<br>ScheduledExecutorService<br>ScheduledThreadPoolExecutor<br>ThreadFactory<br>ThreadPoolExecutor</td></tr><tr><td>线程任务</td><td>Callable<br>CompletableFuture<br>ForkJoinTask<br>Future<br>FutureTask<br>RecursiveTask<br>RunnableScheduledFuture<br>ScheduledFuture<br>RecursiveAction<br>RunnableFuture</td></tr><tr><td>阻塞队列</td><td>ArrayBlockingQueue<br>BlockingDeque<br>BlockingQueue<br>ConcurrentLinkedDeque<br>ConcurrentLinkedQueue<br>DelayQueueLinkedBlockingDequeLinkedBlockingQueueLinkedTransferQueue<br>PriorityBlockingQueue<br>SynchronousQueue<br>TransferQueue</td></tr><tr><td>异常</td><td>BrokenBarrierException<br>CancellationException<br>CompletionException<br>ExecutionException<br>RejectedExecutionException<br>TimeoutException</td></tr><tr><td>并发工具</td><td>ConcurrentHashMap<br>ConcurrentMap<br>ConcurrentNavigableMap<br>ConcurrentSkipListMap<br>ConcurrentSkipListSet<br>CopyOnWriteArrayList<br>CopyOnWriteArraySet</td></tr><tr><td>并发基础工具类</td><td>CountDownLatch<br>CyclicBarrier<br>Semaphore<br>Exchanger<br>Flow<br>Phaser<br>Helpers<br>RejectedExecutionHandler<br>ThreadLocalRandom<br>Delayed<br>CountedCompleter<br>SubmissionPublisher<br>TimeUnit<br>CompletionStage</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> JVM并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础知识</title>
      <link href="/2024/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1><font style="color:rgb(51, 51, 51);">架构</font></h1><p><font style="color:rgb(51, 51, 51);">‌</font><a href="https://www.baidu.com/s?rsv_idx=1&amp;wd=MPP%E6%9E%B6%E6%9E%84&amp;fenlei=256&amp;usm=1&amp;ie=utf-8&amp;rsv_pq=fe27be200004e7e8&amp;oq=mpp%E6%9E%B6%E6%9E%84&amp;rsv_t=b4b2uPOqnJ5Vd5ayvueuNcKao9FlKSM5eFvPraO7aChOVoEVH5qhwhi6LrY&amp;sa=re_dqa_zy"><font style="color:rgb(51, 51, 51);">MPP架构</font></a><font style="color:rgb(51, 51, 51);">（Massively Parallel Processing，大规模并行处理）是一种分布式数据处理技术，其核心特征包括任务并行执行、私有资源、数据分布式存储（本地化）、分布式计算、横向扩展以及Shared Nothing架构。在这种架构中，每个节点都拥有独立的磁盘存储系统和内存系统，通过专用网络或商业通用网络连接彼此进行协同计算，从而提高数据处理性能。</font></p><p><font style="color:rgb(51, 51, 51);">MPP架构与Hadoop架构的比较：</font></p><ul><li><font style="color:rgb(51, 51, 51);">Hadoop架构：是一种分布式计算系统，主要用于处理大规模数据集，它依赖于分布式文件系统（HDFS）进行数据存储和处理。Hadoop架构更侧重于数据的批处理和分布式文件处理，而MPP架构则更侧重于实时或近实时的高性能数据分析。‌</font></li><li><font style="color:rgb(51, 51, 51);">MPP架构：如前所述，MPP架构通过将工作负载分散到多个节点上来提高数据处理性能，每个节点独立处理一部分数据，从而实现并行处理，这种架构非常适合需要快速响应和高效数据处理的应用场景。‌</font></li></ul><p><font style="color:rgb(51, 51, 51);">MPP架构非常适合OLAP（在线分析处理）应用，因为它能够处理大量的数据并快速提供分析结果。在OLAP场景中，MPP架构可以通过并行处理多个查询请求，显著提高查询性能，同时优化数据分布与传输，降低系统延迟和吞吐量，从而提供更好的分析体验。‌</font></p><p><font style="color:rgb(51, 51, 51);"></font></p><h1>分类</h1><p>OLTP：MySQL、PostgreSQL、PolorDB</p><p>OLAP：ClickHouse、AnalyticDB</p><p>内存数据库</p><p>1、DockDB</p><p>2、LevelDB</p><h1><font style="color:rgb(51, 51, 51);">参考</font></h1><p>1、<a href="https://blog.csdn.net/fuhanghang/article/details/135421557">https://blog.csdn.net/fuhanghang/article/details/135421557</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> NewSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AnalyticDB 最佳实践</title>
      <link href="/2024/09/01/AnalyticDB%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/09/01/AnalyticDB%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>原文：ATA：<a href="https://ata.atatech.org/articles/11000164007?layout=%2Fvelocity%2Flayout%2Fblank.vm">https://ata.atatech.org/articles/11000164007?layout=%2Fvelocity%2Flayout%2Fblank.vm</a></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">各位亲爱的用户，随着AnalyticDB for MySQL（下文统一简称：ADB）在集团各个BU、社会上各行各业的推广应用，我们沉淀了一些最佳实践，现在笔者整理在这里，供大家参考，希望对大家有帮助。</font></strong></p><p><font style="color:rgba(25, 26, 31, 0.9);">在读这篇文章之前，请先了解ADB的产品相关的文档：<br></font><font style="color:rgba(25, 26, 31, 0.9);">1.ADB</font><font style="color:rgba(25, 26, 31, 0.9);"> </font><a href="https://help.aliyun.com/product/92664.html?spm=5176.7937365.1120968.ee6.6f151f58LAgIPX">官方文档</a><font style="color:rgba(25, 26, 31, 0.9);">。<br></font><font style="color:rgba(25, 26, 31, 0.9);">2.集团内用户使用ADB过程中的</font><a href="https://yuque.antfin-inc.com/dkysyp/egtkne">答疑手册</a><font style="color:rgba(25, 26, 31, 0.9);">。</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">说明：</font></strong><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">本文写的最佳实践主要针对ADB3.0，ADB2.0在原理上同样适用，具体细节参考</font><a href="https://help.aliyun.com/document_detail/97474.html?spm=a2c4g.11186623.6.908.5c1021c2RMeTIe">官方文档</a><font style="color:rgba(25, 26, 31, 0.9);">和我之前写的</font><a href="https://www.atatech.org/articles/127932">ATA系列文章</a></p><h1><font style="color:rgba(25, 26, 31, 0.9);">通用最佳实践</font></h1><h2 id="font-style-color-rgba-25-26-31-0-9-表设计的最佳实践：-font"><font style="color:rgba(25, 26, 31, 0.9);">表设计的最佳实践：</font></h2><p><font style="color:rgba(25, 26, 31, 0.9);">ADB做为一个分布式的，追求实时分析海量数据的极致性能，需要充分发挥分布式数据库的优势，满足ADB达到最佳性能的特征要求，对表的设计时，需要注意以下几点规则。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-1-选择合适的表类型（维度表or普通表）：-font"><font style="color:rgba(25, 26, 31, 0.9);">1.选择合适的表类型（维度表or普通表）：</font></h4><p><strong><font style="color:rgba(25, 26, 31, 0.9);">维度表：</font></strong><font style="color:rgba(25, 26, 31, 0.9);">又称广播表，数据仓库中的一个概念，一般存储一些维度数据。在ADB中建表语句中有DISTRIBUTED BY BROADCAST 的关键字，这些表会在集群的每个节点存储一份数据，因此建议维度表的数据量不宜太大，每张维度表存储的数据不超过10万行。<br></font><strong><font style="color:rgba(25, 26, 31, 0.9);">普通表：</font></strong><font style="color:rgba(25, 26, 31, 0.9);">也叫作分区表、事实表，一般存储业务的主题数据。普通表可存储的数据量通常比较大，可以存储千万条甚至万亿条数据，可以对其设置一级分区对数据做sharding或者二级分区进行数据的生命周期管理。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">注意：维度表如果太大会导致数据存储空间的膨胀，节点越多膨胀越大，同时也会导致实时写入时性能下降，iops会比较高。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-2-选择合适的分布键（一级分区键）：-font"><font style="color:rgba(25, 26, 31, 0.9);">2.选择合适的分布键（一级分区键）：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">ADB中创建普通表时，默认需要通过DISTRIBUTED BY HASH(column_name,…)指定分布键，按照column_name的HASH值进行分区。ADB支持将多个字段作为分布键。<br></font><font style="color:rgba(25, 26, 31, 0.9);">分布键的选择依据：<br></font><font style="color:rgba(25, 26, 31, 0.9);">尽可能选择参与JOIN的字段作为分布键，例如按照用户维度透视或者圈人，可以选择user_id作为分布键。<br></font><font style="color:rgba(25, 26, 31, 0.9);">尽可能选择值分布均匀的字段作为分布键，例如交易ID、设备ID、用户ID或者自增列作为分布键。<br></font><font style="color:rgba(25, 26, 31, 0.9);">注意：分布键不均匀容易导致数据分布不均，严重影响写入和查询的效率，此外也容易导致单节点磁盘写满导致整个集群锁定不可用。一般情况数据均匀是第一优先级，然后才考虑JOIN KEY对齐的问题，除非有业务就是想定制化。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-3-选择合适的分区键（二级分区键）：-font"><font style="color:rgba(25, 26, 31, 0.9);">3.选择合适的分区键（二级分区键）：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">如果业务明确有增量数据导入需求，创建普通表时可以同时指定分布键和分区，分区可以实现数据的增量同步。<br></font><font style="color:rgba(25, 26, 31, 0.9);">创建普通表时，通过PARTITION BY {VALUE(column_name) | VALUE(date_format(column_name, ?)}指定分区。<br></font><font style="color:rgba(25, 26, 31, 0.9);">例如，PARTITION BY VALUE(column_name)表示使用column_name的值来做分区，PARTITION BY VALUE(DATE_FORMAT(column_name, ‘%Y%m%d’))表示将column_name格式化为类似20190101的日期格式做分区。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 直接用ds的值来做分区<br></font><font style="color:rgba(25, 26, 31, 0.9);">PARTITION BY VALUE(ds)<br></font><font style="color:rgba(25, 26, 31, 0.9);">- ds转换后的天做分区<br></font><font style="color:rgba(25, 26, 31, 0.9);">PARTITION BY VALUE(DATE_FORMAT(ds, ‘%Y%m%d’))<br></font><font style="color:rgba(25, 26, 31, 0.9);">- ds转换后的月做分区<br></font><font style="color:rgba(25, 26, 31, 0.9);">PARTITION BY VALUE(DATE_FORMAT(ds, ‘%Y%m’))<br></font><font style="color:rgba(25, 26, 31, 0.9);">- ds转换后的年做分区<br></font><font style="color:rgba(25, 26, 31, 0.9);">PARTITION BY VALUE(DATE_FORMAT(ds, ‘%Y’))</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">注意：一个实例能承载的最大二级分区数目是有限的，当前限制是10240。请提前规划后这个实例的所有表二级分区键，尽量充分利用二级分区，不要让每个二级分区的数据量过小，如：你使用天做二级分区，但是每天数据量很小，这时可考虑用月来做二级分区。否则会导致数据库中需要保存分区数据的元数据特别多，这些元数据是需要存放在内存中，会占据内存较多的空间，容易导致系统的GC或者OOM，同时也会导致实时写入时的iops比较高</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">二级分区的过期策略</font></strong><font style="color:rgba(25, 26, 31, 0.9);">：<br></font><font style="color:rgba(25, 26, 31, 0.9);">目前二级分区过期策略是依据大小排序，只保留最大的N个二级分区，其中N为生命周期的大小。假设表A定义的生命周期个数为3，目前存在的二级分区为202001，202002，202003。当分区值为202004的数据写入进来时202001分区就会被淘汰。需要注意的是分区淘汰是延迟进行的，不保证202004的数据写入后立即会淘汰202001。此外在使用二级分区时也要注意脏数据带来的误淘汰问题，如果此时表A分别写入了分区值为300001,300002,300003的三条脏数据，那么分区淘汰策略也会被触发，整表将只剩下分区值最大的三条脏数据。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-4-选择合适的主键：-font"><font style="color:rgba(25, 26, 31, 0.9);">4.选择合适的主键：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">在表中定义主键可以去实现数据消重(Replace into)和数据更新操作(Delete、Update)。只有定义过主键的表支持数据更新操作（DELETE和UPDATE）。<br></font><font style="color:rgba(25, 26, 31, 0.9);">主键的选择依据：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 尽可能选择单数字类型字段作为主键，表的性能相对更好。ADB支持将字符串或者多字段组合作为主键。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 主键中必须包含分布键和分区键，如果有二级分区键的话，需要包含二级分区键。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">注意：设置的主键的字段不宜太大，或者某个字段的长度不宜过长，否则的话，会导致数据库的IOPS很高。</font><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">曾经某业务的主键设置太长：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264444750-d64240f8-8b6e-4546-b8db-e6ff3ac8deaf.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">导致在很多的tps下 iops特别高：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264444765-61dbea82-e017-4ce7-9816-84722637fe01.webp" alt=""></p><h4 id="font-style-color-rgba-25-26-31-0-9-5-选择合适聚集索引：-font"><font style="color:rgba(25, 26, 31, 0.9);">5.选择合适聚集索引：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">聚集索引会将该列或者多列排序，保证该列相同或者相近的数据存在磁盘的相同或相近位置，当以聚集列做为查询条件时，查询结果保持在磁盘的相同位置，这样可以减少磁盘的IO。<br></font><font style="color:rgba(25, 26, 31, 0.9);">聚集索引的选择依据：<br></font><font style="color:rgba(25, 26, 31, 0.9);">查询一定会携带的字段可以作为聚集索引。例如，电商卖家透视平台中每个卖家只访问自己的数据，卖家ID可以定义为聚集索引，保证数据的局部性，提升数据查询性能。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">注意：目前聚集索引只支持一个，但该聚集索引可以有多列。目前除非对非常分散的数据进行点查，否则聚集索引对性能的帮助很少。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-6-设计合适的数据类型：-font"><font style="color:rgba(25, 26, 31, 0.9);">6.设计合适的数据类型：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">原理：<br></font><font style="color:rgba(25, 26, 31, 0.9);">ADB处理数值类型的性能远好于处理字符串类型。原因在于：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 数值类型定长，占用内存少，存储空间小。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 数值类型计算更快，尤其是join时。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 从内部索引机制上，字符串类型适合等值查询和范围查询情况，而时间，数值类型性能更高，建议用户尽可能- - 使用数值类型，减少使用字符串类型。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 选择尽可能小的列，列类型要尽可能选择匹配的列，比如性别就可以用boolean或者byte类型，数据长度不大的可以用int<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 在同一个业务模型内，相同字段设计成相同的数据类型和字段长度，字段命名也保持一致，特别是涉及到主外键关联的字段更要注意，避免表在关联时不同的数据类型的字段关联导致隐式转换。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">方法：<br></font><font style="color:rgba(25, 26, 31, 0.9);">常见将字符串转换为数值类型方法：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 包含字符前缀或后缀，例如E12345，E12346等。可以直接去掉前缀或者将前缀映射为数字。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 该列只有少数几个值，例如国家名。可以对每个国家编码，每个国家对应一个唯一数字。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 时间/日期类型数据，避免使用varchar字符类型存储，尽量使用date，timestamp或者int类型存储时间类型。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 对于地理经度维度的使用，需要通过地理函数查询情况，数据类型采用double数据类型。</font></p><h2 id="font-style-color-rgba-25-26-31-0-9-数据写入方面的最佳实践-font"><font style="color:rgba(25, 26, 31, 0.9);">数据写入方面的最佳实践</font></h2><h3 id="font-style-color-rgba-25-26-31-0-9-实时写入：-font"><font style="color:rgba(25, 26, 31, 0.9);">实时写入：</font></h3><h4 id="font-style-color-rgba-25-26-31-0-9-1-批量打包的方式提交：-font"><font style="color:rgba(25, 26, 31, 0.9);">1.批量打包的方式提交：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">向表中写入数据时，可以通过批量打包方式INSERT INTO和REPLACE INTO提高数据写入性能。建议如下：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 通过每条INSERT或者REPLACE语句写入的数据行数大于1000行，但写入的总数据量不宜太大，不要超过16MB。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 通过批量打包方式写入数据时，单个批次的写入延迟相对会高一些，但是整体的性能会提升。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 写入报错时，需要做重试确保数据被写入，重试导致的数据重复可以通过表的主键来消除。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 如果不需要对原始的数据进行修改，直接使用insert into比replace into效率会高3倍以上。<br></font><font style="color:rgba(25, 26, 31, 0.9);">样例：</font></p><pre><code class="language-plain">INSERT INTO  test(id, name,sex,age,login_time) values(1,'dcs',0,23,'2018-03-02 10:00:00'),(2,'hl',0,23,'2018-03-02 10:01:00'),(3,'xx',0,23,'2018-03-02 10:02:00')......;</code></pre><h4 id="font-style-color-rgba-25-26-31-0-9-2-更新数据-font"><font style="color:rgba(25, 26, 31, 0.9);">2.更新数据</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">数据更新有多种方式，使用区别如下：<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 高频基于主键的行级覆盖更新, 且应用可以补齐所有列，请使用replace into values批量打包<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 高频基于主键的行级覆盖更新, 应用不能补齐所有列，请使用update into values批量打包<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 低频基于主键更新，可以使用replace into或者update into单条数据<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 低频任意条件更新，请使用 update set where<br></font><font style="color:rgba(25, 26, 31, 0.9);">注意：update需要查表来填补更新中缺失的旧值，因此比replace into多一次查询，性能较低，不建议做高频、大批量的update操作。如果线上update性能无法满足需求，需考虑替换成Replace into，由应用端补旧值。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-3-删除数据-font"><font style="color:rgba(25, 26, 31, 0.9);">3.删除数据</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">数据删除有多种方式，使用区别如下：<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 低频主键条件删除，请使用 delete from where pk = xxx<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 低频任意条件删除，请使用 delete from where<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 删除单个二级分区，请使用 truncate partition<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 删除单表（包括所有二级分区，如有），请使用truncate table或drop table</font></p><h3 id="font-style-color-rgba-25-26-31-0-9-批量导入：-font"><font style="color:rgba(25, 26, 31, 0.9);">批量导入：</font></h3><h5 id="font-style-color-rgba-25-26-31-0-9-如何选择是批量导入还是实时导入-font"><font style="color:rgba(25, 26, 31, 0.9);">如何选择是批量导入还是实时导入</font></h5><ul><li><font style="color:rgba(25, 26, 31, 0.9);">从ODPS、OSS导入ADB，推荐使用insert overwrite select做批量导入，原因有二：<br></font><font style="color:rgba(25, 26, 31, 0.9);">一方面，批量导入适合大数据量导入，性能好<br></font><font style="color:rgba(25, 26, 31, 0.9);">二方面，批量导入适合数仓语义，即导入过程中旧数据可查，导入完成一键切换新数据。如果导入失败，新数据会回滚，不影响旧数据的查询。</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">从RDS、MySQL、ADB等导入ADB，看数据量情况，数据量不大的(百万级别的表)，推荐使用insert into select做实时导入，数据量大的，推荐使用insert overwrite select做批量导入。</font></li></ul><h5 id="font-style-color-rgba-25-26-31-0-9-导入并发和资源说明-font"><font style="color:rgba(25, 26, 31, 0.9);">导入并发和资源说明</font></h5><ul><li><font style="color:rgba(25, 26, 31, 0.9);">单张表的导入会在系统内部串行，不同表之间的导入任务会并行，默认并行度是2；从ODPS分区表导入到ADB时，每次导入横跨的分区数不要超过30个，同一张表的不同分区导入是排队串行，不同表的导入，同时提交，有并行度n个任务同时导入，出于资源控制，超出的任务也会排队。</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">导入使用的是ADB内部的资源，与查询一样，属于同一个实例的资源。推荐导入任务在查询qps比较低的时候进行，比如凌晨0点以后，并推荐用户配置d2等定时任务，错峰做导入。</font></li></ul><h2 id="font-style-color-rgba-25-26-31-0-9-高效查询的最佳实践-font"><font style="color:rgba(25, 26, 31, 0.9);">高效查询的最佳实践</font></h2><p><font style="color:rgba(25, 26, 31, 0.9);">ADB的优势是能在海量数据场景下，面对复杂查询，做到实时的在线分析。ADB的SQL调优需要充分发挥分布式计算优势，以及ADB本身的一些特征，同时对于通用的数据库优化的方法论同样是适用。</font></p><h3 id="font-style-color-rgba-25-26-31-0-9-查询优化的通用法则：-font"><font style="color:rgba(25, 26, 31, 0.9);">查询优化的通用法则：</font></h3><p><font style="color:rgba(25, 26, 31, 0.9);">按照斗佛早些年在《ORACLE DBA手记》上写的文章，数据访问优化满足以下漏斗法则：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264444751-33ec5c5f-f54c-4dab-a89c-f6a3dfba42f6.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><strong><font style="color:rgba(25, 26, 31, 0.9);">1、 减少数据访问（减少磁盘访问）</font></strong><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">例如：尽量多的使用过滤条件，尽早的提前过滤数据，减少参与计算的数据量，能在子查询里面把数据先过滤的提前过滤。<br></font><strong><font style="color:rgba(25, 26, 31, 0.9);">2、 返回更少数据（减少网络传输或磁盘访问）</font></strong><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">例如：避免select * 的查询，特别的在OLAP数据库下，往往表的列数比较多，同时由于基于列存或者行列混存，对于这种select * 的操作，需要请求的IO回更多。<br></font><strong><font style="color:rgba(25, 26, 31, 0.9);">3、 减少交互次数（减少网络传输）</font></strong><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">例如：上文提到的批量提交。<br></font><strong><font style="color:rgba(25, 26, 31, 0.9);">4、 减少服务器CPU开销（减少CPU及内存开销）</font></strong><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">例如：<br></font><font style="color:rgba(25, 26, 31, 0.9);">A. 减少不必要的排序和分页，特别是在子查询中的排序<br></font><font style="color:rgba(25, 26, 31, 0.9);">B. 在满足业务前提下，尽量减少count distinct操作<br></font><font style="color:rgba(25, 26, 31, 0.9);">C. 在满足业务前提下，特别是在海量数据下，采用类似Hyperloglog的近似计算代替准确计算。<br></font><strong><font style="color:rgba(25, 26, 31, 0.9);">5、 利用更多资源（增加资源）</font></strong><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">例如：<br></font><font style="color:rgba(25, 26, 31, 0.9);">A. 设计表的时候，尽量避免分区倾斜，导致存储和计算压在某一个节点上，尽量把数据都均匀的散列到所有的节点上，充分利用所有机器的能力，最大发挥分布式的数据库的效能<br></font><font style="color:rgba(25, 26, 31, 0.9);">B. ADB本身就是MPP大规模并行处理的典型系统，在内核层面也做了大量的优化处理，充分利用更多的资源。</font></p><h3 id="font-style-color-rgba-25-26-31-0-9-ADB特殊场景的优化：-font"><font style="color:rgba(25, 26, 31, 0.9);">ADB特殊场景的优化：</font></h3><h5 id="font-style-color-rgba-25-26-31-0-9-外表的查询最佳实践-font"><font style="color:rgba(25, 26, 31, 0.9);">外表的查询最佳实践</font></h5><p><font style="color:rgba(25, 26, 31, 0.9);">不要尝试对外表进行较为复杂的计算，这样会导致比较严重的GC，因为外表的计算是全部把数据拖过来算的，且网络带宽的压力也会变大。</font></p><h5 id="font-style-color-rgba-25-26-31-0-9-巧妙的使用聚集索引：-font"><font style="color:rgba(25, 26, 31, 0.9);">巧妙的使用聚集索引：</font></h5><p><font style="color:rgba(25, 26, 31, 0.9);">当查询条件一定包含某列时，特别是该列的数据在存储上非常分散时，对该列建立聚集索引，性能会有明显的提升，可以采用类似如下的sql语句添加聚集索引：<br></font><font style="color:rgba(25, 26, 31, 0.9);">alter table table_name ADD CLUSTERED INDEX index_cls (d_fdbid);<br></font><font style="color:rgba(25, 26, 31, 0.9);">注意：如果表里面的数据已经有了，直接add cluster index不会对存量的数据排序，需要重建表，在建表的时候加上聚集列关键字。</font></p><h5 id="font-style-color-rgba-25-26-31-0-9-减少节点间的数据交互：-font"><font style="color:rgba(25, 26, 31, 0.9);">减少节点间的数据交互：</font></h5><p><font style="color:rgba(25, 26, 31, 0.9);">分布式数据库，在充分发挥分布式计算的同时，有时也会加大跨节点间的网络开销，特别是请求的数据散列在各个节点上时，请求的数据量有比较少，且节点个数又比较多情况下，跨网络开销的情况就非常明显，因此可以采用以下几个思路：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 如果能采用本地计算，在各个节点内join或者聚合分析时，尽量在本节点内计算，具体做法就是，如果在满足业务前提下，能用户一级分区键关联的，采用一级分区键关联；能对一级分区键进行group by的，采用一级分区键group by，这样可以尽量采用localjoin，大大减少跨网络的访问。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 合理的控制节点数量，并不是节点越多越好，当数据库规模不大，且每次查询的数据量很少，且跨网络访问很严重的情况下，节点越多，问题越严重。</font></p><h5 id="font-style-color-rgba-25-26-31-0-9-合理的使用索引：-font"><font style="color:rgba(25, 26, 31, 0.9);">合理的使用索引：</font></h5><p><font style="color:rgba(25, 26, 31, 0.9);">合理使用索引在数据库调优中，非常重要，在ADB中也不例外。在ADB中，默认每列都会创建索引。但是也有例外情况，如果某列的cardinality值比较少时，通过索引查询可能会更慢，因为他需要多查一次索引再回表，且索引的选择性又不高，性能就会很差，这时可以在建表时把这些disable掉建索引的功能，这样就不会在建表后自动建索引了，如果索引已经创建了，可以把索引删除掉，或者通过hint 不走索引访问：<br></font><font style="color:rgba(25, 26, 31, 0.9);">alter table table_name drop index index_name 把枚举列的索引删除掉。<br></font><font style="color:rgba(25, 26, 31, 0.9);">或者使用/</font><em><font style="color:rgba(25, 26, 31, 0.9);">+no_index_columns=[t_order_content.fdelete;fdbid]</font></em><font style="color:rgba(25, 26, 31, 0.9);">/ 类似这样的hint把索引去掉不走</font></p><h2 id="font-style-color-rgba-25-26-31-0-9-ADB连接的最佳实践-font"><font style="color:rgba(25, 26, 31, 0.9);">ADB连接的最佳实践</font></h2><p><font style="color:rgba(25, 26, 31, 0.9);">ADB在使用方式上做到和99%以上和mysql兼容，支持多种连接方式，比如mysql命令行，JDBC连接，Python连接，c#连接，PHP连接等等。整体请参考</font><a href="https://help.aliyun.com/document_detail/123738.html?spm=a2c4g.11186623.6.591.50445923JhLCF3">官方文档</a><font style="color:rgba(25, 26, 31, 0.9);"> </font><font style="color:rgba(25, 26, 31, 0.9);">。<br></font><font style="color:rgba(25, 26, 31, 0.9);">另补充Golang连接最佳实践：<br></font><font style="color:rgba(25, 26, 31, 0.9);">分析型数据库MySQL版3.0 Golang最佳实践：</font><a href="https://yuque.antfin-inc.com/docs/share/d29e0153-df52-44ac-b5eb-430561325da6?#">请参考</a><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">分析型数据库MySQL版2.0 Golang最佳实践：</font><a href="https://yuque.antfin-inc.com/docs/share/bc440e24-4338-40b5-be09-91fcce0807d1?#">请参考</a><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">注意：由于ADB已经是一个分布式数据库，不需要再通过TDDL中间件来连接ADB。</font></p><h1><font style="color:rgba(25, 26, 31, 0.9);">业务行业线上的最佳实践参考：</font></h1><h2 id="font-style-color-rgba-25-26-31-0-9-客户运营行业-font"><font style="color:rgba(25, 26, 31, 0.9);">客户运营行业</font></h2><h4 id="font-style-color-rgba-25-26-31-0-9-客户运营行业使用场景：-font"><font style="color:rgba(25, 26, 31, 0.9);">客户运营行业使用场景：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">随着互联网流量成本的增加，花大价钱砸流量的时代成为历史，客户广告营销越来越讲究精细化运营，越来越依赖对已有的客户数据做实时的，精准的分析，提高广告的转化率，在对人群的营销方面一般存在以下典型的场景：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264444768-4f764d7c-48b8-4ad0-900b-b5f08a10827e.webp" alt=""></p><p><font style="color:rgba(25, 26, 31, 0.9);">典型的系统架构：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264444759-5d07a101-4d2a-447f-bc59-5659527379c3.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">核心表建表语句如下：</font></p><pre><code class="language-plain">CREATE TABLE db.order (order_id,user_id,shop_vip,last_trade_time,last_cart_time,member_grade,seller_zone,member_credits,clustered key index_mmsi(`user_id`))DISTRIBUTED BY HASH(order_id)PARTITION BY VALUE(DATE_FORMAT(last_trade_time, '%Y%m%d')) LIFECYCLE 30COMMENT '订单信息表';</code></pre><p><font style="color:rgba(25, 26, 31, 0.9);">备注：采用order_id做为分布键，确保数据均匀分布，不会出现倾斜，同时由于需要频繁的按照user_id查询或者关联，可以将user_id建为聚集索引。<br></font><font style="color:rgba(25, 26, 31, 0.9);">（1）人群透视<br></font><font style="color:rgba(25, 26, 31, 0.9);">人群透视是指的根据用户的各种标签，来选取特定的人群。通常情况下，以用户或者用户行为的表做为一张事实表，用户的各类标签/属性做为维度表，采用星型模型，用事实表来join各个维度表，做多维分析（有时也可能会采用数据冗余的反范式方式，以牺牲数据存储为代价，将事实表构建为一张大宽表，目的是省去分析时的多表关联）。正是因为用户分析标签的不确定性，采用传统的数据（传统数据库的索引是不能无限制的创建的）是无法做到这种不定维度的分析的，那么ADB就是解决该类问题的最佳方案。<br></font><font style="color:rgba(25, 26, 31, 0.9);">典型的SQL如下：</font></p><pre><code class="language-plain">SELECT  t2.buyer_id,  t3.seller_id,  t1.shop_vip,  t1.last_trade_time,  t1.last_cart_time,  t1.member_grade,  t1.seller_zone,  t1.member_credits,  sum(t1.pay_amount)FROM  db.order t1  JOIN db.dimension_table1 t2 ON t1.user_id= t2.buyer_id  JOIN db.dimension_table2 t3 ON t1.user_id= t3.seller_idWHERE  t1.is_market_target IN('4')  AND t1.seller_zone = 1019  AND t1.attributes IN('6742081')  AND t3.buyer_id = ‘xxxx’  and t3.tseller_id = ‘yyyy’group by  t2.buyer_id,  t3.seller_id,  t1.shop_vip,  t1.last_trade_time,  t1.last_cart_time,  t1.member_grade,  t1.seller_zone,  t1.member_credits</code></pre><p><font style="color:rgba(25, 26, 31, 0.9);">其中的order表可能是万亿级别，巨量数据的多维、多表关联在线实时分析对底层分析系统的能力要求极高。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">（2）人群圈选<br></font><font style="color:rgba(25, 26, 31, 0.9);">人群圈选场景和人群透视的场景类似，更多的时候可能是圈选具体的人群数量，而不是具体的明细数据，这时更多的时候是使用到ADB的聚合计算的能力，即根据各个不定的维度进行count distinct或者group by的操作。<br></font><font style="color:rgba(25, 26, 31, 0.9);">典型的SQL语句如下：</font></p><pre><code class="language-plain">SELECT count(1) AS cnt  FROM(SELECT DISTINCT t1.buyer_id  FROM(SELECT buyer_id  FROM db.order WHERE seller_zone= 11111   AND seller_id= 121211121   AND algorithm_crowd IN('84')) t1  JOIN(SELECT user_id AS buyer_id  FROM db.dimension_table1) t2       ON t1.buyer_id= t2.buyer_idJOIN(SELECT user_id AS seller_id  FROM db.dimension_table2) t3       ON t1.buyer_id= t3.seller_id) t</code></pre><p><font style="color:rgba(25, 26, 31, 0.9);">（3） 人群投放<br></font><font style="color:rgba(25, 26, 31, 0.9);">是指将上面圈选的人群，按照一定的促销渠道投放去处。比如用短信投放，那么就将相关的用户信息取出来投放到运营商渠道；比如投放到一些门户网站，那么就投放到一些广告公司。不同的渠道的数据可以使用不同OSS来存放，而ADB支持将库内的数据，很方便的dump到oss或者其他的下游产品上，而且dump的效率也非常的高效。很好的节省了用户人群投放的效率。<br></font><font style="color:rgba(25, 26, 31, 0.9);">典型的sql如下：</font></p><pre><code class="language-plain">CREATE TABLE output with(oss_dump_endpoint= 'xxxxxx.oss-internal.aliyun-inc.com', oss_dump_bucket_name= 'xxxx',                          oss_dump_file_name= 'xx_prod/20190710/63218721',                          oss_dump_is_overwrite= true,                          oss_dump_compatibility_mode= false,                          oss_dump_access_key_id= 'xxxxxxxxx',                          oss_dump_access_key_secret= 'xxxxxxxxxxxxxxxxxxxx',                          oss_dump_row_del= '\r\n',                          oss_dump_col_del= '\t', table_type= 'oss_dump', dump_charset_code= 'UTF-8',                          oss_dump_table_header= 'false', return_dump_result_count= true) asSELECT DISTINCT t1.buyer_id  FROM(SELECT buyer_id  FROM db.order WHERE last_cart_time&gt;= 20190610   AND last_cart_time&lt; 20190710   AND is_market_target IN('1')   AND seller_zone= 1018   AND seller_id= 3687815378) t1 JOIN(SELECT user_id AS buyer_id  FROM db.dimension_table) t2 ON t1.buyer_id= t2.buyer_id LIMIT 10000</code></pre><h2 id="font-style-color-rgba-25-26-31-0-9-监控大屏类：-font"><font style="color:rgba(25, 26, 31, 0.9);">监控大屏类：</font></h2><p><font style="color:rgba(25, 26, 31, 0.9);">由于ADB支持实时写入，而且实时写入的数据又能进行比较复杂的实时分析，因此在一些监控大屏，监控大盘，实时看板等应用场景中也使用的非常广泛。<br></font><font style="color:rgba(25, 26, 31, 0.9);">典型的系统架构如下：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264445173-4b011e50-0d61-47fd-9d3b-a3855b275161.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">上游生产数据通过Blink、DTS、精卫或者dataworks等工具实时写入到ADB中，在ADB中进行实时在线分析，然后在报表展现工具做大屏显示。<br></font><font style="color:rgba(25, 26, 31, 0.9);">对于该类的业务，对数据的时效要求很高，特别是对数据的实时写入要求很高，实时写入的数据量大，且要求写入后实时可见，还要能快速的分析，因此在表的设计时要特别注意这方面的需求，需要注意以下几点：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 表设计时要设置主键：主键用于排重，一旦有重复的数据写入可以直接覆盖，具体主键设计的细则参考上文；<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 表的设计要设计二级分区：一来该类数据往往量比较大，需要采用二级分区做数据的生命周期管理，自动淘汰过期的数据；二是实时写入数据的索引的构建可以根据二级分区来构建，这样只需要增量数据构建索引，大大提高构建索引的效率，而不需对全表构建索引，有了索引后，数据的查询也就能快很多。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 在特别大量的写入情况下，往往cpu的消耗也比较厉害，需要合理控制构建索引任务的并发度和时间，以避免和大流量写入峰值重合，而加深对实时写入的影响。<br></font><font style="color:rgba(25, 26, 31, 0.9);">典型的SQL如下：</font></p><pre><code class="language-plain">Create Table tb__record_info(  a_info_id bigint NOT NULL AUTO_INCREMENT,  domain varchar NOT NULL,  region varchar NOT NULL,  ip varchar NOT NULL,  result_ts varchar NOT NULL,  time_stamp timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  key idx_domain(domain),  key idx_time(time_stamp),  primary key (a_info_id, domain, time_stamp)) DISTRIBUTE BY HASH(domain) PARTITION BY VALUE(DATE_FORMAT(time_stamp,'%Y%m%d')) LIFECYCLE 60</code></pre><h2 id="font-style-color-rgba-25-26-31-0-9-游戏行业：-font"><font style="color:rgba(25, 26, 31, 0.9);">游戏行业：</font></h2><h4 id="font-style-color-rgba-25-26-31-0-9-ADB在游戏行业的使用场景：-font"><font style="color:rgba(25, 26, 31, 0.9);">ADB在游戏行业的使用场景：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">游戏领域的竞争变得更加激烈，在互联网高速增长的同时，流量成本不断升高，市场营销开始往精细化发展。游戏厂商对于渠道、用户和游戏表现的评估需要更加细化和准确的数据的要求，希望利用优秀的数据分析工具来帮助团队更全面的分析市场和用户的趋势，同时玩家的游戏行为和喜好也在慢慢变化，如何能够及时发现这些变化并针对性的调整产品和游戏设计也是非常重要的，因此提出了如下业务要求：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 提供全面的游戏运营指标分析功能：全面提高游戏开发者的日常数据运营工作效率，不仅提供付费用户、付费率、付费金额和ARPU等运营指标，还强化了付费用户的留存率、回访率、用户生命周期价值等更加精细化的运营指标，游戏开发者可以更加深入，更加有效率的掌握游戏运营状态。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 提供有效分析渠道效果，使每分钱都花在刀刃上：实时的分渠道数据统计可以监测到不同渠道用户的增长、活跃、留存状况以及充值状况，更加全面、快速的分析出投资回报率，让开发者对渠道的评估更加准确。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 针对对付费用户追踪分析，了解付费用户的习惯：针对付费用户群，通过简单易懂的数据分析模型和图表，跟踪付费用户的留存、流失、回访和充值数据，更好的反映付费用户在整个生命周期的关键行为和价值。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 细致分析玩家游戏行为，改进产品体验，提高游戏收益：关卡、道具、消费行为分析的功能可以了解道具和物品在使用过程中使用和消耗的总量以及趋势，开发者可以借此来做到恰到好处的数值平衡设计，也可充分利用数据分析的结果来帮助开发者优化游戏内付费商品的收益。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-典型场景的查询SQL：-font"><font style="color:rgba(25, 26, 31, 0.9);">典型场景的查询SQL：</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">（1）活跃分析<br></font><font style="color:rgba(25, 26, 31, 0.9);">游戏产品日活DAU/月活MAU等均为评价该款游戏是否被玩家广泛接受的一个非常重要的指标，如下：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264445232-8b954199-7086-41c3-a896-8c48ae97a786.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">如此类DAU计算的SQL示例通常如下：</font></p><pre><code class="language-plain">SELECT count(DISTINCT uid) AS count FROM login_log WHERE timestamp &gt;= &lt;start_timestamp&gt; AND timestamp   &lt;= &lt;end_timestamp&gt; AND qita1        = &lt;x&gt; AND qita2        = &lt;y&gt;;</code></pre><p><font style="color:rgba(25, 26, 31, 0.9);">基于上述的基本统计，可以对玩家的活跃状态做更多的探索，比如：<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 活跃账号分析：<br></font><font style="color:rgba(25, 26, 31, 0.9);"> 按照日期分析，常见的DAU/WAU/MAU等<br></font><font style="color:rgba(25, 26, 31, 0.9);"> 按照渠道分析，比如如分包渠道或者广告渠道等<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 在线分析：<br></font><font style="color:rgba(25, 26, 31, 0.9);"> 平均在线玩家数<br></font><font style="color:rgba(25, 26, 31, 0.9);"> 峰值在线玩家数<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 玩家行为分析：<br></font><font style="color:rgba(25, 26, 31, 0.9);"> 人均游戏次数，所选日期内，总游戏次数 / 游戏人数（该数值无法完全精确统计，仅供参考）<br></font><font style="color:rgba(25, 26, 31, 0.9);"> 人均游戏时长分析等</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">（2）来源分析<br></font><font style="color:rgba(25, 26, 31, 0.9);">游戏玩家来源分析里面，新增设备分析用来预测该款游戏的生命周期和拉新效率等，均为评价该款游戏是否被玩家广泛接受的一个非常重要的指标，如下：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264445171-eb7e0719-dc06-43d8-b2ab-a8913e02dec4.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">如此统计新增设备、新增玩家等计算的SQL示例通常如下：</font></p><pre><code class="language-plain">SELECT Count(*) AS count  FROM   (    SELECT deviceid    from login_log              WHERE  channel_id = ‘X’                     AND timestamp &gt;= ‘XXX’    AND timestamp &lt;= ‘YYY’    GROUP  BY deviceid) AS d1    LEFT JOIN (    SELECT deviceid                        FROM   login_log                        WHERE  channel_id = ‘X’                                AND timestamp &lt; ‘YYY’) AS d2ON d1.deviceid = d2.deviceid  WHERE  d1.deviceid IS NULL;</code></pre><p><font style="color:rgba(25, 26, 31, 0.9);">（3）留存分析<br></font><font style="color:rgba(25, 26, 31, 0.9);">留存指标在某些方面反映了游戏产品的质量和保留玩家的能力，也在另一方面反映了渠道与游戏目标用户的契合度及渠道质量。所以对留存指标的分析显得更为重要，如下：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264445196-d8bbc9e8-a7f0-4f97-b515-232348c90ea6.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">如此统计玩家留存率等计算的SQL示例通常如下：</font></p><pre><code class="language-plain">SELECT  channel_id,  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 0,      user_id,      NULL    )  ) AS 'liucun_1',  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 1,      user_id,      NULL    )  ) AS 'liucun_2',  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 2,      user_id,      NULL    )  ) AS 'liucun_3',  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 3,      user_id,      NULL    )  ) AS 'liucun_4',  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 4,      user_id,      NULL    )  ) AS 'liucun_5',  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 5,      user_id,      NULL    )  ) AS 'liucun_6',  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 6,      user_id,NULL    )  ) AS 'liucun_7',  count(    DISTINCT IF (      datediff(payorder_riqi, login_riqi) = 14,      user_id,      NULL    )  ) AS 'liucun_15'FROM  pay_order p  LEFT JOIN login_log l ON p.uid = l.uidWHERE  payorder_riqi &gt;= '2019-01-17'  AND payorder_riqi &lt;= '2019-01-24'GROUP BY  `channel_id`ORDER BY  `liucun_1` DESC</code></pre><h2 id="font-style-color-rgba-25-26-31-0-9-交通行业-font"><font style="color:rgba(25, 26, 31, 0.9);">交通行业:</font></h2><p><font style="color:rgba(25, 26, 31, 0.9);">随着全国开始推广取消跨省收费站，原来的各个省各自为政的线下收费搬到了线上，这些信息化系统的建设，一方面大大的提高了收费和通行的效率，同时也为国家打通全国收费一盘棋，深化高速公路收费体系改革，降低中国流通成本提供了数据基础；另一方面，国家相关部门依赖这些数据，进行一些更加精准的分析，又能进一步推动交通行业的发展。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-几个典型的应用场景-font"><font style="color:rgba(25, 26, 31, 0.9);">几个典型的应用场景</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">（1）车辆通行查询<br></font><font style="color:rgba(25, 26, 31, 0.9);">全国高速公路取消跨省收费站后，所有的车辆经过龙门架后，自动计费。全国1.9亿的ETC，和25万的龙门架，针对这些海量龙门架数据和ETC数据做统计查询，既要保证能存的下，还要要查的快，算的准，这时选用ADB是一个很好的选择方案，既能满足按照门架id、车牌号等任意维度的统计分析，还能满足存储下这些海量的数据，做到比较弹性的扩展。<br></font><font style="color:rgba(25, 26, 31, 0.9);">通常表和数据库的设计要注意如下几点：<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 保证表的数据在各个节点分布均匀，不能将门架号做为分布键，因为在有些区域的车流量特别大，对应的门架的数据量会比较大，有些经济欠发达地区，车流量很少，门架的车流数据很少，这样会导致很严重的数据倾斜。可以考虑把把ETCID 或者车牌号做为分布键，将门架id设计为聚集索引。<br></font><font style="color:rgba(25, 26, 31, 0.9);">- 由于要满足海量的数据实时写入，在建表和数据库调优时要充分考虑数据实时写入的性能，设计的主键不宜太长，构建索引的频率选择一个合适的平衡点，最好和实时写入峰值的时间错开等等。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">（2）数据稽核<br></font><font style="color:rgba(25, 26, 31, 0.9);">作为智慧高速的一部分，既要提供车流实时分析、通行费用结算、智能交互等多样的应用服务，又要加强高速管理，对偷逃费等行为具备智能稽核的能力。在稽核业务中，关于可疑车辆的行驶轨迹查询是非常常见的场景，可是关于可疑车辆的信息描述则可能非常的模糊，比如“车牌尾号是“NV0”的车辆”。如果只是使用倒排索引，车牌 like ‘%NV0’这种查询条件不可避免的会触发全表扫描，在数据量这么巨大的场景下，全表扫描的代价是十分巨大的。如果对车牌字段构建全文索引，返回结果中又会包含很多‘NV0’不在末尾的车牌信息。最佳的解决方案是在表结构中冗余一个车牌字段，并将它创建全文索引，同时使用这两个字段作为查询条件：先用match(车牌_2) against (’“NV0”')筛选出所有包含NV0的车牌信息，在此基础上，再用车牌_1 like '%NV0’筛选出NV0在结尾的车牌。（注释：车牌_1和车牌_2均存储车牌信息，为车牌_1构建倒排索引，车牌_2构建全文索引）。</font></p><pre><code class="language-plain">select  * from demo where match(licence_code2) against ('"NV0"')  and licence_code like '%NV0';</code></pre><p><font style="color:rgba(25, 26, 31, 0.9);">（3）数据分发<br></font><font style="color:rgba(25, 26, 31, 0.9);">在有些专有云场景下，由于不同的ISV，不同的部门对数据有着不同的需求和访问权限，甲方的数据资产部门不可能把核心的数据仓库（基于ADB构建的实时数仓）全部开放给需求方，即使可以用子账号的方式开放，但是对于一些不同网络环境的部门的数据需求就无法满足，在这种场景下，可以使用ADB的dump能力把实时数仓的数据dump到不同的需求方的oss的bucket里面，需求方根据约定的规则到oss上取数据。具体架构如下：<br></font><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1709264445219-d302bbab-b375-4613-9aa2-c9914bbe268a.webp" alt=""><font style="color:rgba(25, 26, 31, 0.9);"><br></font><font style="color:rgba(25, 26, 31, 0.9);">这样的应用，ADB在满足实时数仓的高效分析的同时，还起到了数据分发HUB的作用，让数据资产部门能很好的掌控数据。</font></p><h1><font style="color:rgba(25, 26, 31, 0.9);">FAQ:</font></h1><h4 id="font-style-color-rgba-25-26-31-0-9-1-磁盘占用大小包含哪些数据？为什么会触发磁盘满锁定？-font"><font style="color:rgba(25, 26, 31, 0.9);">1. 磁盘占用大小包含哪些数据？为什么会触发磁盘满锁定？</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">磁盘占用量主要包括数据和索引两部分。索引在构建过程中，会临时额外占用少量空间，期间可能会有少量数据膨胀。<br></font><font style="color:rgba(25, 26, 31, 0.9);">用户可以使用如下sql查询使用空间：（延迟统计的，1小时统计一次）<br></font><font style="color:rgba(25, 26, 31, 0.9);">select (sum(data_length)+sum(index_length))/1024/1024/1024 as ‘数据空间(GB)’ from information_schema.tables;<br></font><font style="color:rgba(25, 26, 31, 0.9);">使用如下sql查询当前日志使用空间：<br></font><font style="color:rgba(25, 26, 31, 0.9);">show binary logs<br></font><font style="color:rgba(25, 26, 31, 0.9);">其中，adb-bin.log表示binlog，adb-system.log表示系统日志。<br></font><font style="color:rgba(25, 26, 31, 0.9);">单节点磁盘使用量超过80%则会触发锁定，有2种可能原因：一是一级分区键选择不合理导致某些节点数据倾斜，二是数据分布比较平均，总体使用量过大。是否存在表有分区倾斜可以在控制台页面观察。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-2-是否支持磁盘大小扩缩，是否支持节点数扩缩？节点数扩缩需要多久-font"><font style="color:rgba(25, 26, 31, 0.9);">2. 是否支持磁盘大小扩缩，是否支持节点数扩缩？节点数扩缩需要多久?</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">目前磁盘使用ecs云盘，只支持扩容，不支持缩容。节点数支持扩缩，数量范围与实例初始规格相关，控制台变配页面可以看到当前实例节点数变配范围。节点数扩缩会在节点间进行部分数据迁移，正常情况下最大耗时为最大单节点磁盘使用量/40(MB/s) + 20min。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-3-如何进一步提高写入性能？-font"><font style="color:rgba(25, 26, 31, 0.9);">3. 如何进一步提高写入性能？</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">数据写和导入尽可能使用批量写入的方式，使用dataworks进行数据同步可关注是否并发任务数和写入批大小设置过小。主键选择尽可能精简。写入表的分区键选择尽可能均衡。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-4-如何选择合适的一级分区列-font"><font style="color:rgba(25, 26, 31, 0.9);">4. 如何选择合适的一级分区列</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">ADB内部将数据拆分为若干个一级分区，通常情况下一个ADB实例内部大概有100数量级左右的一级分区。在进行查询时不同的一级分区并发进行。因此一级分区列最重要的一点是需要保证数据尽可能的均匀，否则会出现长尾查询拖慢整体查询进度。<br></font><font style="color:rgba(25, 26, 31, 0.9);">不同的表如果一级分区列相同，那么这些表在执行以一级分区列为join key的join时可以大幅度减少数据shuffle。因此在保证数据均匀的前提下，相同的一级分区列可以加速join。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-5-如何选择合适的二级分区列-font"><font style="color:rgba(25, 26, 31, 0.9);">5. 如何选择合适的二级分区列</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">二级分区是对一级分区的进一步拆分，一般是在时间维度上进行。大部分情况下单二级分区的数据尽量超过一百万，达到百万级，同时也不要达到数千万。<br></font><font style="color:rgba(25, 26, 31, 0.9);">下面以一张订单表为例来选择合适的二级分区。假设这张表单天增量百万左右，需要保留10年的数据。由于我们单ADB集群通常情况下，有100左右的一级分区。若该表按日为分区，则单二级分区的大小约为1w左右远低于我们的建议值。因此用月或者年作为二级分区比较合适。<br></font><font style="color:rgba(25, 26, 31, 0.9);">二级分区的生命周期是支持修改的。如下语句: alter table lineitem partitions 12展示了如何将lineitem的二级分区个数修改为12。需要注意的是二级分区个数的修改是后台异步执行的，执行build table lineitem可以加速分区修改任务。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-6-二级分区的过期策略是怎样的。-font"><font style="color:rgba(25, 26, 31, 0.9);">6. 二级分区的过期策略是怎样的。</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">目前二级分区过期策略是依据大小排序，只保留最大的N个二级分区，其中N为生命周期的大小。假设表A定义的生命周期个数为3，目前存在的二级分区为202001，202002，202003。当分区值为20204的数据写入进来时202001分区就会被淘汰。需要注意的是分区淘汰是延迟进行的，不保证20204的数据写入后立即会淘汰202001。此外在使用二级分区时也要注意脏数据带来的误淘汰问题，如果此时表A分别写入了分区值为300001,300002,300003的三条脏数据，那么分区淘汰策略也会被触发，整表将只剩下分区值最大的三条脏数据。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-7-聚集索引是什么，什么情况下适合使用聚集索引。-font"><font style="color:rgba(25, 26, 31, 0.9);">7. 聚集索引是什么，什么情况下适合使用聚集索引。</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">聚集索引就是让数据根据若干字段进行排序。对于有这相同的排序字段的数据在物理上尽可能的存储在一起。<br></font><font style="color:rgba(25, 26, 31, 0.9);">如果查询一定会带的某个字段，比如电商中卖家透视平台，每个卖家只访问自己的数据，那卖家id就是可以选择为聚集索引，可以保证数据的locality，进而性能有量级的提升。<br></font><font style="color:rgba(25, 26, 31, 0.9);">目前聚集索引只支持一个，但该聚集索引可以有多列。目前除非对非常分散的数据进行点查，否则聚集索引对性能的帮助很少，请谨慎选择。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-8-主键如何选择，是否能够修改主键？-font"><font style="color:rgba(25, 26, 31, 0.9);">8. 主键如何选择，是否能够修改主键？</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">主键一般情况下用于数据的去重。主键的长度与去重的效率成反比，因此非常不建议使用较长的String如UUID作为主键，建议为1~3个long值。<br></font><font style="color:rgba(25, 26, 31, 0.9);">此外需要注意的是，主键需要包含一级分区键和二级分区键。目前不支持主键的修改。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-9-如何自己指定索引-font"><font style="color:rgba(25, 26, 31, 0.9);">9. 如何自己指定索引</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">a. ADB默认是全字段索引，一般不需要自己维护索引。<br></font><font style="color:rgba(25, 26, 31, 0.9);">b. 如何查看一个表有哪些索引，跟mysql一样使用这个语句：show index from t<br></font><font style="color:rgba(25, 26, 31, 0.9);">c. 如果想要drop掉某个索引可以使用：alter table t drop key key_name。其中key_name可以通过上面的语句查询。注意drop掉索引会导致查询变慢<br></font><font style="color:rgba(25, 26, 31, 0.9);">d. 如果想要自己指定索引，那跟mysql一样，使用key关键字：key key_name (column_name)。如：create table t(id bigint,c1 varchar,key id_idx(id))DISTRIBUTE BY HASH(id)</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-10-直接用mysql的建表ddl可以在adb中执行建表吗？-font"><font style="color:rgba(25, 26, 31, 0.9);">10. 直接用mysql的建表ddl可以在adb中执行建表吗？</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">可以的，具体行为是这样的：<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 如果DDL中有主键，用主键做distribute key<br></font><font style="color:rgba(25, 26, 31, 0.9);">• 如果DDL中没有主键，会自动给他添加一个字段：<strong>adb_auto_id</strong>，然后用__adb_auto_id__做主键和分区键</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-11-可以直接用adb2-0的建表语句在adb3-0中执行吗？-font"><font style="color:rgba(25, 26, 31, 0.9);">11. 可以直接用adb2.0的建表语句在adb3.0中执行吗？</font></h4><p><font style="color:rgba(25, 26, 31, 0.9);">可以</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">参考文档：<br></font><font style="color:rgba(25, 26, 31, 0.9);">李华植：《海量数据库解决方案》<br></font><font style="color:rgba(25, 26, 31, 0.9);">白鳝 ：《DBA的思想天空》<br></font><font style="color:rgba(25, 26, 31, 0.9);">叶正盛：《面向程序员的数据库访问性能优化法则》<br></font><font style="color:rgba(25, 26, 31, 0.9);">南靖：《新一代游戏数据运营融合分析最佳实践V2.docx》<br></font><font style="color:rgba(25, 26, 31, 0.9);">王庶：《全国高速公路取消省界收费站项目落地实践》</font></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> NewSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AnalyticDB</title>
      <link href="/2024/09/01/AnalyticDB/"/>
      <url>/2024/09/01/AnalyticDB/</url>
      
        <content type="html"><![CDATA[<p>分析型数据库、数据仓库</p><p>内部初名 Garuda，又名 ADS</p><h1>整体架构</h1><h2 id="读写分离架构">读写分离架构</h2><p>计算存储分离</p><p>冷热数据分离</p><h3 id="视角-1">视角 1<img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722269056133-b3c27c4d-53c6-424f-9eb2-a5c90b067226.webp" alt=""></h3><p>前端节点（FN)</p><p>写入节点（BN）</p><p>计算节点（CN）</p><h3 id="视角-2">视角 2</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722253380127-327d8f37-0c5e-422c-bb7f-1d0fbf935522.png" alt=""></p><p><strong><font style="color:rgb(0, 0, 0);">第一层是接入层</font></strong><font style="color:rgb(0, 0, 0);">，由Mulit-Master可线性扩展的协调节点构成，主要负责协议层接入、SQL解析和优化、实时写入Sharding、数据调度和查询调度。</font></p><p><strong><font style="color:rgb(0, 0, 0);">第二层是计算引擎</font></strong><font style="color:rgb(0, 0, 0);">，具备分布式MPP+DAG融合执行能力，结合智能优化器，可支持高并发和复杂SQL混合负载，同时借助于云原生基础设施，计算节点实现了弹性调度，可根据业务需求做到分钟级甚至秒级扩展，达到了资源的有效利用。  </font></p><p><strong><font style="color:rgb(0, 0, 0);">第三层是存储引擎，</font></strong><font style="color:rgb(0, 0, 0);">基于Raft协议实现的分布式实时强一致高可用存储引擎，通过数据分片和Multi-Raft实现并行，利用分层存储实现冷热分离降低成本，通过行列存储和智能索引达到极致性能。</font></p><p><font style="color:rgb(0, 0, 0);"></font></p><h1></h1><h2 id="关键技术">关键技术</h2><p>1、智能 sql 优化器</p><p>2、曦和计算引擎</p><p>3、玄武存储引擎</p><p>4、读写节点分离</p><p>5、硬件加速</p><h1>静态分层模块</h1><h2 id="存储层（玄武引擎）">存储层（玄武引擎）</h2><p>整体存储架构</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722253317389-851c77b5-a5fc-41d5-b091-14ec983a0a19.png" alt=""></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722336889091-d43c28c5-32b7-475e-beda-ab56ab3e75f4.webp" alt=""></p><ul><li>FrontNode（FN）</li></ul><p>包括 W-FN（负责写入）、R-FN（负责查询）</p><p><font style="color:rgba(25, 26, 31, 0.9);">FRONTNODE 主要负责SQL解析、查询结果汇聚，实时数据写入、DDL等功能。所有FN完全对等，节点之间完全无耦合，无单点故障。</font></p><ul><li>BufferNode（BN）</li></ul><p>分布式的队列系统</p><p>支持多副本</p><p>master-slave 架构，可快速 failover</p><p>failover 期间，会有短暂的不可写，但是 CN 在此期间可以直接读取 pangu 的数据（写入宕机不影响查询）</p><ul><li>ComputeNode（CN）</li></ul><p>计算节点，承担计算 + 存储的功能</p><p>不在写入链路上，不影响写入（流量反压的时候可能会）</p><p>每个节点上都包含历史的 cache 数据和实时数据两部分：加速分区列计算，避免数据 shuffle 和跨机计算</p><p>会定期去同步本地存储引擎中和 BN 有差异的数据</p><h3 id="发展历程">发展历程</h3><h4 id="第一代：普通的-OLTP-引擎">第一代：普通的 OLTP 引擎</h4><p>借鉴 H2 数据库的存储引擎：<font style="color:#DF2A3F;">行存 + B+索引</font>、支持事务</p><h4 id="第二代：列存">第二代：列存</h4><p>列存的原理示意图</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722418899192-b830c3fc-e808-4171-ba48-a072e872a467.webp" alt=""></p><p>优点 ：压缩比高、自由选择压缩算法   -&gt; 更低的 io 延迟</p><p>列存的天然优势：io 剪裁，只读取感兴趣的数据列</p><p>ADB 的列存，增加了三部分内容：<font style="color:rgba(25, 26, 31, 0.9);">分区、列和块三层meta</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">1、 分分区meta</font></strong><font style="color:rgba(25, 26, 31, 0.9);">主要包括表的行数和列数，主要解决count(*)的性能问题。</font></p><p><strong><font style="color:rgba(25, 26, 31, 0.9);">2、 列meta主要包括：</font></strong></p><ul><li><font style="color:rgba(25, 26, 31, 0.9);">max、min：可以有效解决二级分区快速筛选</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">sum，count，count distinct， null count： 可以加速sum/count/distinct 计算，同时该metrics可以提供给优化器选择最优执行计划。</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">Dict： 针对cardinality较少的列（例如性别，星座），保存字典在该meta中，数据文件中保存字典序号（int 类型），既大大压缩了存储空间，又可以加速groupby、distinct 等算子的计算性能。</font></li></ul><p><strong><font style="color:rgba(25, 26, 31, 0.9);">3、 块meta主要包括：</font></strong></p><ul><li><font style="color:rgba(25, 26, 31, 0.9);">max、min： 解决无索引条件下的，快速过滤功能。如果某条件与max、min无交集，则可以快速跳过该块。同时可以提高max，min算子的计算性能。</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">sum： 提高sum算子计算性能。</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">null count：支持快速filter 空值列。</font></li></ul><p><font style="color:rgba(25, 26, 31, 0.9);"></font></p><p><font style="color:rgba(25, 26, 31, 0.9);">其他：</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">1、 增加了二级分区。支持数据的生命周期管理，也即能够设置数据的保存期限，自动根据规则淘汰过期数据；</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">2、 实时化。这是另一个很大的话题，我们单独开了文章来介绍。请参见《超大规模的立即可见实时写入》。</font></p><h4 id="font-style-color-rgba-25-26-31-0-9-第三代：行列混存-font"><font style="color:rgba(25, 26, 31, 0.9);">第三代：行列混存</font></h4><p>解决了的问题：</p><p>1、OLTP 的点查性能问题</p><p><font style="color:rgba(25, 26, 31, 0.9);">解决办法： select *等由列存的完全随机读转化为了顺序读。</font></p><p>2、OLAP 的多维分析问题</p><p><font style="color:rgba(25, 26, 31, 0.9);">解决办法：进行单列IO时将列存的顺序读转化为了顺序跳读；进行多列IO时则将随机读转化为了顺序读。</font></p><p>3、写入大吞吐的问题：每天<font style="color:rgba(25, 26, 31, 0.9);">千亿级别实时数据写入</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">解决办法：列存时的随机写被转化为了顺序写。</font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722419298990-2235dbc6-1d5d-4d92-94e9-cf764420d1ad.webp" alt=""></p><p><font style="color:rgba(25, 26, 31, 0.9);">AnalyticDB也支持了另外两项重要功能：</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">1）clustered by预排序功能。该功能将某一列或某几列的数据进行排序后，存放到磁盘上。从而保证了相同数据在磁盘上连续存储。对于等值查询、范围查询都能够大幅减少需要IO的block数，实现查询加速。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">2）分层存储。将SSD盘作为本地cache，确保热点数据查询性能，同时降低了总体存储成本。</font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722419461285-fe301b6f-6757-4dd1-80e0-dea9ec462076.webp" alt=""></p><h4 id="第四代：定长存储">第四代：定长存储</h4><p><font style="color:rgba(25, 26, 31, 0.9);">即以byte为单位将block真正变为定长。</font></p><p>解决结构化、非结构化数据存储问题</p><h4 id="下一代：HTAP">下一代：HTAP</h4><p>展望</p><h3 id="索引">索引</h3><h4 id="全索引">全索引</h4><p>多列、多条件同时走索引，快速多路合并，可以在毫秒级内找出结果集</p><p>根据成本估计，智能选择走索引还是扫描</p><h4 id="支持的索引类型">支持的索引类型</h4><p>1、 倒排索引</p><p>基于 lucene</p><p><font style="color:rgba(25, 26, 31, 0.9);"> 目前Lucene采用Prefix+Sufix字典压缩term，倒排链中保存的是递增行号集合，采用Delta+Vint压缩算法，压缩比可以达到1：4。同时所有查询过程为顺序读，解压速度达到900MB/s。</font></p><p>2、Bitmap 索引</p><p>对于散列度较低的列，自动构建 bitmap 索引，降低存储空间</p><p>3、 范围索引</p><p>解决 lucene 的范围索引问题</p><p><font style="color:rgba(25, 26, 31, 0.9);">先生成直方图数据分布，将所有数据切分为多个互不相交的区间，并将每个区间作为一个Bitmap索引</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">查询时，范围条件被拆成多个or 条件的组合。例如数据被切成[0,10),[10,20), [30,40),[40,50)等区间，</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">如：条件 x &gt; 5 and x &lt; 45，会被转换为 (5, 10)，[10, 20), [20, 30),[30, 40), [40, 45)多个or条件。</font></p><p>4、全文索引</p><p>5、向量索引</p><p>6、json 索引</p><p>。。。</p><h4 id="索引优化">索引优化</h4><p><font style="color:rgba(25, 26, 31, 0.9);">1、 索引结果缓存</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">2、CBO（基于代价优化）</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">根据 index 中的统计信息</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">根据 meta 中的统计信息</font></p><p>3、无索引查询优化</p><p>多没有构建索引的列，也能根据统计，做一些加速，减少 io</p><p>4、流式归并</p><p><font style="color:rgba(25, 26, 31, 0.9);">传统的数据处理系统在所有查询条件计算完毕后，将结果集一次性合并完毕。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">而AnalyticDB采用了流式归并方法，按需将结果集进行合并。该方法的一大优点是：一旦满足了计算需求，就会触发早停逻辑，避免了不必要的结果合所带来的CPU、内存消耗 。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">例子：</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">where ( (姓名=‘张三’ AND 性别!= ‘女’ ) AND (籍贯 = ‘山西’ OR 籍贯 = ‘安徽’)) OR (工作 like ‘建筑%’  OR 工作like ‘%酒吧%’)</font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722422548370-8754f737-384d-4a4d-9583-170c26a7da2f.webp" alt=""></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722422552428-cbdd1348-ba6f-45c5-9f57-cecd71726c7b.webp" alt=""></p><p>5、结构化、非结构化的融合检索</p><p><font style="color:rgba(25, 26, 31, 0.9);">能够在进行等值、范围、多值列检索的同时，进行文本的匹配和计算，为大数据分析带来了新的可能性</font></p><h2 id="SQL-解析层">SQL 解析层</h2><h3 id="主要的优化手段">主要的优化手段</h3><p>1、执行下推</p><p><font style="color:rgba(25, 26, 31, 0.9);">执行下推是将SQL中可以依赖存储能力的关系代数计算进行提取，将查询计划等价转换为两部分，一部分在计算层执行，一部分下推给存储层执行</font></p><p>2、基于代价的查询优化器</p><p>3、查询计划缓存及调整</p><h3 id="执行计划">执行计划</h3><h4 id="传统的火山执行引擎">传统的火山执行引擎</h4><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722423394376-3f5c7b5a-51b6-4c3d-a316-79321b9fd080.webp" alt=""></p><p>生成一系列的算子（operator)</p><p>存在的问题：</p><p>1、代价很高的解释开销</p><p>2、较低的 cpu cache 命中率</p><p>next()是虚函数，导致 cpu 预测错误，耗费大量无用的 cpu 时间</p><h3 id="基于字节码生成技术的算子优化">基于字节码生成技术的算子优化</h3><p>使用 asm 技术，对 sql 算子进行特定的优化，如 for 循环、switch 等</p><h2 id="计算层（Lambda-结构）">计算层（Lambda 结构）</h2><p>每个 CN 节点都无状态</p><p>每个 CN 内部，数据分为两部分：</p><ul><li>全量<ul><li>全索引</li><li>列存储</li></ul></li></ul><p>全量数据走全索引查询</p><ul><li>增量</li></ul><p>分两步查询：</p><p><font style="color:rgba(25, 26, 31, 0.9);">1）利用block 级别索引剪裁无用block；</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">2）对有用数据块扫描；</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">两部分的结果汇总作为该分区的查询结果。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);"></font></p><p><font style="color:rgba(25, 26, 31, 0.9);">会定期合并增量数据  -&gt; 全量数据（重新排序 + 重建索引）</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">离线完成，不影响 CN 的查询（解耦）</font></p><h3 id=""></h3><h2 id="硬件加速">硬件加速</h2><p>使用 GPU 对一些可并行的逻辑进行加速</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722424520093-7730136a-4406-4572-877b-1565a7474ef6.webp" alt=""></p><p>1、 使用 gpu 进行聚合、join、hash 等计算</p><p>2、cpu、gpu 混合计算</p><p>执行计划层面、算子执行层面</p><p>3、gpu 代码动态生成技术</p><p>基于 llvm，根据逻辑执行计划，动态生成 gpu 物理执行计划</p><p>4、显存管理技术</p><p>5、GPU 解压技术</p><p>用 gpu 来进行数据解压缩，大幅提升性能</p><h1>动态流程</h1><h2 id="实时写入流程">实时写入流程</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722337555445-d2632d38-4954-45ec-993a-05523c3a7ab8.webp" alt=""></p><p>可横向扩展 FN、BN</p><p>写入不受制于某节点，完全松耦合、易扩展</p><p>注意：</p><p>1、BN 会定时将数据推送给 CN</p><p>2、CN 也会在需要的时候去 BN 里查数据</p><h3 id="font-style-color-rgba-25-26-31-0-9-性能-font"><font style="color:rgba(25, 26, 31, 0.9);">性能</font></h3><p><font style="color:rgba(25, 26, 31, 0.9);">写入速度上，单DB（20个FN）写入速度达到280W条每秒，每天入库数据量1600亿条，同时写入数据大小达到600MB每秒。</font></p><h2 id="查询过程">查询过程</h2><p>解析层生成执行计划（一个 DAG），然后生成物理执行计划（一系列的 task、operator 等）</p><p>FN 接收到请求，向 BN 收集涉及表的分区和最新写入的版本号</p><p>将查询的请求和版本号一起发给 CN</p><p>CN 对比本地的版本号和请求中的版本</p><p>若 CN 本地的版本号小于请求的版本，则去 BN 中拉取最新的数据（<font style="color:#DF2A3F;">可以保证写入实时可见</font>）</p><p>若 CN 本地的版本号大于等于请求的版本，则直接用 CN 本地的最新版本</p><p>然后进行数据查询操作</p><h1>参考文档</h1><p>1、<a href="https://grow.alibaba-inc.com/course/4800010774428817/section/1830000000000324?spm=ata.23639746.0.0.cd145de7lcay5p">https://grow.alibaba-inc.com/course/4800010774428817/section/1830000000000324?spm=ata.23639746.0.0.cd145de7lcay5p</a></p><p>2、ADB 的论文</p><p><a href="https://www.vldb.org/pvldb/vol12/p2059-zhan.pdf">https://www.vldb.org/pvldb/vol12/p2059-zhan.pdf</a></p><p>3、<a href="https://ata.atatech.org/articles/11000111313?layout=%2Fvelocity%2Flayout%2Fblank.vm#yetk7VY2"><strong>No.4.深度解析AnalyticDB-玄武存储引擎-支撑每秒千万级数据写入的读写分离架构</strong></a></p><p>4、<a href="https://ata.atatech.org/articles/11000111315?layout=%2Fvelocity%2Flayout%2Fblank.vm">No.8深度解析AnalyticDB-硬件加速- 如何利用新硬件加速OLAP查询</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> NewSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 常用语法</title>
      <link href="/2024/09/01/MongoDB%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/09/01/MongoDB%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>聚合操作<font style="color:rgb(221, 74, 104);background-color:rgb(245, 242, 240);">aggregate</font></h1><p>聚合操作，通过操作一系列的阶段 stage，来对数据进行处理。每个阶段都会对数据进行处理，然后转换给下一阶段，就像「管道」一样</p><p>常见的聚合操作 stage 有：</p><ol><li><code>**&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$match&lt;/font&gt;**</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：用于过滤数据，只让符合条件的文档进入下一个管道阶段。</font></li><li><code>**&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$group&lt;/font&gt;**</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：根据指定的表达式对输入文档进行分组，可以计算分组内文档的聚合值（如总和、平均值、最大值等）。</font></li><li><code>**&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$sort&lt;/font&gt;**</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：将输入文档按指定字段排序。</font></li><li><code>**&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$project&lt;/font&gt;**</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：投影，修改输入文档的结构，可以用来重命名、增加、删除字段或计算新值。</font></li><li><code>**&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$limit&lt;/font&gt;**</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：限制聚合管道返回的文档数。</font></li><li><code>**&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$skip&lt;/font&gt;**</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：跳过指定数量的文档，常与</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$limit&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">一起使用实现分页。</font></li><li><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">还有很多其他阶段，如</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$unwind&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">、</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$lookup&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">等，用于更复杂的数据处理需求。</font></li></ol><p><font style="background-color:rgb(245, 242, 240);"></font></p><h2 id="unwind">$unwind</h2><p>类似一行转多行</p><p><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$unwind&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">是一个</font><font style="color:#DF2A3F;background-color:rgb(247, 249, 253);">聚合管道阶段</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">的操作符</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">它的主要作用是从文档的数组字段中取出每个元素，然后为每个元素生成一个新文档，这样做的结果就是将数组拆分成多条独立的记录。这对于处理数组类型的字段并且需要对数组中的每个元素进行单独操作或分析时非常有用。</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"></font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">还可以接受其他参数，来进行行为控制，如</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">preserveNullAndEmptyArrays 选项可以用来决定是否保留那些数组字段为空或不存在的文档。</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"></font></p><h2 id="font-style-color-rgb-153-0-85-background-color-rgb-245-242-240-match-font-font-style-color-rgb-154-110-58-font"><font style="color:rgb(153, 0, 85);background-color:rgb(245, 242, 240);">$match</font><font style="color:rgb(154, 110, 58);">:</font></h2><p>类似 sql 的 where 中的过滤？？？</p><p><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$match&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">是用来过滤聚合管道（Aggregation Pipeline）中的文档的数据处理阶段。它的主要作用是从输入的文档集合中找出符合指定条件的文档，并将这些文档传递给管道的下一个阶段。</font></p><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">使用</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$match&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">的优势包括：</font></p><ol><li><strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">减少处理的数据量</font></strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：将</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$match&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">放在管道的开始，可以尽早过滤掉不需要的文档，从而减少后续管道阶段处理的数据量，提高整体效率。</font></li><li><strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">优化性能</font></strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：尤其是在处理大量数据时，先通过</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$match&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">筛选可以显著减少资源消耗和提高查询速度。</font></li><li><strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">逻辑分组和计算前的预处理</font></strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：在进行分组(</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$group&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">)、排序(</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$sort&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">)或其他操作之前，使用</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$match&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">来过滤数据，可以使这些操作更加高效。</font></li></ol><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"></font></p><pre><code class="language-java"> { $match: { age: { $gt: 20 } } }</code></pre><h2 id="font-style-color-rgb-51-51-51-background-color-rgb-247-249-253-group-font"><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">$group:</font></h2><p><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$group&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">是一个聚合管道阶段，用于将集合中的文档分组，根据指定的表达式来聚集文档，然后对每个分组执行各种聚合操作，如计算总和、平均值、最大值、最小值等。</font></p><p>主要用途包括：</p><ol><li><strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">数据分组</font></strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：根据一个或多个字段的值将文档划分到不同的组。</font></li><li><strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">聚合计算</font></strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：对每个组执行计算，如求和、平均、最大值、最小值等。</font></li><li><strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">聚合数组</font></strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：将来自同一组的文档的数组字段合并成一个数组。</font></li><li><strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">计数</font></strong><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">：计算每个组的文档数量。</font></li></ol><p>主要参数有：</p><p><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;_id&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 这是分组的依据，可以是字段名或者一个表达式。如果指定为null，则所有文档视为一个组。</font></p><p><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;field1&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 自定义输出字段名，表示聚合计算的结果。</font></p><p><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;accumulator&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 聚合运算符，用于定义如何处理分组内的文档，常见的有：</font></p><ul><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$sum&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 计算总和。</font></li><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$avg&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 计算平均值。</font></li><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$min&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 找出最小值。</font></li><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$max&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 找出最大值。</font></li><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$push&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 将分组内文档的某个字段值放入一个数组中。</font></li><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$addToSet&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 类似于</font><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$push&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">，但会确保数组中的元素不重复。</font></li><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$first&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 选取每个分组中第一个文档的指定字段值。</font></li><li><code>&lt;font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);"&gt;$last&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">: 选取每个分组中最后一个文档的指定字段值。</font></li></ul><pre><code class="language-plain">{    "_id":"待分组的字段",        "要展示的字段1":{{"$sum":"进行累加的字段"}},        // 计算每个item的总销售额    "totalPrice": { $sum: { $multiply: ["$quantity", "$price"] } } }</code></pre><pre><code class="language-plain">{"$group":{  _id:{fieldA:"$字段1",fieldB:"$字段2"}，  count: { $sum: 1 } // 计算每个组的文档数量}}</code></pre><h2 id="sort">$sort</h2><p>用作排序</p><pre><code class="language-java">aggrate([        {$sort:{field1:-1,field:1,fieldDesc:-1,fieldAsc:1}}])    </code></pre><h2 id="font-style-color-rgb-153-0-85-background-color-rgb-245-242-240-lookup-font"><font style="color:rgb(153, 0, 85);background-color:rgb(245, 242, 240);">$lookup</font></h2><p><font style="color:rgb(51, 51, 51);background-color:rgb(247, 249, 253);">是一个聚合管道阶段，用于将来自一个集合的文档与另一个集合中的文档进行“连接”操作，类似于SQL中的JOIN。这对于处理数据分布在多个集合中的情况非常有用，可以将相关数据组合在一起，便于分析或查询。</font></p><pre><code class="language-java">{  $lookup:  {    from: &lt;字符串&gt;,    localField: &lt;字符串&gt;,    foreignField: &lt;字符串&gt;,    as: &lt;字符串&gt;  }}</code></pre><h1>其他操作</h1><h2 id="投影">投影</h2><p>在 find 或 aggrate 语句中，可以添加额外的参数，来控制哪些字段需要返回，哪些字段不需要返回</p><pre><code class="language-plain">db.collection.find({},{_name:0,_age:1})</code></pre><h2 id="常见逻辑判断">常见逻辑判断</h2><h3 id="为空判断">为空判断</h3><p>$exists、$eq</p><h1>采购大脑流程</h1><h2 id="定义数据源">定义数据源</h2><p>对应了 MongoDB 中的集合 Collection</p><h2 id="定义指标配置管理">定义指标配置管理</h2><p>对应了在 group 中统计的方式，如 sum、max、min 等</p><p>只有 7，8 个，对应了 $group 中的展示字段</p><p>如计数、时效（平均值/时间）、求和、列表（什么逻辑都没有）、平均值等</p><p>需要计算的字段，用占位符代替，在后续的指标中会使用</p><h2 id="定义指标分组管理">定义指标分组管理</h2><p>待梳理</p><h2 id="字段管理">字段管理</h2><p>对数据源中的 no schema 的文档自动，做一个定义，抽取感兴趣的字段，用于业务使用</p><p>有父级字段，即 jsonPath 的方式</p><p>分日期、数值、字符串、数组、布尔、对象等</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722847328230-e27b4f5a-1ec4-454b-8237-c72928c98764.png" alt=""></p><h2 id="指标管理">指标管理</h2><p>基于指标配置，聚合出来的指标</p><p>根据不同的业务需求，可以定义不同含义的指标</p><h2 id="指标实例管理">指标实例管理</h2><p>最终给用户（技术同学）用的对象，采购大脑查询就是查的这个指标实例</p><p>可以定义筛选字段、分组字段、附件字段（即展示字段）</p><h2 id="查询过程">查询过程</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1722847569320-6a3bde9f-c931-40cc-bbc8-acf8b50ba14c.jpeg" alt="画板"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2024/09/01/MongoDB/"/>
      <url>/2024/09/01/MongoDB/</url>
      
        <content type="html"><![CDATA[<h1>关键字</h1><p><font style="color:rgb(44, 62, 80);">上限集合(Capped Collection)</font></p><p><font style="color:rgb(44, 62, 80);">上限集合类似于定长的循环队列，数据顺序追加到集合的尾部，当集合空间达到上限时，它会覆盖集合中最旧的文档。上限集合的数据将会被顺序写入到磁盘的固定空间内，所以，I/O 速度非常快，如果不建立索引，性能更好。</font></p><p><font style="color:rgb(44, 62, 80);"></font></p><p><font style="color:rgb(44, 62, 80);">分片</font></p><p><font style="color:rgb(44, 62, 80);">副本</font></p><p><font style="color:rgb(44, 62, 80);">链式复制、非链式复制</font></p><p><font style="color:rgb(44, 62, 80);"></font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1723006197692-7fb2c357-5b52-4758-b617-2c16bc71964c.png" alt=""></p><p><font style="color:rgb(44, 62, 80);">高可用-复制集群</font></p><p>Primary 节点</p><p>Secondary 节点</p><p>Arbitoer 节点（仲裁节点）</p><p>高伸缩-分片集群</p><p>MongoDB 的分布式版本，用于提升集群的数据容量，读吞吐量，分散读写压力</p><p>configserver：配置服务</p><p>shard：分片服务</p><p>mongdos：路由服务</p><p>分片键（Shard Key):</p><p>决定了分片数据在分片中的分布情况</p><p><strong><font style="color:rgb(44, 62, 80);">Chunk（块）:</font></strong></p><p><strong><font style="color:rgb(44, 62, 80);">分片集群的一个概念，本质上就是一堆 Document 的逻辑数据单元，每个 Chunk 包含一定范围的片键的数据</font></strong></p><p><strong><font style="color:rgb(44, 62, 80);">属于离散数学中的划分概念</font></strong></p><p><strong>均衡器(Balancer)</strong> 、再平衡：</p><p>chunk 分裂的过程</p><p><font style="color:rgb(25, 27, 31);">GridFS：支持超大文件分片存储</font></p><p><font style="color:rgb(25, 27, 31);">写关注（Write Concern）：</font></p><p><font style="color:rgb(25, 27, 31);">用来描述数据库写操作返回信息的保证级别，有3种选项，分别为0 - Unacknowledged、1 - Acknowledged、 majority - Replica Acknowledged，</font></p><h1>概述</h1><h2 id="什么是-MongoDB">什么是 MongoDB</h2><p><font style="color:rgb(37, 41, 51);">由</font><font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">C++</font><font style="color:rgb(37, 41, 51);">语言编写，基于分布式文件存储的，</font><font style="color:rgb(37, 41, 51);">介于关系数据库与非关系</font><font style="color:rgb(37, 41, 51);">数据库</font></p><h2 id="特点">特点</h2><p><font style="color:rgb(0, 0, 0);">它是一种面向集合，模式无关的文档型数据库。其中数据以“集合”的方式进行分组，每个集合都有单独的名称并可以包含无限数量的文档。这里的集合同关系型数据库中的表（table）类似，唯一的区别就是它并没有任何明确的schema。 MongoDB以一系列键值对集合的方式存储数据，其中键(Key)是字符串，值(Value)是任何一种数据类型的集合，包括数组和文档。</font></p><h2 id="font-style-color-rgb-0-0-0-适用场景-font"><font style="color:rgb(0, 0, 0);">适用场景</font></h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722439358133-8ffc32ec-ebb6-4e3e-9d7a-47d671c762fe.webp" alt=""></p><h1>原理</h1><h2 id="索引类型有哪些？">索引类型有哪些？</h2><ul><li>单字段索引(<code>Single Field Indexes</code>)</li><li>复合索引(<code>Compound Indexes</code>)</li><li>多键索引(<code>Multikey Indexes</code>)</li><li>全文索引(<code>text Indexes</code>)</li><li>Hash 索引(<code>Hash Indexes</code>)</li><li>通配符索引(<code>Wildcard Index</code>)</li><li>2dsphere索引(<code>2dsphere Indexes</code>)</li></ul><h3 id="索引的限制">索引的限制</h3><p>额外的开销：</p><p>索引是存放在内存中的：当内存不够时，会删掉一些索引</p><p>在正则和非操作符（$nin、$not 等）、算数操作符、$where 子句中不会使用索引</p><h2 id="引擎">引擎</h2><h3 id=""><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1722437086550-6a3e1ce9-8d00-4095-9f45-d67af47bd616.webp" alt=""></h3><h3 id="MMAP（内存映射）">MMAP（内存映射）</h3><p>3.0 版本之前，只有这一种</p><p>锁颗粒度较粗</p><p><font style="color:rgba(25, 26, 31, 0.9);">基于填充因子的自适应分配方式(paddingFactor)，这种方式下将会基于每个集合计算历史的文档更新平均增长长度，每当新文档插入或者老文档移动，都会基于填充因子推算出额外空间填充进去。MMAP还提供了一种基于usePowerOf2Sizes的预分配方式，这种方式直接为文档分配2的N次方大小的存储空间。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">将所有文件、索引存储到了一起，不利于磁盘空间回收</font></p><h3 id="MMAPv1">MMAPv1</h3><p>3.0 版本之后</p><p>锁颗粒较细（库级别 -&gt; 集合级别）</p><p><font style="color:rgba(25, 26, 31, 0.9);">将基于usePowerOf2Sizes的预分配方式作为默认的文档空间分配方式</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">创建集合的时候还可以设置成noPadding标签，关闭空间预分配。</font></p><h3 id="font-style-color-rgba-25-26-31-0-9-WiredTiger（重点，类-b-树）-font"><font style="color:rgba(25, 26, 31, 0.9);">WiredTiger（重点，类 b+树）</font></h3><p>锁粒度进一步细化（集合级别 -&gt;  文档级别），类似于 MySQL 中的行锁了</p><p>压缩算法</p><p><font style="color:rgba(25, 26, 31, 0.9);">支持对所有集合和索引进行块压缩和前缀压缩，包括journal日志，</font></p><ul><li><font style="color:rgba(25, 26, 31, 0.9);">Snappy（默认）：压缩速度快，cpu 开销低，适合大多数业务场景</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">Zlib：压缩率高，但是速度慢</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">none(不压缩)</font></li></ul><p>文件格式：</p><p>集合、索引存放到单独的文件中，便于删除后及时释放空间</p><h4 id="原理">原理</h4><p>以 page 为单位向磁盘中写数据，每个 page 是 b+树中的一个节点</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723006552248-d04cd313-623f-4be6-a824-2f29385b48a2.webp" alt=""></p><p>官网讲解文档：</p><p><a href="https://mongoing.com/archives/category/wiredtiger%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e7%b3%bb%e5%88%97">https://mongoing.com/archives/category/wiredtiger%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e7%b3%bb%e5%88%97</a></p><h4 id="写入流程">写入流程</h4><p><font style="color:rgb(25, 27, 31);">WiredTiger的写操作会先写入Cache，并持久化到WAL(Write ahead log)，每60s或log文件达到2GB时会做一次Checkpoint，将当前的数据持久化，产生一个新的快照。Wiredtiger连接初始化时，首先将数据恢复至最新的快照状态，然后根据WAL恢复数据，以保证存储可靠性。</font></p><p><font style="color:rgb(25, 27, 31);">写关注（Write Concern）：</font></p><p><font style="color:rgb(25, 27, 31);">用来描述数据库写操作返回信息的保证级别，有3种选项，分别为0 - Unacknowledged、1 - Acknowledged、 majority - Replica Acknowledged</font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723007149825-2a3bf1db-fffe-47d6-b106-bb100bb1a20a.webp" alt=""></p><h4 id="修改流程">修改流程</h4><p>原理是修改的时候，会生成新的节点，不修改原有的节点</p><p>会导致 b+树越来越大，但是写入性能强（空间换时间）</p><h3 id="font-style-color-rgba-25-26-31-0-9-MongoRocks-font"><font style="color:rgba(25, 26, 31, 0.9);">MongoRocks</font></h3><p>基于 facebook 开源的 rocksDB 实现的存储引擎</p><p>最大的特点：支持高并发随机写入和读取</p><p>压缩算法更多：</p><p><font style="color:rgba(25, 26, 31, 0.9);">Snappy、Zlib和LZ4等压缩算法</font></p><h3 id="font-style-color-rgba-25-26-31-0-9-In-Memory-官方企业版-font"><font style="color:rgba(25, 26, 31, 0.9);">In-Memory(官方企业版)</font></h3><h3 id="其他特殊版本">其他特殊版本</h3><h2 id="架构">架构</h2><h3 id="副本集群">副本集群</h3><p>支持数据一致性要求强、要求不强的场景</p><p>即 MongoDB 的高可用解决方案</p><p>通过 opLog 的复制来实现数据同步和最终一致性</p><p>类似 MySQL 的 binlog，但 binLog 是二进制文件；但是 opLog 是 MongoDB 的一个特殊集合，叫<font style="color:rgba(25, 26, 31, 0.9);">capped collection</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">这种集合在创建初期就设置其大小或者文档最大数量，后续按照LRU(Least Recently Used)规则和插入顺序进行 age-out。</font></p><p>opLog 的特点：</p><ul><li><font style="color:rgba(25, 26, 31, 0.9);">可插入和更新，更新不能超出文档大小，否则更新失败；</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">不可以删除文档，只能删除整个集合；</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">32bit系统上大小有限制，而64bit系统则无文件大小限制；</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">在这个集合上无法进行分片；</font></li></ul><p>副本集的特点：</p><ul><li><font style="color:rgba(25, 26, 31, 0.9);">MongoDB副本集拥有具备各种功能的多种角色，比如投票节点、隐藏从库、延迟从库等；</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">MongoDB可配置每个成员的优先级(priority)和投票数(votes)，以此来建设异地容灾集群，比如我就指定某地域只能选主，其他地域只提供读服务；</font></li><li><font style="color:rgba(25, 26, 31, 0.9);">结合强大的MongoDB驱动实现读写分离、强一致。</font></li></ul><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722867957179-c22c79fa-1cc0-45cc-8662-b1aa2a53905d.png" alt=""></p><h3 id="分片集群">分片集群</h3><p>水平扩容的一种</p><p>支持自动分片、手动分片</p><p><strong><font style="color:rgb(48, 48, 48);">自动预分片支持：</font></strong><font style="color:rgb(48, 48, 48);">如果分片集群选用 hash 分片策略，则支持 shardCollection 时提前对片建进行自动预备分片。</font></p><p><strong><font style="color:rgb(48, 48, 48);">手动预分片支持：</font></strong><font style="color:rgb(48, 48, 48);">hash 分片策略和范围分片策略都可以通过 mongodb 自有的 splitAt 等接口进行手动人工预分片，分片接口的支持确保预分片更加弹性自由。</font></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722868180081-93729ea0-ba69-4d45-8c96-2dda146b126a.png" alt=""></p><h4 id="组成">组成</h4><ul><li><strong>Config Servers</strong>：配置服务器，本质上是一个 MongoDB 的副本集，负责存储集群的各种元数据和配置，如分片地址、Chunks 等</li><li><strong>Mongos</strong>：路由服务，不存具体数据，从 Config 获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。</li><li><strong>Shard</strong>：每个分片是整体数据的一部分子集，从 MongoDB3.6 版本开始，每个 Shard 必须部署为副本集（replica set）架构</li></ul><p>分片键：</p><p>要求得是文档的字段</p><p>且是一个索引（不能是多索引、文本索引、地理空间索引）</p><p>5.0 之后，分片键实时可变</p><p>大小不能超过 512 字节</p><p><strong>选择要求：</strong></p><ul><li><strong>取值基数</strong> 取值基数建议尽可能大，如果用小基数的片键，因为备选值有限，那么块的总数量就有限，随着数据增多，块的大小会越来越大，导致水平扩展时移动块会非常困难。 例如：选择年龄做一个基数，范围最多只有 100 个，随着数据量增多，同一个值分布过多时，导致 chunck 的增长超出 chuncksize 的范围，引起 jumbo chunk，从而无法迁移，导致数据分布不均匀，性能瓶颈。</li><li><strong>取值分布</strong> 取值分布建议尽量均匀，分布不均匀的片键会造成某些块的数据量非常大，同样有上面数据分布不均匀，性能瓶颈的问题。</li><li><strong>查询带分片</strong> 查询时建议带上分片，使用分片键进行条件查询时，mongos 可以直接定位到具体分片，否则 mongos 需要将查询分发到所有分片，再等待响应返回。</li><li><strong>避免单调递增或递减</strong> 单调递增的 sharding key，数据文件挪动小，但写入会集中，导致最后一篇的数据量持续增大，不断发生迁移，递减同理。</li></ul><h4 id="分片策略">分片策略</h4><ul><li>基于 hash 分片</li></ul><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722868527447-9e76852e-dafe-4ff0-84a5-bfb71dd3c127.png" alt=""></p><ul><li>基于范围分片</li></ul><h4 id="Chunk">Chunk</h4><p>分片集群不会记录每条数据在哪个分片上，而是记录 Chunk 在哪个分片上一级这个 Chunk 包含哪些数据。</p><p>默认情况下，一个 Chunk 的最大值默认为 64MB（可调整，取值范围为 1~1024 MB。如无特殊需求，建议保持默认值），进行数据插入、更新、删除时，如果此时 Mongos 感知到了目标 Chunk 的大小或者其中的数据量超过上限，则会触发 <strong>Chunk 分裂</strong>。</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722868686348-745876a6-d563-439d-94cc-dae4bd884d06.png" alt=""></p><p>数据的增长会让 Chunk 分裂得越来越多。这个时候，各个分片上的 Chunk 数量可能会不平衡。Mongos 中的 <strong>均衡器(Balancer)</strong> 组件就会执行自动平衡，尝试使各个 Shard 上 Chunk 的数量保持均衡，这个过程就是 <strong>再平衡（Rebalance）</strong>。默认情况下，数据库和集合的 Rebalance 是开启的。</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722868691093-c2c79302-92fb-4c5c-8df6-ab2d7a286b7b.png" alt=""></p><h1><font style="color:rgb(0, 0, 0);">优点</font></h1><ul><li><font style="color:rgb(37, 41, 51);">架构简单</font></li><li><font style="color:rgb(37, 41, 51);">没有复杂的连接</font></li><li><font style="color:rgb(37, 41, 51);">深度查询能力,</font><code>&lt;font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);"&gt;MongoDB&lt;/font&gt;</code><font style="color:rgb(37, 41, 51);">支持动态查询。</font></li><li><font style="color:rgb(37, 41, 51);">容易调试</font></li><li><font style="color:rgb(37, 41, 51);">容易扩展</font></li><li><font style="color:rgb(37, 41, 51);">不需要转化/映射应用对象到数据库对象</font></li><li><font style="color:rgb(37, 41, 51);">使用内部内存作为存储工作区,以便更快的存取数据。</font></li></ul><h1>MongoDB 本身可能存在的问题</h1><h2 id="1、opLog-循环复制问题">1、opLog 循环复制问题</h2><p>集团的 MongDB 打了补丁，修改了 opLog 的格式</p><h3 id="2、opLog-不支持-回滚？">2、opLog 不支持 回滚？</h3><p>给 opLog 加上了全镜像功能</p><h2 id="font-style-color-rgb-0-0-0-与其他产品的对比-font"><font style="color:rgb(0, 0, 0);">与其他产品的对比</font></h2><table><thead><tr><th><strong><font style="color:#252933;">形式</font></strong></th><th><strong><font style="color:#252933;">MongoDB</font></strong></th><th><strong><font style="color:#252933;">MySQL</font></strong></th></tr></thead><tbody><tr><td><font style="color:#252933;"> 数据库模型</font></td><td><font style="color:#252933;">非关系型</font></td><td><font style="color:#252933;">关系型</font></td></tr><tr><td><font style="color:#252933;"> 存储方式</font></td><td></td><td><font style="color:#252933;">虚拟内存+持久化</font></td></tr><tr><td><font style="color:#252933;"> 查询语句</font></td><td><font style="color:#252933;">独特的MongoDB查询方式</font></td><td><font style="color:#252933;">传统SQL语句</font></td></tr><tr><td><font style="color:#252933;"> 架构特点</font></td><td><font style="color:#252933;">副本集以及分片</font></td><td><font style="color:#252933;">常见单点、M-S、MHA、MMM等架构方式</font></td></tr><tr><td><font style="color:#252933;"> 数据处理方式</font></td><td><font style="color:#252933;">基于内存，将热数据存在物理内存中，从而达到高速读写</font></td><td><font style="color:#252933;">不同的引擎拥有自己的特点</font></td></tr><tr><td><font style="color:#252933;"> 使用场景</font></td><td><font style="color:#252933;">事件的记录，内容管理或者博客平台等数据大且非结构化数据的场景</font></td><td><font style="color:#252933;">适用于数据量少且很多结构化数据</font></td></tr></tbody></table><table><thead><tr><th><strong><font style="color:#252933;">形式</font></strong></th><th><strong><font style="color:#252933;">MongoDB</font></strong></th><th><strong><font style="color:black;">redis</font></strong></th></tr></thead><tbody><tr><td><font style="color:#252933;"> 内存管理机制</font></td><td><font style="color:#252933;">MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘</font></td><td><font style="color:#252933;">Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据</font></td></tr><tr><td><font style="color:#252933;"> 支持的数据结构</font></td><td><font style="color:#252933;">MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引</font></td><td><font style="color:#252933;">Redis 支持的数据结构丰富，包括hash、set、list等</font></td></tr><tr><td><font style="color:#252933;"> 性能</font></td><td><font style="color:#252933;">mongodb依赖内存，TPS较高</font></td><td><font style="color:#252933;">Redis依赖内存，TPS非常高。性能上Redis优于MongoDB</font></td></tr><tr><td><font style="color:#252933;"> 可靠性</font></td><td><font style="color:#252933;">支持持久化以及复制集增加可靠性</font></td><td><font style="color:#252933;">Redis依赖快照进行持久化；AOF增强可靠性；增强可靠性的同时，影响访问性能</font></td></tr><tr><td><font style="color:#252933;"> 数据分析</font></td><td><font style="color:#252933;">mongodb内置数据分析功能（mapreduce）</font></td><td><font style="color:#252933;">Redis不支持</font></td></tr><tr><td><font style="color:#252933;"> 事务支持情况</font></td><td><font style="color:#252933;">只支持单文档事务，需要复杂事务支持的场景暂时不适合</font></td><td><font style="color:#252933;">Redis 事务支持比较弱，只能保证事务中的每个操作连续执行</font></td></tr><tr><td><font style="color:#252933;"> 集群</font></td><td><font style="color:#252933;">MongoDB 集群技术比较成熟</font></td><td><font style="color:#252933;">Redis从3.0开始支持集群</font></td></tr></tbody></table><h1>参考</h1><p>1、<a href="https://juejin.cn/post/6844903965629349895">https://juejin.cn/post/6844903965629349895</a></p><p>2、<a href="https://ata.atatech.org/articles/11000077531">MongoDB在集团的使用</a></p><p>3、【【驳斥八股文系列】别瞎分析了，MongoDB 使用的是 B+ 树，不是你们以为的 B 树】<a href="https://zhuanlan.zhihu.com/p/519658576">https://zhuanlan.zhihu.com/p/519658576</a></p><p>4、<a href="https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">https://javaguide.cn/database/mongodb/mongodb-questions-02.html#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4</a></p><p>5、【<a href="https://mongoing.com/archives/77479"><font style="color:rgb(85, 85, 85);">一文读懂 MongoDB chunk 迁移</font></a>】</p><p><a href="https://mongoing.com/archives/77479">https://mongoing.com/archives/77479</a></p><p>6、<a href="https://zhuanlan.zhihu.com/p/122287797">https://zhuanlan.zhihu.com/p/122287797</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图数据库</title>
      <link href="/2024/09/01/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/09/01/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>1、企典的企业管理关系在用</p><p>阿里云的GDB</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1718330676257-273716a2-6f73-49e9-a462-f3ad450aa018.png" alt=""></p><p><a href="https://www.aliyun.com/product/gdb">https://www.aliyun.com/product/gdb</a></p><p>2、企典其他平台在用的：<font style="color:rgb(0, 0, 0);">interactive</font></p><p><font style="color:rgb(0, 0, 0);">没搜到，貌似是内测的产品</font></p><p><font style="color:rgb(0, 0, 0);"></font></p><p><font style="color:rgb(0, 0, 0);">3、开源的neo4j</font></p><p><font style="color:rgb(0, 0, 0);">4、MongoDB（图数据库扩展）</font></p><p><font style="color:rgb(0, 0, 0);">5、AgentsGraph是一个基于PostgreSQL </font></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2024/09/01/Redis/"/>
      <url>/2024/09/01/Redis/</url>
      
        <content type="html"><![CDATA[<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1725165586488-3281dd1f-8d5b-48bf-bae0-07e01d749d30.jpeg" alt="画板"></p><h1>为什么快</h1><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1711266375077-18b1b0f0-6727-4030-9c39-d68be184d271.png" alt=""></p><p>1、基于内存</p><p>2、采用reactor模型</p><p>3、高效的数据结构</p><h2 id="基础数据结构">基础数据结构</h2><h3 id="String（SDS）">String（SDS）</h3><p>底层结构</p><p>长度 + 数组</p><p>应用场景</p><p>常规数据、计时</p><p>分布式锁：</p><p>setnx key value</p><h3 id="Hash">Hash</h3><p>应用场景：</p><p>相比较String，适用于经常存取对象中的个别字段信息</p><p>如购物车（key为用户id，value为&lt;商品，商品数量&gt;）</p><p>有两个数组，渐进式 hash 迁移数据</p><h3 id="List">List</h3><h3 id="Set">Set</h3><h3 id="SortSet">SortSet</h3><p>skipList(跳表)，高效的查询性能</p><h3 id="ZSet（有序集合）">ZSet（有序集合）</h3><p>使用场景：</p><p>排行榜(如直播送礼物的排行榜、微信步数排行榜、游戏段位排行榜、话题热搜排行榜等)</p><h1>高可用</h1><h2 id="主从复制">主从复制</h2><p>master节点 -&gt;  同步数据给slave节点，最终达到最终一致性</p><p>节点出错，需要人工干预，手动进行故障恢复</p><h2 id=""></h2><h2 id="Redis-Sentinel（自动进行故障恢复）">Redis Sentinel（自动进行故障恢复）</h2><p>哨兵节点、主从节点，是不一样的节点</p><h3 id="能力：监控、通知、自动故障恢复、配置中心">能力：监控、通知、自动故障恢复、配置中心</h3><p>天然的分布式架构、至少三个节点</p><p>节点自动发现</p><p>使用INFO 命令，去找主节点，从主节点那里，获取从节点的信息</p><p>使用发布、订阅的机制，使用默认的通道，接收其他哨兵同步的信息</p><h4 id="故障检测：">故障检测：</h4><p>主观宕机SDOWN：针对主节点、从节点、其他哨兵节点</p><p>客观宕机ODOWN：仅针对主节点</p><h4 id="故障转移：">故障转移：</h4><p>几个状态：</p><p>SENTINEL_FAILOVER_STATE_XXXX</p><p>NONE:</p><p>WAIT_START: 选择负责的sentinel的leader的选举，去对故障的master节点进行恢复</p><p>SELECT_SLAVE:负责的sentinel节点从 该主节点下存活的从节点里，选一个当主节点</p><p>选最完整的从节点</p><p>SEND_SLAVEOF_NOONE:</p><p>选择好的新主节点后，开始配置新主节点</p><p>WAIT_PROMOTION:</p><p>等待从节点自己提升为master节点</p><p>RECONF_SLAVES:</p><p>配置其他从节点，以新主节点为准，进行主从复制</p><p>UPDATE_CONFIG:</p><p>更新主节点的配置，正式完成故障转移，对外提供服务</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1711625857757-632a6802-16e2-4427-81de-e932670790b7.png" alt=""></p><p>注意：</p><p>1、sentinel 不主动移除从节点信息，为了提高恢复效率吧</p><p>2、脑裂的情况下，无法完全避免数据丢失。但是可以配置</p><pre><code class="language-json">min-replicas-to-write 1min-replicas-max-lag 10</code></pre><p>使丢失降到最低</p><h2 id="Redis-Cluster">Redis Cluster</h2><p>提供高伸缩性</p><h3 id="示意图">示意图</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723032021947-125fb46f-dc29-44c0-bec9-7f6d2ea3e9cf.webp" alt=""></p><h4 id="哈希槽映射">哈希槽映射</h4><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723032052934-a5690bb9-10d2-4a40-996f-f85ed7707e8b.webp" alt=""></p><h1>常见面试题</h1><h1>参考：</h1><p>1、<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzI0NTE4NDg0NA==&amp;hid=1&amp;sn=3174a495bc96271a7ae163f9d60b9f37">https://mp.weixin.qq.com/mp/homepage?__biz=MzI0NTE4NDg0NA==&amp;hid=1&amp;sn=3174a495bc96271a7ae163f9d60b9f37</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TDDL</title>
      <link href="/2024/08/31/TDDL/"/>
      <url>/2024/08/31/TDDL/</url>
      
        <content type="html"><![CDATA[<h1>解决的问题</h1><p>1、单一数据库无法满足性能需求</p><p>读写分离、垂直分表、水平分表、分布式事务</p><p>2、系统容灾</p><p>3、运维管理</p><h1>原理</h1><h2 id="整体结构">整体结构</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1710666507554-5303aa8e-d53c-42be-814f-08c941af6757.png" alt=""><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1710666526744-ff9f22c8-5a05-483a-8ead-949f0780287e.png" alt=""></p><h2 id="执行原理">执行原理</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1710666553059-2c207052-1390-435f-a7f2-c8509dd8dd77.png" alt=""></p><h2 id="执行流程">执行流程</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1710676746044-c5fcc982-2de3-4bb3-b221-c983e3725327.png" alt=""></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1710676790907-52212d1d-ebc5-485d-9fbf-ddfbf3dfdcc1.png" alt=""></p><h1>核心组件</h1><h2 id="Matrix层">Matrix层</h2><p>1、解决分库分表带来的问题，影响数据访问的路由；</p><p>2、解决事务问题</p><ul><li>固定哈希算法</li><li>一致性哈希算法</li><li>自定义路由：<ul><li>如userId%表大小</li></ul></li></ul><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1710676974499-134e48e4-319b-4124-996a-42702943d687.png" alt=""></p><h2 id="Group-层">Group 层</h2><p>作用：</p><p>读写分离</p><p>主备切换</p><p>权重选择</p><p>数据保护：数据库连接down后，保护程序不会因为数据库挂掉而整体卡死</p><h2 id="Atom层">Atom层</h2><p>基于Druid连接池</p><p>作用：</p><p>动态创建、添加、减少数据源</p><p>对数据库做了代理，对单库的jdbc进行了封装</p><p>统计计数</p><h1>Sequence</h1><h2 id="单数据源">单数据源</h2><p>使用DefaultSequenceDao</p><h2 id="多数据源">多数据源</h2><p>使用使用GroupSequenceDao</p><p>多个实例的Sequence表</p><p>value步长 = innerStep * dscount</p><p>关键参数：</p><p>dscount：数据源的个数，值需要大于等于实际的数据源个数</p><p>可以大于数据源：为以后增加数据源预留空间、为单元化多数据源提供基础</p><p>dbGroupKeys：对应tddl中group name</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引相关</title>
      <link href="/2024/08/31/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/08/31/MySQL%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>B 树索引</p><p>聚簇索引</p><p>hash 索引（自适应 hash 索引，索引的索引）</p><h1>索引合并</h1><p>使用 explain 分析，当 type = index_merge 时，表示使用了索引合并</p><p>定义：</p><p>当一次查询中包含了多个条件，并可以用到多个索引时，可以将这些索引合并起来，减少回表查询次数</p><p>使用：</p><p>1、 有 mysql 的参数控制</p><p>2、查询的多个列上有索引，可能会多个列上都使用索引，并将结果合并起来使用</p><h1>参考：</h1><p>1、<a href="https://www.sohu.com/a/723166711_121124376">https://www.sohu.com/a/723166711_121124376</a></p><p>2、<a href="https://blog.csdn.net/java_chegnxuyuan/article/details/104996349">https://blog.csdn.net/java_chegnxuyuan/article/details/104996349</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库框架 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的锁</title>
      <link href="/2024/08/31/MySQL%E7%9A%84%E9%94%81/"/>
      <url>/2024/08/31/MySQL%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1>锁</h1><p><strong>按照颗粒度分：</strong></p><ul><li>全局锁：锁整个database，由MySQL的SQL Layer层（核心服务层）实现。</li><li>表级锁：锁某个table，由MySQL的SQL Layer层实现。<ul><li><font style="color:rgb(37, 41, 51);">自增锁（AUTO-INC LOCK）</font></li></ul></li><li>行级锁：锁某Row的索引，也可锁定行索引之间的间隙，由存储引擎实现【InnoDB】<ul><li><strong>记录锁</strong>（Record Locks）：锁定索引中的一条记录</li><li><strong>间隙锁</strong><font style="color:rgb(37, 41, 51);">（Gap Locks）：要么锁住索引记录中间的值，要么锁住第一个索引记录前面的值或者最后一个索引记录后面的值。</font></li><li><strong>临键锁</strong><font style="color:rgb(37, 41, 51);">（Next-Key Locks）：是索引记录上的记录锁和在索引记录之间的间隙锁的组合（间隙锁+记录锁）</font></li><li><strong>插入意向锁</strong><font style="color:rgb(37, 41, 51);">（Insert Intention Locks）：做insert操作时添加的对记录ID的锁，不同的插入意向锁不互斥，但是对其他的锁互斥</font></li></ul></li></ul><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723634316054-a5f11176-7b20-4403-b303-e18fc3b2fb93.webp" alt=""><font style="color:rgb(37, 41, 51);"><br></font></p><p><font style="color:rgb(37, 41, 51);"></font></p><p><strong>按锁功能分</strong></p><ul><li><strong>共享锁Shared Lock（S锁，也叫做读锁）</strong><ul><li>加了读锁的记录，允许其他事务再加读锁</li><li>加锁方式：select … lock in share mode</li></ul></li><li><strong>排它锁Exclusive Lock（X锁，也叫写锁）</strong><ul><li>加了写锁的记录，不允许其他事务再加读锁或者写锁</li><li>加锁方式：select … for update</li><li></li></ul></li></ul><h1>explain字段的说明</h1><h3 id="type">type</h3><p>这个字段是我们优化要重点关注的字段，这个字段直接反映我们SQL的性能是否高效。</p><p>这个字段值较多，这里我只重点关注我们开发中经常用到的几个字段:system,const,eq_ref,ref,range,index,all;<br>性能由好到差依次为：<strong>==system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all==</strong>(一定要牢记)</p><ul><li>system：表只有一行记录，这个是const的特例，一般不会出现，可以忽略</li><li>const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。</li><li>eq_ref：唯一性索引扫描，表中只有一条记录与之匹配。一般是两表关联，关联条件中的字段是主键或唯一索引。</li><li>ref：非唯一行索引扫描，返回匹配某个单独值的所有行</li><li>range：检索给定范围的行，一般条件查询中出现了&gt;、&lt;、in、between等查询</li><li>index：遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。all和index都是读全表，但index是从索引中检索的，而all是从硬盘中检索的。</li><li>all：遍历全表以找到匹配的行</li></ul><p>参考文章：</p><p>1、<a href="https://blog.csdn.net/shark_chili3007/article/details/108089396">https://blog.csdn.net/shark_chili3007/article/details/108089396</a></p><p>2、<a href="https://juejin.cn/post/7368375416929239092?searchId=202408141914405888882B1A217C964C98">https://juejin.cn/post/7368375416929239092?searchId=202408141914405888882B1A217C964C98</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库框架 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQl的MVCC</title>
      <link href="/2024/08/31/MySql%E7%9A%84MVCC/"/>
      <url>/2024/08/31/MySql%E7%9A%84MVCC/</url>
      
        <content type="html"><![CDATA[<p>写数据流程</p><p>// todo 待完善</p><h2 id="bin-Log">bin Log</h2><p>用于做主从复制、数据恢复</p><p>格式有：</p><p>row</p><p>statement</p><p>mixed</p><p>过程：</p><p>主节点写bin log</p><p>从节点监听到，拉取binlog，到本地的relaylog中</p><p>再异步去执行 relay log，使数据到一致状态</p><h2 id="Redo-Log">Redo Log</h2><p>用于保存事务的重做日志，用于事务、崩溃恢复</p><p>内部有两阶段提交的过程</p><p>P1：写redolog 预提交</p><p>然后 写bin log</p><p>P2：写redo log ，最终提交</p><h2 id="Undo-Log">Undo Log</h2><p>用于保存事务的回滚日志，和mvcc相关</p><p>日志版本链</p><h1>MVCC</h1><h2 id="隐藏字段">隐藏字段</h2><p>undo log 中 ，有隐藏字段：</p><ul><li>事务 id ：递增的</li><li>roll 指：即 undo log 记录的指针，串联起来，形成版本记录链</li></ul><h2 id="Read-View-视图">Read View 视图</h2><p>形成可见的版本快照</p><p>实现可重复读、读未提交的不同级别</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库框架 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构</title>
      <link href="/2024/08/31/MySQL%E6%9E%B6%E6%9E%84/"/>
      <url>/2024/08/31/MySQL%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>整体架构</h1><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723612130061-3a058ac1-fbb8-4db7-ab05-e2da11c4c9e9.webp" alt=""></p><h2 id="查询过程">查询过程</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723612225151-ad4719a1-56cb-4482-8453-92811c0637b7.webp" alt=""></p><h1>InnoDB 架构</h1><h2 id="整体架构">整体架构</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723612371210-41599cef-1348-4ea6-a361-0c90a3c8c87d.webp" alt=""></p><h2 id="磁盘结构">磁盘结构</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723612358651-cef080ae-2733-4326-924d-ac095b388199.webp" alt=""></p><h3 id="表空间">表空间</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/webp/308915/1723612403747-5885be98-64e7-40ff-b843-d9a2b1cc4b2e.webp" alt=""></p><h1>参考</h1><p>1、<a href="https://juejin.cn/post/7143614079532269598?searchId=20240814130817BFE1023A1534296FB990">https://juejin.cn/post/7143614079532269598?searchId=20240814130817BFE1023A1534296FB990</a></p><p>2、<a href="https://juejin.cn/post/7142891691526062094">https://juejin.cn/post/7142891691526062094</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库框架 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2024/08/31/Mysql%20%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/08/31/Mysql%20%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1>事务隔离级别</h1><h2 id="读未提交">读未提交</h2><h2 id="读提交">读提交</h2><h2 id="可重复读">可重复读</h2><p>用 mvcc 机制保证</p><h2 id="串行化">串行化</h2><h2 id="序列化">序列化</h2><p>跨库事务</p><p>事务不生效的场景</p><p>分布式事务</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库框架 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas原理-Watch命令的执行过程</title>
      <link href="/2024/08/31/Arthas%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%EF%BC%9AWatch%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/08/31/Arthas%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%EF%BC%9AWatch%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>前置流程</h1><p>1、arthas 客户端，通过 命令行工具，启动了 arthas 终端</p><p>入口 com.taobao.arthas.client.TelnetConsole#process(java.lang.String[], java.awt.event.ActionListener)</p><p>2、目标 JVM 通过 agentmain 的方式，将 arthas 的核心代码注入到 jvm 里</p><p>入口： com.taobao.arthas.agent334.AgentBootstrap#agentmain</p><h1>arthas-core agent 启动流程</h1><p>1、解析参数，获取 arthas-core 的 jar 路径</p><p>若传入的 jar 路径不存在，则尝试去当前运行AgentBootstrap 的 classloader 路径下，获取 arthas-core.jar</p><p>若还加载不成功，则报错，启动失败</p><p>2、创建一个新的 classloader，新开一个线程</p><p>3、在新的线程里面，使用 classloader，通过反射的方式，去执行</p><p>com.taobao.arthas.core.server.ArthasBootstrap#getInstance(java.lang.instrument.Instrumentation, java.lang.String)</p><p>方法，获取 arthas 的 bootstrap 实例</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1723467037510-cc5c0b8d-b352-4a99-9dec-e0c9cdc787b7.png" alt=""></p><p>4、 然后判断当前实例是否已经启动，若已经启动，则抛异常</p><h1>arthas-core 核心启动流程</h1><p>单例，实例化一个ArthasBootstrap 实例</p><p>构造函数中，执行以下逻辑：</p><p>0、初始化 fastjson：initFastjson()</p><p>1、初始化 Spy：initSpy()</p><p>使用 bootstrap Classloader，去加载 java.arthas.SpyAPI 类</p><p>若为加载到，则尝试从当前类的 codeSource 中的位置，去加载</p><p>若还加载失败，在抛异常</p><p>2、初始化 arthas 环境：initArthasEnvironment(args)</p><p>主要是根据参数，初始化一个ArthasEnvironment实例，略过，不细究</p><p>3、其他操作</p><ul><li>确保 arthas 的 output 目录存在</li><li>初始化日志系统：使用 logback</li></ul><p>4、增强 classloader：enhanceClassLoader()</p><p>通过配置，创建了一个com.alibaba.bytekit.asm.instrument.InstrumentTransformer 实例</p><p>给instrumentation 添加了类转换器</p><p>对类进行增强：</p><p>要么是 ClassLoader 这个类</p><p>要么是通过参数传入的类 set</p><p>PS：此处使用了 byteKit 类库工具，还需要进一步研究</p><p>5、初始化 bean：initBeans()</p><p>创建了resultViewResolver、historyManager</p><p>6、绑定服务：bind(Configure configure)</p><p>使用 cas 来确保只有一个进程能绑定成功</p><p>设置随机的 tcp 端口、http 端口</p><p>尝试获取被监听的 jvm 的应用名称（通过 <a href="http://spring.application.name">spring.application.name</a> 配置来）</p><p>6.1 根据上面的配置，创建TunnelClient 实例，并 start()启动</p><p>即，启动一个 webSocket 服务（基于 netty）</p><p>核心的 handler 是这个：TunnelClientSocketClientHandler（待分析）</p><p>6.2 根据上面的配置，再创建一个 Shell 服务</p><p>创建ShellServerImpl 实例：<font style="color:#DF2A3F;">shellServer</font></p><p>启动一个 netty 的服务实例：workerGroup</p><p>给termServers 注册HttpTelnetTermServer、HttpTermServer（依赖 workerGroup）</p><p>将内置的命令处置器们：BuiltinCommandPack，注册到 termServer 的resolvers List 里</p><p>异步启动 shellServer</p><p>实际启动的服务，应该是com.taobao.arthas.core.shell.term.impl.TelnetTermServer#listen 这个</p><p>依赖了 termd-core</p><p>作用应该是处理输入字符的，具体不太明白</p><p>启动 http 的 session 的 manager</p><p>启动一个 http 的 api 的 handler</p><p>调用 java.arthas.SpyAPI#init 初始化 SpyAPI</p><p>7、创建一个周期调度的只有一个线程的线程池：executorService，并将其线程设置为 守护线程</p><p>至此，目标 JVM 被增强了的内容有：</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1723478720118-ca9700b9-3a1b-4295-a881-7b559cdb1f25.jpeg" alt="画板"></p><h1>arthas-core 运行态结构</h1><h2 id="当接收到用户输入的-watch-命令时，系统的处置流程">当接收到用户输入的 watch 命令时，系统的处置流程</h2><p>1、ShellLineHandler 创建一个createJob，对应用户输入的 watch 命令</p><p>通过 com.taobao.arthas.core.shell.system.impl.JobControllerImpl#createJob，对用户输入的命令，进行解析，，解析出来 Command</p><p>流程入口，在 com.taobao.arthas.core.shell.system.impl.JobControllerImpl#createJob 中</p><p>包装为 com.taobao.arthas.core.shell.system.impl.ProcessImpl，该类的 run 里面，会去调用</p><p>com.taobao.arthas.core.server.ArthasBootstrap#execute，通过 SpyAPI 的方式，调用具体的增强方法</p><p>具体的命令，在目录com/taobao/arthas/core/command 下面</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1723480314113-79a00853-c1ef-484a-8261-02cad7d296fc.jpeg" alt="画板"></p><h2 id="增强命令的类图结构">增强命令的类图结构</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/jpeg/308915/1723479779763-49b5da3b-b069-404a-a693-27e63d5de83a.jpeg" alt="画板"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arthas </tag>
            
            <tag> jvm底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-CodeCache、CodeDump</title>
      <link href="/2024/08/31/CodeCache%E3%80%81CodeDump/"/>
      <url>/2024/08/31/CodeCache%E3%80%81CodeDump/</url>
      
        <content type="html"><![CDATA[<p>什么是CodeCache</p><p>JIT编译后的热点代码、JNI代码、JVM动态生成的代码 ，它们存放的地方，就是CodeCache</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1718797353135-ba6b1c51-6c2a-4efc-b1e6-c3fcf9cc62b8.png" alt=""></p><p>内部的数据结构：</p><p>方法区：保存JIT编译后的、jni、动态生成的代码</p><p><font style="color:rgb(64, 64, 64);">non-method区域，存放如编译器缓冲区和字节码解释器，这块区域是永远不会被回收的</font></p><h1>JIT</h1><p>热点代码优化</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1718797606233-8e619754-0ad6-4efc-b01e-d97ebb6e971d.png" alt=""></p><h2 id="分层编译">分层编译</h2><p>Client：（使用C1编译器）编译速度快，但是效果一般</p><p>Server：（使用C2编译器）编译速度慢，但效果好</p><p>分层编译：client、server相结合，应用刚启动的时候，用client；运行过程中，不断使用Server进行优化</p><h2 id="回边">回边</h2><p><font style="color:rgba(25, 26, 31, 0.9);">针对循环体代码，JVM同样会进行热点代码的探测，识别是否可能存在热点代码，在JVM中，字节码中遇到控制流向后跳转的指令称为</font><strong><font style="color:rgba(25, 26, 31, 0.9);">回边</font></strong><font style="color:rgba(25, 26, 31, 0.9);">（BackEdge），JVM在方法中的循环体中添加回边计数器，执行次数超过阈值就认为是向编译器提交编译请求，触发OSR（On-Stack Replacement）编译。</font></p><p>注意：</p><p><font style="color:rgba(25, 26, 31, 0.9);">1、一旦CodeCache达到了阈值，JVM将会切换到interpreted-only（解释执行）模式，字节码将不再会被编译成机器码。因此，应用程序将继续运行，但运行速度会降低一个数量级。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);">针对这种情况，可以通过参数-XX:+UseCodeCacheFlushing开启CodeCache自动清理机制，此时JVM会开始进行CodeCache区域的清理工作，卸载过期的旧code，以释放空间。</font></p><p><font style="color:rgba(25, 26, 31, 0.9);"></font></p><h1><font style="color:rgba(25, 26, 31, 0.9);">实践注意事项</font></h1><p>1、一般应用不必关注JIT</p><p>2、大流量高并发的应用，可能存在瞬时流量过高，导致大量热点代码需要优化，进而JIT编译压力增加，造成性能下降</p><p>建议上线后，预估流量，先小流量切流，在JIT预热后，在放入大流量</p><p><font style="color:rgba(25, 26, 31, 0.9);">3、</font><strong><font style="color:rgba(25, 26, 31, 0.9);">如果CodeCache区域被占满，编译器被停用，字节码将不再会被编译成机器码，应用程序将继续运行，但运行速度会降低一个数量级，严重影响应用服务的运行</font></strong></p><blockquote><p><font style="color:rgb(64, 64, 64);">针对这种情况，</font><strong><font style="color:rgb(254, 3, 0);">可以通过参数-XX:+UseCodeCacheFlushing开启CodeCache自动清理机制（JVM8默认开启）</font></strong><font style="color:rgb(64, 64, 64);">，此时JVM会开始进行CodeCache区域的清理工作，卸载过期的旧code，以释放空间。</font></p><p><font style="color:rgba(0, 0, 0, 0.8);">code cache full一旦被处理，将会打印”CodeCache is full”的日志，但是这条日志只会打印一次：</font></p><p><font style="color:rgb(64, 64, 64);">Java HotSpot™ 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.</font></p><p><font style="color:rgb(64, 64, 64);">Java HotSpot™ 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=</font></p><p><font style="color:rgb(64, 64, 64);">Code Cache [0xffffffff77400000, 0xffffffff7a390000, 0xffffffff7a400000) total_blobs=11659 nmethods=10690 adapters=882 free_code_cache=909Kb largest_free_block=502656</font></p><p><font style="color:rgba(0, 0, 0, 0.8);">具体什么时候会触发回收呢？这和CodeCacheMinimumFreeSpace有关</font></p><p><font style="color:rgba(0, 0, 0, 0.8);">CodeCacheMinimumFreeSpace表示CodeCache的可用大小不足这个值的时候，就会停止进行JIT编译，并进行code cache full的处理逻辑，该参数的使用方式如下：</font><font style="color:rgb(64, 64, 64);">-XX:CodeCacheMinimumFreeSpace=1M </font></p><p><font style="color:rgba(0, 0, 0, 0.8);">默认情况下，在Liunx环境，</font><strong><font style="color:rgb(254, 3, 0);">该值的大小为500K。</font></strong></p></blockquote><p><font style="color:rgb(64, 64, 64);">4、导致CodeCache失效的其他原因：JVM的redefine和retrasnsform</font></p><p><font style="color:rgb(64, 64, 64);">如集团内部的青龙插件进行流量收集的时候，会进行插桩（redefine）</font></p><h1>其他：redefine机制</h1><p><font style="color:rgba(0, 0, 0, 0.8);">redefine是jvm提供给开发人员用于动态修改方法内容的机制</font></p><p>arthas就是基于此机制实现的</p><p>即 Instrumentation 机制</p><h1>参考</h1><ul><li><a href="https://ata.atatech.org/articles/11000175618?layout=%2Fvelocity%2Flayout%2Fblank.vm">https://ata.atatech.org/articles/11000175618?layout=%2Fvelocity%2Flayout%2Fblank.vm</a></li><li><a href="https://ata.atatech.org/articles/11000236414?spm=ata.23639746.0.0.44f9c466DpWzZG">https://ata.atatech.org/articles/11000236414?spm=ata.23639746.0.0.44f9c466DpWzZG</a></li><li>【<font style="color:rgb(105, 105, 105);">JVM系列六(JVM-codecache内存区域介绍</font>】<a href="http://thinkhejie.github.io/2016/05/05/JVM%E7%B3%BB%E5%88%97_06/?spm=ata.21736010.0.0.d4807536xEiLkK">http://thinkhejie.github.io/2016/05/05/JVM%E7%B3%BB%E5%88%97_06/?spm=ata.21736010.0.0.d4807536xEiLkK</a></li><li><a href="https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/codecache.htm?spm=ata.21736010.0.0.d4807536xEiLkK">https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/codecache.htm?spm=ata.21736010.0.0.d4807536xEiLkK</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch</title>
      <link href="/2024/08/31/ElasticSearch/"/>
      <url>/2024/08/31/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h1>基本概念</h1><h2 id="基本组件">基本组件</h2><p>集群：由不同节点组成。整个 Elasticsearch 集群的核心就是对所有的分片执行分布存储，索引，负载，路由的工作。</p><p>节点：单个服务器，用于保存数据、搜索文档</p><p>索引：类似 数据库，可以定义多种类型的映射，映射到一个或多个主分片中，可以有 0 个、多个副本分片</p><p>文档：类似数据库中的一行数据，可以有不同的结构（字段）</p><h3 id="分片（Shard）-：">分片（Shard） ：</h3><p>分片的个数在索引创建时被定义，不能动态修改。</p><p>每个分配都是单独的 lucene 实例，多分片可以分散数据和负载，增加并行度和吞吐量</p><p>是集群数据的容器，Index（索引）被分为多个文档碎片存储在分片中，分片又被分配 到集群内的各个节点里。</p><p>当需要查询一个文档时，需要先找到其位于的分片。也就是说，分片是 Elasticsearch 在集群内分发数据的单位。</p><p>每个分片都是一个 Lucene 索引实例，您可以将其视作一个独立的搜索引擎，它能够对 Elasticsearch 集 群中的数据子集进行索引并处理相关查询。</p><p>主分片（Primary Shard）：</p><p>分片的类型，负责写入数据</p><p>默认为 1 个</p><p>副本分片（Replica Shard）：</p><p>是主分片的副本，提供搜索、返回文档的服务。支持横向扩展，增大数量有利于增加吞吐量</p><p>主分片出异常的情况下，会从副本分片中自动进行选举出新的主分片</p><p>默认为 0 个，但生产环境上，最少为一个</p><h2 id="路由（Route）">路由（Route）</h2><p>默认情况下， 在 es 中存放数据时会根据文档 id 平均存放到所遇到分片中。导致查数据的时候，需要查所有的分片才能得到结果。</p><p>默认情况的分片算法：</p><pre><code class="language-java">shard_num = hash(_routing) % num_primary_shards</code></pre><p>为了避免扫描全部分片，因此需要自定义路由规则，将文档放到指定的分片上去，查询的时候，只查指定的分片即可得到结果</p><h2 id="集群的节点类型：">集群的节点类型：</h2><ul><li>主节点（Master-eligible node） ：集群层面的管理，例如创建或删除索引、跟踪哪些节点是集群的一部分，以及决定将哪些分片分配给哪些节点。任何不是仅投票主节点的合格主节点都可以通过主选举过程被选为主节点。</li><li>专用备选主节点（Dedicated master-eligible node） ： Elasticsearch 集群中，设置了只能作为主节点的节点。设置专用主节点主要是为了保障集群增大时的稳定性，建议专用主节点个数至少为 3 个。</li><li>仅投票主节点（Voting-only master-eligible node）: 仅参与主节点选举投票，不会被选为主节点，硬件配置可以较低。</li><li>数据节点（data node） ：数据存储和数据处理比如 CRUD、搜索、聚合。</li><li>预处理节点（ingest node） ：执行由预处理管道组成的预处理任务。</li><li>仅协调节点（coordinating only node） ：路由分发请求、聚集搜索或聚合结果。</li><li>远程节点（Remote-eligible node） ：跨集群检索或跨集群复制。</li></ul><h2 id="Luence-的关键概念">Luence 的关键概念</h2><p><font style="color:rgb(0, 0, 0);background-color:rgb(251, 251, 251);">term：关键字</font></p><p><font style="color:rgb(0, 0, 0);background-color:rgb(251, 251, 251);">postings</font><font style="color:rgb(0, 0, 0);"> list:位置表</font></p><p><font style="color:rgb(0, 0, 0);background-color:rgb(251, 251, 251);">即包含所有关键字的文档id集合，被处理为整形id</font></p><p>luence 的写入流程</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722739476481-48e86bcb-9e0f-4893-a8fb-cebbb361b162.png" alt=""></p><h2 id="索引原理：">索引原理：</h2><h3 id="倒排索引：">倒排索引：</h3><p>字典树 Trie，树状结构，hash 树的变种</p><p>有限状态转移机</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722738290583-e1c9285f-eea6-4455-83b0-e0745bcbef03.png" alt=""></p><h3 id="索引压缩、优化">索引压缩、优化</h3><h4 id="分段存储">分段存储</h4><h4 id="延时写策略">延时写策略</h4><h4 id="段合并">段合并</h4><h1>关键流程</h1><h2 id="写入流程">写入流程</h2><p>如下图</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722741477676-1df5e7d9-9d7c-437d-aac0-e0ca6233d372.png" alt=""></p><h1>常见问题</h1><h2 id="如何保存数据一致">如何保存数据一致</h2><p>通过版本号使用乐观锁控制，确保新版本不会被旧版本覆盖</p><p>写操作：</p><p>三种分布式一致性级别</p><p>读操作：</p><p>可设置 replication= sync（默认同步），来使主分片和副本分片都返回结果，才返回给客户端</p><p>= async 是，可以设置查询 参数来确保数据为最新的</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1722053748745-1440d211-db3d-471a-bcff-a5f8c8ce9fb6.png" alt=""></p><h2 id="如何与-mysql-保持数据同步">如何与 mysql 保持数据同步</h2><p>全量、增量、增全量、binlog 同步</p><h1>本地安装</h1><pre><code class="language-shell">curl -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-8.14.3-darwin-x86_64.tar.gzcurl https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-8.14.3-darwin-x86_64.tar.gz.sha512 | shasum -a 512 -c - tar -xzf elasticsearch-8.14.3-darwin-x86_64.tar.gzcd elasticsearch-8.14.3/</code></pre><h1>参考：</h1><p>1、【Elasticsearch 如何做到快速检索 - 倒排索引的秘密】<a href="https://segmentfault.com/a/1190000037658997">https://segmentfault.com/a/1190000037658997</a></p><p>2、【<font style="color:rgb(85, 85, 85);">关于Lucene的词典FST深入剖析】</font><a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/">https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/</a></p><p>3、【<font style="color:rgb(34, 34, 38);">科普文：深入理解ElasticSearch体系结构】</font><a href="https://blog.csdn.net/Rookie_CEO/article/details/140088756">https://blog.csdn.net/Rookie_CEO/article/details/140088756</a></p><p>4、<a href="https://www.cnblogs.com/jajian/p/11223992.html">https://www.cnblogs.com/jajian/p/11223992.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diamond</title>
      <link href="/2024/08/31/Diamond/"/>
      <url>/2024/08/31/Diamond/</url>
      
        <content type="html"><![CDATA[<h1>数据更新原理：</h1><p>1、本地线程检查本地容灾目录里的文件是否有变动</p><p>2、起线程，轮询server里的数据是否有变动</p><p>3、 若有变动，则通知listener，进行回调</p><h1>参考：</h1><p><a href="https://ata.atatech.org/articles/11000027665?spm=ata.23639746.0.0.4e677ddaxNBnry">https://ata.atatech.org/articles/11000027665?spm=ata.23639746.0.0.4e677ddaxNBnry</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-CodeCache</title>
      <link href="/2024/08/31/JVM-CodeCache/"/>
      <url>/2024/08/31/JVM-CodeCache/</url>
      
        <content type="html"><![CDATA[<p>什么是CodeCache<br>JIT编译后的热点代码、JNI代码、JVM动态生成的代码 ，它们存放的地方，就是CodeCache</p><p>内部的数据结构：<br>方法区：保存JIT编译后的、jni、动态生成的代码<br>non-method区域，存放如编译器缓冲区和字节码解释器，这块区域是永远不会被回收的</p><p>JIT<br>热点代码优化</p><p>分层编译<br>Client：（使用C1编译器）编译速度快，但是效果一般<br>Server：（使用C2编译器）编译速度慢，但效果好<br>分层编译：client、server相结合，应用刚启动的时候，用client；运行过程中，不断使用Server进行优化<br>回边<br>针对循环体代码，JVM同样会进行热点代码的探测，识别是否可能存在热点代码，在JVM中，字节码中遇到控制流向后跳转的指令称为回边（BackEdge），JVM在方法中的循环体中添加回边计数器，执行次数超过阈值就认为是向编译器提交编译请求，触发OSR（On-Stack Replacement）编译。</p><p>注意：<br>1、一旦CodeCache达到了阈值，JVM将会切换到interpreted-only（解释执行）模式，字节码将不再会被编译成机器码。因此，应用程序将继续运行，但运行速度会降低一个数量级。<br>针对这种情况，可以通过参数-XX:+UseCodeCacheFlushing开启CodeCache自动清理机制，此时JVM会开始进行CodeCache区域的清理工作，卸载过期的旧code，以释放空间。</p><p>实践注意事项<br>1、一般应用不必关注JIT<br>2、大流量高并发的应用，可能存在瞬时流量过高，导致大量热点代码需要优化，进而JIT编译压力增加，造成性能下降<br>建议上线后，预估流量，先小流量切流，在JIT预热后，在放入大流量<br>3、如果CodeCache区域被占满，编译器被停用，字节码将不再会被编译成机器码，应用程序将继续运行，但运行速度会降低一个数量级，严重影响应用服务的运行<br>针对这种情况，可以通过参数-XX:+UseCodeCacheFlushing开启CodeCache自动清理机制（JVM8默认开启），此时JVM会开始进行CodeCache区域的清理工作，卸载过期的旧code，以释放空间。<br>code cache full一旦被处理，将会打印”CodeCache is full”的日志，但是这条日志只会打印一次：<br>Java HotSpot™ 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.<br>Java HotSpot™ 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=<br>Code Cache [0xffffffff77400000, 0xffffffff7a390000, 0xffffffff7a400000) total_blobs=11659 nmethods=10690 adapters=882 free_code_cache=909Kb largest_free_block=502656<br>具体什么时候会触发回收呢？这和CodeCacheMinimumFreeSpace有关<br>CodeCacheMinimumFreeSpace表示CodeCache的可用大小不足这个值的时候，就会停止进行JIT编译，并进行code cache full的处理逻辑，该参数的使用方式如下：-XX:CodeCacheMinimumFreeSpace=1M<br>默认情况下，在Liunx环境，该值的大小为500K。</p><p>4、导致CodeCache失效的其他原因：JVM的redefine和retrasnsform<br>如集团内部的青龙插件进行流量收集的时候，会进行插桩（redefine）</p><p>其他：redefine机制<br>redefine是jvm提供给开发人员用于动态修改方法内容的机制<br>arthas就是基于此机制实现的</p><p>即 Instrumentation 机制</p><p>参考<br>● <a href="https://ata.atatech.org/articles/11000175618?layout=%2Fvelocity%2Flayout%2Fblank.vm">https://ata.atatech.org/articles/11000175618?layout=%2Fvelocity%2Flayout%2Fblank.vm</a><br>● <a href="https://ata.atatech.org/articles/11000236414?spm=ata.23639746.0.0.44f9c466DpWzZG">https://ata.atatech.org/articles/11000236414?spm=ata.23639746.0.0.44f9c466DpWzZG</a><br>● 【JVM系列六(JVM-codecache内存区域介绍】<a href="http://thinkhejie.github.io/2016/05/05/JVM%E7%B3%BB%E5%88%97_06/?spm=ata.21736010.0.0.d4807536xEiLkK">http://thinkhejie.github.io/2016/05/05/JVM系列_06/?spm=ata.21736010.0.0.d4807536xEiLkK</a><br>● <a href="https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/codecache.htm?spm=ata.21736010.0.0.d4807536xEiLkK">https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/codecache.htm?spm=ata.21736010.0.0.d4807536xEiLkK</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的AOP：Java Agent技术</title>
      <link href="/2024/08/31/JVM%E7%9A%84AOP%EF%BC%9AJava%20Agent%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/08/31/JVM%E7%9A%84AOP%EF%BC%9AJava%20Agent%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1>Spring AOP 的局限性</h1><p>1、只能操作 bean 对象的方法</p><p>因为使用<font style="color:rgb(64, 64, 64);">BeanPostProcessor 需要是 spring 的 bean，才能被处理</font></p><p>2、无法操作静态方法</p><p><font style="color:rgb(64, 64, 64);">因为Spring AOP的两种实现方式：Cglib和JDK动态代理，分别是通过生成目标类的子类和实现目标接口的方式来创建动态代理的，而静态方法不能被子类重写，更谈不上接口实现。</font></p><p>3、方法只有被外部调用才生效，被内部自己调用（this.xxxxx()）的方式，无法生效切面</p><p>4、无法织入 private 方法（cglib）</p><h2 id="本质原因：">本质原因：</h2><p>Spring Aop 的 jvm 的运行时技术，class 已经生成，spring无法修改 class，只能 通过子类继承、接口扩展的方式生成一个新类，再替换原有的 bean。</p><h1>Agent 技术的原理</h1><h2 id="PreMain-方式">PreMain 方式</h2><p>jdk1.5 后就有了，给 JVM 提供的扩展点，用于对 class 进行修改，可以在启动时直接修改 class 内容。比较原始</p><p>使用本方法分三步：</p><p>1、实现方法</p><p>public static void premain(String args, Instrumentation instrumentation){�</p><p>}</p><p>2、打包，将实现的类信息打包到 META-INF/MANIFEST.MF 中，并设置Premain-Class 为 实现的类</p><p>3、运行，添加参数</p><p>-javaagent:/path/to/jar/myAgent.jar=自定义参数字符串</p><h2 id="Agent-方式">Agent 方式</h2><p>jdk1.6 之后才有的，用于在 jvm 启动之后执行类的转换方法</p><p>arthas 就是使用的这种方法</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arthas </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 表达式与原理</title>
      <link href="/2024/08/31/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2024/08/31/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>自制IDEA的反编译工具</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1718276360540-721839d7-725b-4d5e-b197-02f639ff4882.png" alt=""></p><pre><code class="language-shell">/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/javap-c -p $FileNameWithoutExtension$.class$OutputPath$/$FileDirRelativeToSourcepath$</code></pre><h1>使用场景</h1><h2 id="Function-函数式接口">Function 函数式接口</h2><p>只有一个方法的接口</p><h2 id="匿名内部类">匿名内部类</h2><p>依赖 java 的类型推断机制</p><p>如继承 Thread，复写 run 方法</p><p>如复写 Comparator</p><h1>原理</h1><p>使用@FunctionalInterface 可以帮助进行检查，但是不是必须的</p><h2 id="匿名内部类的方式">匿名内部类的方式</h2><p>生成$ 的内部方法</p><h2 id="Lambda-表达式">Lambda 表达式</h2><p>通过 invokedynamic 指令实现，不会产生新的类</p><p>会生成一个新的有$ 的内部方法</p><h1>应用：</h1><h2 id="stream-编程">stream 编程</h2><h1>参考</h1><p>1、<a href="https://ata.atatech.org/articles/12000171704?spm=ata.23639746.0.0.432686caHCjv3c#WdMvwNz5">https://ata.atatech.org/articles/12000171704?spm=ata.23639746.0.0.432686caHCjv3c#WdMvwNz5</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSearch相关</title>
      <link href="/2024/08/31/OpenSearch%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/08/31/OpenSearch%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1>分类</h1><h2 id="font-style-color-rgb-24-24-24-行业算法版-font"><font style="color:rgb(24, 24, 24);">行业算法版</font></h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714793095077-8129aacd-a313-44f5-9f63-a4d2b9fc1076.png" alt=""></p><h3 id="特点">特点</h3><h4 id="font-style-color-rgb-24-24-24-智能-font"><font style="color:rgb(24, 24, 24);">智能</font></h4><p><font style="color:rgb(24, 24, 24);">内置丰富的定制化算法模型，并结合不同行业搜索特点，推出行业召回、排序算法，保障更优搜索效果</font></p><h4 id="font-style-color-rgb-24-24-24-丰富的外围功能-font"><font style="color:rgb(24, 24, 24);">丰富的外围功能</font></h4><p><font style="color:rgb(24, 24, 24);">支持热搜、底纹、下拉提示、统计报表等一系列搜索外围功能，方便用户展示及分析。</font></p><p><font style="color:rgb(24, 24, 24);"></font></p><p><font style="color:rgb(24, 24, 24);"></font></p><h2 id="font-style-color-rgb-24-24-24-高性能检索版-font"><font style="color:rgb(24, 24, 24);">高性能检索版</font></h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714793183916-f90c93f6-6448-4738-b82b-71a88afa35e7.png" alt=""></p><h3 id="特点-2">特点</h3><h4 id="font-style-color-rgb-24-24-24-高吞吐-font"><font style="color:rgb(24, 24, 24);">高吞吐</font></h4><p><font style="color:rgb(24, 24, 24);">单表支持万级别的写入TPS，秒级更新。</font></p><h4 id="font-style-color-rgb-24-24-24-SQL查询-font"><font style="color:rgb(24, 24, 24);">SQL查询</font></h4><p><font style="color:rgb(24, 24, 24);">OpenSearch-高性能检索支持SQL查询语法，支持多表在线join，提供丰富的内置UDF函数定制机制，以满足不同用户的检索需求。在运维系统中我们开放了搜索测试页面，方便用户进行SQL测试。</font></p><p><font style="color:rgb(24, 24, 24);"></font></p><h2 id="font-style-color-rgb-24-24-24-向量检索版-font"><font style="color:rgb(24, 24, 24);">向量检索版</font></h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714793257620-43926df4-8de1-4df2-a87d-969cf9aebe43.png" alt=""></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714793285601-7b0d3f02-e8fb-4a71-ad88-b2ed0fac60b3.png" alt=""></p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714793290525-8cd1859b-dc6e-4e1e-a48d-edc9f686b946.png" alt=""></p><h3 id="特点-3">特点</h3><h4 id="font-style-color-rgb-24-24-24-稳定-font"><font style="color:rgb(24, 24, 24);">稳定</font></h4><p><font style="color:rgb(24, 24, 24);">向量检索版底层采用c++实现，经过十多年的发展，支撑了多个核心业务，非常稳定，非常适用于对稳定性要求较高的核心搜索场景。</font></p><h4 id="font-style-color-rgb-24-24-24-高效-font"><font style="color:rgb(24, 24, 24);">高效</font></h4><p><font style="color:rgb(24, 24, 24);">OpenSearch-向量检索版是一个分布式搜索引擎，可以高效的支持海量数据的检索，同时也支持数据的实时更新（秒级生效），非常适用于对查询耗时敏感、时效性要求高的搜索场景。</font></p><h4 id="font-style-color-rgb-24-24-24-低成本-font"><font style="color:rgb(24, 24, 24);">低成本</font></h4><p><font style="color:rgb(24, 24, 24);">OpenSearch-向量检索版支持多种索引压缩策略，同时支持多值索引加载测试，能够以较低的成本满足用户的查询需求。</font></p><p><font style="color:rgb(24, 24, 24);"></font></p><h2 id="font-style-color-rgb-24-24-24-召回引擎版-font"><strong><font style="color:rgb(24, 24, 24);">召回引擎版</font></strong></h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714793561231-f105bbcf-0d83-42c6-a72a-24fd2713878e.png" alt=""></p><h3 id="特点-4">特点</h3><p><strong><font style="color:rgb(24, 24, 24);">稳定</font></strong></p><p><font style="color:rgb(24, 24, 24);">召回引擎版底层采用c++实现，经过十多年的发展，支撑了多个核心业务，非常稳定，非常适用于对稳定性要求较高的核心搜索场景。</font></p><p><strong><font style="color:rgb(24, 24, 24);">高效</font></strong></p><p><font style="color:rgb(24, 24, 24);">OpenSearch-召回引擎版是一个分布式搜索引擎，可以高效的支持海量数据的检索，同时也支持数据的实时更新（秒级生效），非常适用于对查询耗时敏感、时效性要求高的搜索场景。</font></p><p><strong><font style="color:rgb(24, 24, 24);">低成本</font></strong></p><p><font style="color:rgb(24, 24, 24);">OpenSearch-召回引擎版支持多种索引压缩策略，同时支持多值索引加载测试，能够以较低的成本满足用户的查询需求。</font></p><p><strong><font style="color:rgb(24, 24, 24);">功能丰富</font></strong></p><p><font style="color:rgb(24, 24, 24);">OpenSearch-召回引擎版支持多种分析器类型、多种索引类型、强大的查询语法，能够很好的满足用户的检索需求。同时我们还提供插件机制，方便用户定制自己的业务处理逻辑。</font></p><p><strong><font style="color:rgb(24, 24, 24);">SQL查询</font></strong></p><p><font style="color:rgb(24, 24, 24);">OpenSearch-召回引擎版支持SQL查询语法，支持多表在线join，提供丰富的内置UDF函数和UDF函数定制机制，以满足不同用户的检索需求。在运维系统中我们即将集成SQL studio，方便用户进行SQL开发和测试。</font></p><p><font style="color:rgb(24, 24, 24);"></font></p><h2 id="font-style-color-rgb-24-24-24-LLM智能问答版-font"><font style="color:rgb(24, 24, 24);">LLM智能问答版</font></h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714793641674-5a63a164-61b7-43e7-bb22-8bcb3320347a.png" alt=""></p><h3 id="特点-5">特点</h3><h4 id="font-style-color-rgb-24-24-24-企业专属问答搜索-font"><font style="color:rgb(24, 24, 24);">企业专属问答搜索</font></h4><p><font style="color:rgb(24, 24, 24);">基于业务数据生成问答结果，更加安全、稳定、优质、可靠</font></p><h4 id="font-style-color-rgb-24-24-24-内置LLM模型-font"><font style="color:rgb(24, 24, 24);">内置LLM模型</font></h4><p><font style="color:rgb(24, 24, 24);">无需额外访问LLM模型，内置搜索、问答全链路服务</font></p><h4 id="font-style-color-rgb-24-24-24-丰富的NLP模型-font"><font style="color:rgb(24, 24, 24);">丰富的NLP模型</font></h4><p><font style="color:rgb(24, 24, 24);">内置文档切片、文本向量化、图像向量化等丰富的NLP、算法模型等，提供更优质的问答搜索效果保障</font></p><h4 id="font-style-color-rgb-24-24-24-多模态搜索-font"><font style="color:rgb(24, 24, 24);">多模态搜索</font></h4><p><font style="color:rgb(24, 24, 24);">支持文本、链接、图片等多模型问答结果展示，满足个性化问答搜索需求</font></p><h4 id="font-style-color-rgb-24-24-24-一站式快速接入-font"><font style="color:rgb(24, 24, 24);">一站式快速接入</font></h4><p><font style="color:rgb(24, 24, 24);">流程全打通，只需导入业务数据，即可一站式快速构建企业专属问答搜索服务</font></p><h1><font style="color:rgb(24, 24, 24);">参考文档：</font></h1><h2 id="内网文档">内网文档</h2><p><a href="https://aliyuque.antfin.com/arr480/fbefv0/op8v3ivkmfuzt55s">https://aliyuque.antfin.com/arr480/fbefv0/op8v3ivkmfuzt55s</a></p><h2 id="阿里云文档">阿里云文档</h2><p><a href="https://help.aliyun.com/zh/open-search/high-performance-searchedition/best-practices-1/?spm=a2c4g.11186623.0.0.14a742c6LdizPv">https://help.aliyun.com/zh/open-search/high-performance-searchedition/best-practices-1/?spm=a2c4g.11186623.0.0.14a742c6LdizPv</a></p><h2 id="慢查询优化">慢查询优化</h2><p><a href="https://aliyuque.antfin.com/search_vpc/opensearch/pfclca?">https://aliyuque.antfin.com/search_vpc/opensearch/pfclca?</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2024/08/31/RocketMQ/"/>
      <url>/2024/08/31/RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1>参考文章：</h1><p><font style="color:rgba(40, 37, 33, 0.9);background-color:rgb(255, 253, 225);">1、【仓储出库中枢】应用重启过程metaq rebalance引发消费停滞问题根治</font></p><p><a href="https://ata.alibaba-inc.com/articles/200262?spm=a1z2e.8101737.webpage.dtitle2.3eb54f9bt5QWqE">https://ata.alibaba-inc.com/articles/200262?spm=a1z2e.8101737.webpage.dtitle2.3eb54f9bt5QWqE</a></p><p>2、【RocketMQ实战 丁威、梁勇 著】</p><h1><font style="color:rgb(18, 18, 18);">分布式下如何提高性能（高并发）</font></h1><p><a href="https://zhuanlan.zhihu.com/p/402660843">https://zhuanlan.zhihu.com/p/402660843</a></p><h1>顺序消息，如何提高并发度</h1><h2 id="官方的顺序消息的原理">官方的顺序消息的原理</h2><p>1、发送端：顺序消息写入的Topic，by hash(key) -&gt;  写入到 指定的consumeQueue</p><p>2、消费端：定义的线程线程数 = 1，即可实现顺序消费</p><p>性能瓶颈：</p><p>1、消费重平衡，需要对broker加锁</p><p>2、找对应consumeQueue，也需要加锁</p><p>3、拉取任务之后，需要对本地的processQueue加上</p><p>加锁的地方比较多，性能较差</p><h2 id="优化方案（消费端优化）">优化方案（消费端优化）</h2><p>性能瓶颈分析：多个加锁，可以针对业务的需求，提升性能</p><p>如，对不同账号userId，就可以对不同的账号之间进行并发消费</p><p>1、重写消费者类</p><p>实现DefaultLitePullConsumer,实现自定义的pull模式</p><p>重写execute方法</p><p>2、加入多线程，生成n个消费线程，对key % n 路由 到对应的消费线程中，实现业务级的多线程</p><p>metaQ通过tag进行过滤，可以降本</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2023/png/308915/1702043886915-127680a4-295d-46cd-ab8b-080ec3a4b1c5.png" alt=""></p><h1>基本组件</h1><h2 id="Broker">Broker</h2><h2 id="Producer">Producer</h2><h2 id="Consumer">Consumer</h2><h2 id="NameServer">NameServer</h2><h1>高性能的优化点</h1><h2 id="异步复制">异步复制</h2><p>A:客户端写、先返回CompleteableFuture，</p><p>B:然后去落盘、复制副本，</p><p>C:然后再future.complete返回给客户端</p><p>B期间，还可以处理其他写情况，吞吐量较高</p><p>C阶段，符合同步复制的语义</p><h2 id="线程模型：netty-reactor模型">线程模型：netty+reactor模型</h2><h2 id="快速失败">快速失败</h2><h2 id="顺序写">顺序写</h2><p>commitlog</p><h2 id="定长文件、页缓存、内存映射">定长文件、页缓存、内存映射</h2><p>在linux中，MappedByteBuffer 约等于 页缓存</p><h2 id="内核级读写分离">内核级读写分离</h2><p>transientStorePoolEnable = true</p><p>写入page Cache 后，批量刷新到磁盘 =》</p><p>开启后：堆外内存 + 定时刷新到磁盘</p><h2 id="零拷贝：">零拷贝：</h2><p>在netty中，要读取文件，将文件基于内存映射，获取为一个ByteBuf，然后封装到FileRegion中，最后使用transferTo（底层为FileChannel.trasferTo），直接发送到网卡</p><h1>常用场景</h1><h2 id="顺序消费（局部顺序）">顺序消费（局部顺序）</h2><p>加了三把锁：</p><p>1、队列重平衡之后，添加拉取任务之后，回向broker加锁</p><p>2、线程池消费的时候，会对消息队列加锁，确保同一个消息队列不会被并行执行</p><p>3、还会对处理队列加锁，保障重新负载的时候，不会被重复消费，只有当处理队列中的消息全部处理后，在会释放锁</p><h2 id="延迟消息">延迟消息</h2><p>内部默认有18个级别的延迟队列</p><p>topic修改为"SCHEDULER_TOPIC_XXX"</p><p>每个级别都有定时任务捞取，满足条件后，重新放入broker</p><h2 id="广播消息原理">广播消息原理</h2><p>1、发送方正常发送</p><p>2、消费方订阅的时候，设置为广播订阅</p><pre><code class="language-plain">consumer.setMessageModel(MessageModel.BROADCASTING);</code></pre><p>官方文档上的说明</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1714372368543-efc9b61e-5416-4b07-86b4-bd15e4d69640.png" alt=""></p><h2 id="消费模式">消费模式</h2><h3 id="pull（lite-pull）">pull（lite pull）</h3><p>优点：</p><p>消息拉取以消费组为维度，且默认会创建20个拉取任务，消息拉取效率高，适合大数据的批处理任务</p><p>对实时性要求不高</p><p>缺点：</p><p>消费点位自动提交poll之后，就自动提交了，处理不好就容易丢失消息</p><p>短轮询：只轮询一次，默认等待时间1秒</p><p>长轮询：默认阻塞5秒，等待时间长，支持被唤醒，降低无效的拉取频率</p><h3 id="push">push</h3><p>默认16次重试</p><h2 id="限流机制">限流机制</h2><h4 id="消费端限流：">消费端限流：</h4><p>消费队列中积压的消息数：超过1000条</p><p>待处理的消息最大偏移量和最小偏移量，相差超过1000</p><p>消息队列中消息总大小超过100MB</p><p>任意满足，即限流</p><h3 id="服务端限流：">服务端限流：</h3><p>若消息存在内存中，则运行拉取的最大消息大小，默认256KB</p><p>若消息存在内存中，则运行拉取的最大消息条数，默认32</p><p>若消息存在磁盘中，则运行拉取的最大消息大小，默认64KB</p><p>若消息存在磁盘中，则运行拉取的最大消息条数，默认8</p><p>根据待拉取消息的物理偏移量和当前commitlog文件的最大偏移量之差超过内存的40%，就认为需要从磁盘中拉</p><h2 id="部署模式">部署模式</h2><h3 id="主从模式">主从模式</h3><p>多个master-slave组合</p><p>master 写，slave读</p><h3 id="多副本架构模式（Dledger）">多副本架构模式（Dledger）</h3><p>多个raft复制组，强一致性，每个组内只有leader可读写，会自动选举leader</p><p>基于raft协议，一个复制组，至少需要3台broker</p><p>Q：主从如何迁移到多副本架构</p><p>三步走：</p><p>1、多副本的raft节点加入原集群</p><p>2、逐步关闭原主从节点的写权限</p><p>3、过了日志存储时间后，下线原节点</p><h2 id="几种异常情况">几种异常情况</h2><h3 id="1、broker-的PageCache-压力大">1、broker 的PageCache 压力大</h3><p>若broker 追加page cache 锁超时1秒，就抛这个异常</p><p>解决办法：</p><p>开启transientStorePoolEnable = true（内核级读写分离）</p><p>即把消息先写入堆外内存，由于该内存启用了锁定机制，性能接近直接操作内存</p><p>然后后台线程会定时批量写入page Cache，将单条变为批量，提高写入性能</p><p>但：有数据丢失的可能</p><h3 id="2、发送线程池积压的拒绝策略">2、发送线程池积压的拒绝策略</h3><p>线程池中的有界队列长度默认为1000，超过后就会抛出错误</p><p>开启1中的配置后，还异常，则需要扩容了</p><h3 id="3、Broker-端快速失败">3、Broker 端快速失败</h3><p>broker 尚未page cache 忙，但是有一些发送请求在队列中等了超过200ms，也认为是繁忙，需要客户端自己捕获并处理</p><h3 id="4、订阅关系不一致，导致消息丢失">4、订阅关系不一致，导致消息丢失</h3><p>同一个消费者组，每个机器上订阅不同的tag，则会导致消息丢失（会被过滤而不消费）</p><p>若每个机器上订阅的tag相同，则不会丢失消息</p><h3 id="5、同一台机器上，clientId不唯一，导致不消费">5、同一台机器上，clientId不唯一，导致不消费</h3><p>和负载均衡算法有关</p><h3 id="6、NameServer-间路由信息是最终一致的，对发送、消费的影响">6、NameServer 间路由信息是最终一致的，对发送、消费的影响</h3><p>发送：有发送方自己保证，可能会造成发送不均衡，不会丢消息</p><p>消费：可能造成部分消费、部分不消费，不会丢消息，且易于监控、发现，易恢复</p><h3 id="7、NameServer间路由变更及时性问题">7、NameServer间路由变更及时性问题</h3><p>发送：若有broker挂掉，但是路由未更新，可能导致消息发送失败</p><p>解决办法：失败规避，客户端重试</p><p>消费：消费端重试，较好弥补</p><p>总结：NameServer 存在的问题，虽然可能致命，但是由生产者、消费者自己去保障、解决（发送重试、消费幂等），成本较低，且能保障可用性、稳定性。因此，职责分离，允许这些情况的发生</p><h2 id="文件恢复机制">文件恢复机制</h2><p>commitlog 文件异步构建 index 和 consumeQueue的过程中，可能有异常</p><p>基于checkpoint、abort文件</p><h3 id="若有abort文件，则代表异常退出">若有abort文件，则代表异常退出</h3><p>1、从commitlog倒数第三个文件，开始恢复</p><h2 id="消息轨迹">消息轨迹</h2><p>有默认的主题：RMQ_SYS_TRACE_TOPIC<br>还可以自定义</p><h1>企业级场景</h1><h2 id="消息流量隔离">消息流量隔离</h2><p>打标，修改topic</p><p>使用封装sdk的方式完成，如dpath的功能</p><h2 id="任意时间消息延迟方案">任意时间消息延迟方案</h2><p>一般的方案：</p><p>1、定时轮询存储介质（DB、redis等）</p><p>2、时间轮 和 本地存储索引</p><p>3、基于开源消息中间件的二次开发</p><p>每级别的延迟队列，都有消息的逻辑</p><p>搭建定时消息服务，负责消息轮转，传递下一等级的消息</p><p>同一延迟级别的消息，进行排序（可基于数据库、时间轮等）</p><h2 id="消息资源容灾迁移方案">消息资源容灾迁移方案</h2><h3 id="同城跨可用区部署-、">同城跨可用区部署 、</h3><p>master、slave，互相同城跨可用区交叉部署</p><h3 id="资源迁移">资源迁移</h3><p>主题迁移</p><p>消费组迁移</p><p>集群迁移</p><h2 id="跨集群复制方案">跨集群复制方案</h2><p>将一个集群的消息，复制到另一个集群，尝用于异地多活</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1716019391924-1cda2cf8-591d-4206-8a6d-f1d652dd4083.png" alt=""></p><h1>RocketMQ的编程技巧</h1><p>1、读写锁</p><p>用在存储路由元素的hashMap上，用ReentrantReadWriteLock</p><p>Q：为什么不用ConcurrentHashMap</p><p>A：ConcurrentHashMap 只针对自身安全，多个map之间，并不能保证并发安全</p><p>2、信号量的使用</p><p>异步发送的时候，用来控制并发度，避免限流</p><p>3、同步转异步</p><p>没使用Future</p><p>而是使用CountDownlatch</p><p>4、CompletableFuture</p><p><a href="https://yuque.antfin.com/attachments/lark/0/2024/drawio/308915/1716021754716-78b9cd1f-3fc1-490c-a272-1a1517116f93.drawio">RocketMQ原理.drawio</a></p>        <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;xml&quot;:&quot;<mxfile host=\&quot;drawio-plugin\&quot; modified=\&quot;2024-09-01T14:04:35.762Z\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36\&quot; etag=\&quot;hEpEZqKc94sVaShclzo_\&quot; version=\&quot;22.1.22\&quot; type=\&quot;embed\&quot;>\n  <diagram name=\&quot;第 1 页\&quot; id=\&quot;M9NXE2QjgKB9ijitMYhI\&quot;>\n    <mxGraphModel dx=\&quot;1771\&quot; dy=\&quot;1521\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;>\n      <root>\n        <mxCell id=\&quot;0\&quot; />\n        <mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; />\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-104\&quot; value=\&quot;consumer\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1350\&quot; y=\&quot;720\&quot; width=\&quot;387.06\&quot; height=\&quot;450\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-117\&quot; value=\&quot;消费者组A&amp;lt;br&amp;gt;&amp;lt;font style=&amp;quot;font-size: 8px;&amp;quot;&amp;gt;（不同消费者组之间线程隔离）&amp;lt;/font&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1427.06\&quot; y=\&quot;910\&quot; width=\&quot;182.94\&quot; height=\&quot;70\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-23\&quot; value=\&quot;Broker\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;350\&quot; y=\&quot;440\&quot; width=\&quot;500\&quot; height=\&quot;310\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; value=\&quot;Name Server 集群&amp;lt;br&amp;gt;最终一致性\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;360\&quot; y=\&quot;60\&quot; width=\&quot;600\&quot; height=\&quot;160\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-20\&quot; value=\&quot;Consumer Group\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1050\&quot; y=\&quot;200\&quot; width=\&quot;240\&quot; height=\&quot;580\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-24\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.75;entryDx=0;entryDy=0;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-1\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-46\&quot; value=\&quot;长连接\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-24\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.5076\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-28\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-1\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-11\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-50\&quot; value=\&quot;事务消息、定时消息\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-28\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.3379\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-1\&quot; value=\&quot;producer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-50\&quot; y=\&quot;120\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-27\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;shape=link;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-2\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-15\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-31\&quot; value=\&quot;彼此独立&amp;lt;br style=&amp;quot;border-color: var(--border-color);&amp;quot;&amp;gt;无通信&amp;lt;br style=&amp;quot;border-color: var(--border-color);&amp;quot;&amp;gt;无状态\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-27\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.0133\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-2\&quot; value=\&quot;NameServer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;400\&quot; y=\&quot;120\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-3\&quot; value=\&quot;consumer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1110\&quot; y=\&quot;640\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-52\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-4\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-8\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-54\&quot; value=\&quot;同步消息副本\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-52\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.227\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-53\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-4\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-9\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-55\&quot; value=\&quot;同步消息副本\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-53\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.2823\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-4\&quot; value=\&quot;Broker&amp;lt;br&amp;gt;Master\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;400\&quot; y=\&quot;470\&quot; width=\&quot;90\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-5\&quot; value=\&quot;Broker\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;370\&quot; y=\&quot;650\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-6\&quot; value=\&quot;Broker\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;380\&quot; y=\&quot;660\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-59\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;curved=1;startArrow=classic;startFill=1;endArrow=none;endFill=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-8\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-21\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;410\&quot; y=\&quot;640\&quot; />\n              <mxPoint x=\&quot;1010\&quot; y=\&quot;640\&quot; />\n              <mxPoint x=\&quot;1010\&quot; y=\&quot;420\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-61\&quot; value=\&quot;从节点消费 pull 拉&amp;lt;br&amp;gt;tag 过滤\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-59\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.4983\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-8\&quot; value=\&quot;Broker&amp;lt;br&amp;gt;slave\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;370\&quot; y=\&quot;575\&quot; width=\&quot;80\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-58\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;curved=1;startArrow=classic;startFill=1;endArrow=none;endFill=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-9\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-19\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;990\&quot; y=\&quot;620\&quot; />\n              <mxPoint x=\&quot;990\&quot; y=\&quot;300\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-60\&quot; value=\&quot;从节点消费 pull拉&amp;lt;br&amp;gt;tag 过滤\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-58\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.8416\&quot; y=\&quot;3\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;136\&quot; y=\&quot;-3\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-9\&quot; value=\&quot;Broker&amp;lt;br&amp;gt;slave\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;500\&quot; y=\&quot;570\&quot; width=\&quot;76\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-10\&quot; value=\&quot;Broker\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;390\&quot; y=\&quot;670\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-11\&quot; value=\&quot;Broker\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;600\&quot; y=\&quot;500\&quot; width=\&quot;110\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-12\&quot; value=\&quot;Broker\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;610\&quot; y=\&quot;510\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-13\&quot; value=\&quot;Broker\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;620\&quot; y=\&quot;520\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-28\&quot; value=\&quot;彼此独立&amp;lt;br style=&amp;quot;border-color: var(--border-color);&amp;quot;&amp;gt;无通信&amp;lt;br&amp;gt;无状态\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;shape=link;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-15\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-16\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-0.0045\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-15\&quot; value=\&quot;NameServer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;595\&quot; y=\&quot;120\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-16\&quot; value=\&quot;NameServer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;800\&quot; y=\&quot;120\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-25\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.028;entryY=1.01;entryDx=0;entryDy=0;entryPerimeter=0;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-17\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-48\&quot; value=\&quot;长连接\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-25\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.6218\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-29\&quot; value=\&quot;普通消息&amp;lt;br&amp;gt;发送重试\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-17\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-4\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-0.6804\&quot; y=\&quot;2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-95\&quot; value=\&quot;&amp;lt;div style=&amp;quot;text-align: left;&amp;quot;&amp;gt;延迟故障规避&amp;lt;/div&amp;gt;&amp;lt;font style=&amp;quot;font-size: 5px;&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;text-align: left;&amp;quot;&amp;gt;有两个数组，可以配置规避的延时&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;text-align: left;&amp;quot;&amp;gt;1、false：不开启（默认），即乐观规避，重试的时候，才会规规避发生失败的broker&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;text-align: left;&amp;quot;&amp;gt;2、true：开启，即悲观规避，发现有broker失败，后续所有发送请求都尝试其他broker&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;text-align: left;&amp;quot;&amp;gt;一般不用此功能&amp;lt;/div&amp;gt;&amp;lt;/font&amp;gt;\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-29\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.4363\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;42\&quot; y=\&quot;25\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-17\&quot; value=\&quot;producer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-70\&quot; y=\&quot;310\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-26\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.377;entryY=1.013;entryDx=0;entryDy=0;entryPerimeter=0;dashed=1;dashPattern=8 8;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-18\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-49\&quot; value=\&quot;长连接\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-26\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.6039\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-18\&quot; value=\&quot;producer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-80\&quot; y=\&quot;555\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-19\&quot; value=\&quot;consumer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1110\&quot; y=\&quot;260\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-21\&quot; value=\&quot;consumer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1110\&quot; y=\&quot;380\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-22\&quot; value=\&quot;consumer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1110\&quot; y=\&quot;510\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-30\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.224;entryY=0.037;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-18\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-5\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-51\&quot; value=\&quot;先选队列、再选broker，最后再发送\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-30\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.3399\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; value=\&quot;Broker\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;container=0;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;500\&quot; y=\&quot;820\&quot; width=\&quot;622.94\&quot; height=\&quot;450\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-32\&quot; value=\&quot;consumerQueue\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;25\&quot; y=\&quot;42.857142857142854\&quot; width=\&quot;360\&quot; height=\&quot;32.14285714285714\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-33\&quot; value=\&quot;consumerQueue\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;25\&quot; y=\&quot;96.42857142857143\&quot; width=\&quot;360\&quot; height=\&quot;32.14285714285714\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-34\&quot; value=\&quot;consumerQueue\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;25\&quot; y=\&quot;150\&quot; width=\&quot;360\&quot; height=\&quot;42.857142857142854\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-65\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-91\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-62\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-56\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;page Cache&amp;lt;br&amp;gt;commitlog的内存锁定&amp;lt;/font&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;80\&quot; y=\&quot;310\&quot; width=\&quot;102.5\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-62\&quot; value=\&quot;网卡\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;430\&quot; y=\&quot;296.6\&quot; width=\&quot;35\&quot; height=\&quot;32.14\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-76\&quot; value=\&quot;MMAP\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;10\&quot; y=\&quot;328.74\&quot; width=\&quot;60\&quot; height=\&quot;21.26\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-39\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-81\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-38\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-81\&quot; value=\&quot;操作系统刷盘&amp;lt;br&amp;gt;同步、异步\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;25\&quot; y=\&quot;390\&quot; width=\&quot;230\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-91\&quot; value=\&quot;page Cache\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;315\&quot; y=\&quot;295.34000000000003\&quot; width=\&quot;70\&quot; height=\&quot;34.65\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-1\&quot; value=\&quot;本地消费进度缓存\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;353.97\&quot; y=\&quot;360\&quot; width=\&quot;250\&quot; height=\&quot;70\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-2\&quot; value=\&quot;&amp;amp;lt;queueId,AtomicLong&amp;amp;gt; offsetTable\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;365\&quot; y=\&quot;390\&quot; width=\&quot;227.94\&quot; height=\&quot;15\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-50\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-34\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-48\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;250\&quot; y=\&quot;300\&quot; />\n              <mxPoint x=\&quot;250\&quot; y=\&quot;300\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-53\&quot; value=\&quot;单条写入\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-50\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.199\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-34\&quot; value=\&quot;SendMessageProcessor\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;30\&quot; y=\&quot;260\&quot; width=\&quot;260\&quot; height=\&quot;15.91\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-35\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-34\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-56\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-54\&quot; value=\&quot;组提交\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-35\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.0814\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-38\&quot; value=\&quot;&amp;lt;p style=&amp;quot;line-height: 150%; font-size: 5px;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 5px;&amp;quot;&amp;gt;异步复制到slave&amp;lt;br&amp;gt;复制完毕后，才返回给客户端成功&amp;lt;br&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;/p&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;190\&quot; y=\&quot;430\&quot; width=\&quot;80\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-47\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.437;entryY=-0.034;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-56\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-81\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-51\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-48\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-56\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;250\&quot; y=\&quot;349\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-52\&quot; value=\&quot;定时刷新\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-51\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.4533\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-48\&quot; value=\&quot;堆外内存\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-31\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;210\&quot; y=\&quot;307.48\&quot; width=\&quot;80\&quot; height=\&quot;21.26\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-35\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-32\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-20\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-36\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-33\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-20\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1190\&quot; y=\&quot;960\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-37\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.693;entryY=1.002;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-34\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-20\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-38\&quot; value=\&quot;消费重平衡\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1130\&quot; y=\&quot;810\&quot; width=\&quot;120\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-39\&quot; value=\&quot;长连接\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.959;entryY=1.008;entryDx=0;entryDy=0;entryPerimeter=0;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-19\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-40\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.932;entryY=1.009;entryDx=0;entryDy=0;entryPerimeter=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-21\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;1126\&quot; y=\&quot;292\&quot; as=\&quot;sourcePoint\&quot; />\n            <mxPoint x=\&quot;945\&quot; y=\&quot;231\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-43\&quot; value=\&quot;长连接\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-40\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.4081\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-41\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.898;entryY=0.998;entryDx=0;entryDy=0;entryPerimeter=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-22\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;1136\&quot; y=\&quot;302\&quot; as=\&quot;sourcePoint\&quot; />\n            <mxPoint x=\&quot;955\&quot; y=\&quot;241\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-44\&quot; value=\&quot;长连接\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-41\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.4779\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-42\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.87;entryY=1.007;entryDx=0;entryDy=0;entryPerimeter=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;dashed=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-3\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;1146\&quot; y=\&quot;312\&quot; as=\&quot;sourcePoint\&quot; />\n            <mxPoint x=\&quot;965\&quot; y=\&quot;251\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-45\&quot; value=\&quot;长连接\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-42\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.5677\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-64\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=1;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-57\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-91\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;790\&quot; y=\&quot;1244\&quot; />\n              <mxPoint x=\&quot;840\&quot; y=\&quot;1244\&quot; />\n              <mxPoint x=\&quot;840\&quot; y=\&quot;1150\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-57\&quot; value=\&quot;Disk\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;510\&quot; y=\&quot;1330\&quot; width=\&quot;390\&quot; height=\&quot;320\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-66\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.926;entryY=1.007;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-62\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-20\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;1240\&quot; y=\&quot;860\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-67\&quot; value=\&quot;sendFile 零拷贝\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-66\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.7227\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-77\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0.004;entryY=0.417;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-76\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;340\&quot; y=\&quot;1150\&quot; as=\&quot;sourcePoint\&quot; />\n            <mxPoint x=\&quot;760\&quot; y=\&quot;1060\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-78\&quot; value=\&quot;写入消息文件\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-77\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.0531\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-79\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.087;entryY=0.039;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-76\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-57\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-55\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;curved=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-83\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-85\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;170\&quot; y=\&quot;1390\&quot; />\n              <mxPoint x=\&quot;170\&quot; y=\&quot;1510\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-60\&quot; value=\&quot;异步构建\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-55\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.6456\&quot; y=\&quot;4\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-61\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;curved=1;exitX=0;exitY=0.5;exitDx=0;exitDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-83\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-84\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;250\&quot; y=\&quot;1390\&quot; />\n              <mxPoint x=\&quot;250\&quot; y=\&quot;1450\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;-WFzfWah-8NZCb1TUVI7-2\&quot; style=\&quot;edgeStyle=entityRelationEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-83\&quot; target=\&quot;-WFzfWah-8NZCb1TUVI7-1\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-83\&quot; value=\&quot;store/commitlog/00000001231.log&amp;lt;br&amp;gt;所有主题的消息，都混在一起\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;520\&quot; y=\&quot;1370\&quot; width=\&quot;200\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-84\&quot; value=\&quot;store/topic/index.log&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;单个文件定长&amp;lt;br&amp;gt;用于根据时间戳范围查找事件\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;520\&quot; y=\&quot;1430\&quot; width=\&quot;270\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-85\&quot; value=\&quot;store/consumequeue/{topic}/{queueId}/xxxxxx.log&amp;lt;br&amp;gt;单个文件300000个条目&amp;lt;br&amp;gt;每个下标，是逻辑偏移量，queueOffset\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;520\&quot; y=\&quot;1480\&quot; width=\&quot;340\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-86\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.47;entryY=1.023;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-23\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-27\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-87\&quot; value=\&quot;定时发生心跳&amp;lt;br&amp;gt;30秒&amp;lt;br&amp;gt;（包含全部信息）\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-86\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.1005\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-88\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;edgeStyle=orthogonalEdgeStyle;\&quot; parent=\&quot;1\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-34\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;350\&quot; y=\&quot;1060\&quot; as=\&quot;sourcePoint\&quot; />\n            <mxPoint x=\&quot;535\&quot; y=\&quot;1157\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-89\&quot; value=\&quot;写入消息文件\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-88\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.0531\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-93\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;edgeStyle=orthogonalEdgeStyle;\&quot; parent=\&quot;1\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-91\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;1080\&quot; y=\&quot;1100\&quot; as=\&quot;sourcePoint\&quot; />\n            <mxPoint x=\&quot;690\&quot; y=\&quot;1140\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-94\&quot; value=\&quot;读取消息\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-93\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.0531\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-97\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-96\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-6\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-98\&quot; value=\&quot;定时消息\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-97\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.3368\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-96\&quot; value=\&quot;producer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-90\&quot; y=\&quot;670\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-100\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-99\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-10\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-101\&quot; value=\&quot;顺序消息\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-100\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.6282\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;-5\&quot; y=\&quot;-6\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-102\&quot; value=\&quot;局部顺序&amp;lt;br&amp;gt;手动选择队列&amp;lt;br&amp;gt;MessageQueueSelector&amp;lt;br&amp;gt;此时不会自动重试\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-100\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.2798\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;30\&quot; y=\&quot;10\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-103\&quot; value=\&quot;全局消息&amp;lt;br&amp;gt;只设一个queue\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-100\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.2108\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;19\&quot; y=\&quot;-5\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-99\&quot; value=\&quot;producer\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-90\&quot; y=\&quot;790\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-107\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=1;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-105\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-10\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;390\&quot; y=\&quot;780.0000000000002\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-108\&quot; value=\&quot;&amp;lt;p style=&amp;quot;line-height: 70%;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 7px;&amp;quot;&amp;gt;定时去捞数据&amp;lt;br&amp;gt;有位点，则从位点开始拉&amp;lt;br&amp;gt;没有位点，则根据位点重置策略开始拉&amp;lt;/font&amp;gt;&amp;lt;/p&amp;gt;\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-107\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.8339\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-25\&quot; value=\&quot;顺序消费，会加锁，去锁队列\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-107\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.9251\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-18\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-105\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-17\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1385\&quot; y=\&quot;820\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-105\&quot; value=\&quot;PullMessageService\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1427.06\&quot; y=\&quot;750\&quot; width=\&quot;190\&quot; height=\&quot;90\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-106\&quot; value=\&quot;pullRequest队列\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1452.06\&quot; y=\&quot;780\&quot; width=\&quot;117.94\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-111\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-109\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-110\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-109\&quot; value=\&quot;RebalanceService&amp;lt;br&amp;gt;每20秒重新负载一次&amp;lt;br&amp;gt;by 消费者组\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1427.0600000000002\&quot; y=\&quot;850\&quot; width=\&quot;170\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-110\&quot; value=\&quot;PullRequest变动\&quot; style=\&quot;whiteSpace=wrap;html=1;verticalAlign=top;rounded=0;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1647.0600000000002\&quot; y=\&quot;857.5\&quot; width=\&quot;70\&quot; height=\&quot;35\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-112\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1.003;entryY=0.831;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-110\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-105\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1667.0600000000002\&quot; y=\&quot;885\&quot; />\n              <mxPoint x=\&quot;1687.0600000000002\&quot; y=\&quot;885\&quot; />\n              <mxPoint x=\&quot;1687.0600000000002\&quot; y=\&quot;827\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-114\&quot; value=\&quot;新增、删除\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;pjnpSmMfOQ8Y0L6ePmK4-112\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.2105\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-115\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;消费线程池&amp;lt;/font&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1466.03\&quot; y=\&quot;950\&quot; width=\&quot;103.97\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-118\&quot; value=\&quot;消费者组B\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1427.06\&quot; y=\&quot;990\&quot; width=\&quot;162.94\&quot; height=\&quot;70\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-6\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-121\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-1\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1320\&quot; y=\&quot;1085\&quot; />\n              <mxPoint x=\&quot;1320\&quot; y=\&quot;1215\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-7\&quot; value=\&quot;定时提交进度&amp;lt;br&amp;gt;每5秒提交所有记录\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-6\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.1536\&quot; y=\&quot;3\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-15\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-121\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-14\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-121\&quot; value=\&quot;本地消费进度缓存\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1437.06\&quot; y=\&quot;1080\&quot; width=\&quot;272.94\&quot; height=\&quot;70\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;pjnpSmMfOQ8Y0L6ePmK4-122\&quot; value=\&quot;&amp;amp;lt;queueId,AtomicLong&amp;amp;gt; offsetTable\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1452.06\&quot; y=\&quot;1107.5\&quot; width=\&quot;227.94\&quot; height=\&quot;15\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-3\&quot; value=\&quot;集群模式下采用&amp;lt;br&amp;gt;consumerOffset.json\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;751.47\&quot; y=\&quot;1340\&quot; width=\&quot;120\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-4\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-1\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-3\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;990\&quot; y=\&quot;1355\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-5\&quot; value=\&quot;定时持久化&amp;lt;br&amp;gt;每5秒\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-4\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;-0.3986\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-8\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.797;entryY=0.004;entryDx=0;entryDy=0;entryPerimeter=0;edgeStyle=orthogonalEdgeStyle;fontSize=7;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-115\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-121\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1660\&quot; y=\&quot;960\&quot; />\n              <mxPoint x=\&quot;1660\&quot; y=\&quot;1020\&quot; />\n              <mxPoint x=\&quot;1655\&quot; y=\&quot;1020\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-9\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 9px;&amp;quot;&amp;gt;提交消费进度&amp;lt;br&amp;gt;（offset最小的，避免漏消费）&amp;lt;/font&amp;gt;\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-8\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.156\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-10\&quot; value=\&quot;&amp;lt;font color=&amp;quot;#ff3333&amp;quot; style=&amp;quot;font-size: 9px;&amp;quot;&amp;gt;重复消费问题&amp;lt;/font&amp;gt;\&quot; style=\&quot;ellipse;shape=cloud;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1647.06\&quot; y=\&quot;1030\&quot; width=\&quot;80\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-11\&quot; value=\&quot;pull、push\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1456.03\&quot; y=\&quot;810\&quot; width=\&quot;110\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-13\&quot; value=\&quot;负载均衡算法\&quot; style=\&quot;ellipse;shape=cloud;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1737.06\&quot; y=\&quot;750\&quot; width=\&quot;112.94\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-14\&quot; value=\&quot;广播模式下采用&amp;lt;br&amp;gt;本地的user_home/.rockermq_offsets文件\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=middle;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1437.06\&quot; y=\&quot;1230\&quot; width=\&quot;272.94\&quot; height=\&quot;70\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-16\&quot; value=\&quot;限流的参数、机制\&quot; style=\&quot;ellipse;shape=cloud;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1747.06\&quot; y=\&quot;820\&quot; width=\&quot;132.94\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-23\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-17\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-21\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1380\&quot; y=\&quot;1025\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-17\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 7px;&amp;quot;&amp;gt;本地消费队列&amp;lt;br&amp;gt;ProcessQueue&amp;lt;br&amp;gt;TreeMap&amp;lt;/font&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1360\&quot; y=\&quot;865\&quot; width=\&quot;50\&quot; height=\&quot;85\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-19\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.001;entryY=0.547;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-17\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-115\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1390\&quot; y=\&quot;970\&quot; />\n              <mxPoint x=\&quot;1420\&quot; y=\&quot;970\&quot; />\n              <mxPoint x=\&quot;1420\&quot; y=\&quot;960\&quot; />\n              <mxPoint x=\&quot;1456\&quot; y=\&quot;960\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-20\&quot; value=\&quot;DefaultLitePullConsumer\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1790\&quot; y=\&quot;910\&quot; width=\&quot;150\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-22\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.75;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-21\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-121\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;1642\&quot; y=\&quot;1025\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-21\&quot; value=\&quot;消费线程池\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1464.56\&quot; y=\&quot;1012.5\&quot; width=\&quot;95.44\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-26\&quot; value=\&quot;并发消费模式下，可能同时被消费问题\&quot; style=\&quot;ellipse;shape=cloud;whiteSpace=wrap;html=1;fontColor=#FF0000;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;350\&quot; y=\&quot;775\&quot; width=\&quot;130\&quot; height=\&quot;65\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-33\&quot; value=\&quot;多个nameServer的路由状态不一致，引起的问题\&quot; style=\&quot;ellipse;shape=cloud;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;380\&quot; y=\&quot;-40\&quot; width=\&quot;184\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-36\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;pjnpSmMfOQ8Y0L6ePmK4-81\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-83\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;-WFzfWah-8NZCb1TUVI7-3\&quot; value=\&quot;顺序写，&amp;lt;div&amp;gt;高吞吐量&amp;lt;/div&amp;gt;\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; parent=\&quot;ygqqnxASPyGEW-wWTjM5-36\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;>\n          <mxGeometry x=\&quot;0.384\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint y=\&quot;-14\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-40\&quot; value=\&quot;每个条目的结构：（20B）&amp;lt;br&amp;gt;commitlog offset:8B(消息的物理偏移量)&amp;lt;br&amp;gt;size：4B&amp;lt;br&amp;gt;&amp;lt;div style=&amp;quot;&amp;quot;&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;tag hashcode：8B&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;align=left;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;871.47\&quot; y=\&quot;1600\&quot; width=\&quot;228.53\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-42\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.965;entryY=0.982;entryDx=0;entryDy=0;entryPerimeter=0;curved=1;endArrow=openAsync;endFill=0;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-40\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-85\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-44\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0.5;entryDx=0;entryDy=0;curved=1;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-43\&quot; target=\&quot;pjnpSmMfOQ8Y0L6ePmK4-84\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;970\&quot; y=\&quot;1440\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-43\&quot; value=\&quot;整体的结构：&amp;lt;br&amp;gt;IndexHeader：40B(开始、结束时间戳，开始、结束物理偏移量，hash槽计数、索引计数)&amp;lt;br&amp;gt;Hash槽：5 000 000 * 4B&amp;lt;br&amp;gt;Index item:20 000 000 * 20B\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;align=left;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;910\&quot; y=\&quot;1480\&quot; width=\&quot;540\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-45\&quot; value=\&quot;&amp;lt;span style=&amp;quot;color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 251, 251); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;&amp;quot;&amp;gt;索引条目的结构：&amp;lt;br&amp;gt;hashCode：4B&amp;lt;br&amp;gt;物理偏移量：8B&amp;lt;br&amp;gt;时间差：4B（该消息与第一条消息的时间戳差值，应大于等于0）&amp;lt;br&amp;gt;上一个索引下标：4B（用于哈希槽冲突的解决）&amp;lt;br&amp;gt;&amp;lt;/span&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;align=left;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1170\&quot; y=\&quot;1560\&quot; width=\&quot;380\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-58\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-57\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-59\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;160\&quot; y=\&quot;1500\&quot; as=\&quot;targetPoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-57\&quot; value=\&quot;checkpoint\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;540\&quot; y=\&quot;1560\&quot; width=\&quot;90\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-59\&quot; value=\&quot;异步构建索引、消费队列&amp;lt;br style=&amp;quot;border-color: var(--border-color); font-size: 11px;&amp;quot;&amp;gt;&amp;lt;span style=&amp;quot;font-size: 11px; background-color: rgb(255, 255, 255);&amp;quot;&amp;gt;文件恢复机制&amp;lt;/span&amp;gt;\&quot; style=\&quot;ellipse;shape=cloud;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;120\&quot; y=\&quot;1410\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-62\&quot; value=\&quot;abort\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;540\&quot; y=\&quot;1600\&quot; width=\&quot;90\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;ygqqnxASPyGEW-wWTjM5-63\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.357;entryY=0.89;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;ygqqnxASPyGEW-wWTjM5-62\&quot; target=\&quot;ygqqnxASPyGEW-wWTjM5-59\&quot; edge=\&quot;1\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;-WFzfWah-8NZCb1TUVI7-1\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;每行的记录格式：&amp;lt;/font&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;4B:消息长度（消息头 + 消息体）&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;4B：魔数&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;4B：消息CRC&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;4B：队列ID&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;8B：物理偏移量&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;4B：系统标识&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;4B：消息产生的时间戳&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;4B：消息体长度&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;1B：主题长度&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;变长：主题名称&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;变长：消息体时机内容&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;2B：消息属性长度&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;white-space: pre;&amp;quot;&amp;gt;&amp;#x9;&amp;lt;/span&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;span style=&amp;quot;background-color: initial;&amp;quot;&amp;gt;变长：消息属性&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;align=left;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;1010\&quot; y=\&quot;1330\&quot; width=\&quot;540\&quot; height=\&quot;110\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n      </root>\n    </mxGraphModel>\n  </diagram>\n</mxfile>\n&quot;}"></div>        <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收</title>
      <link href="/2024/08/31/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2024/08/31/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1>GC</h1><h2 id="垃圾回收算法">垃圾回收算法</h2><ul><li>标记-清理</li></ul><p>标记、清理；会产生不连续碎片</p><ul><li>标记-复制</li></ul><p>将内存分为两部分</p><p>标记、复制存活对象到另一部分，清空垃圾部分</p><ul><li>标记-整理</li></ul><p>标记、移动存活的对象，到内存的一段</p><p>清理掉边界外的空间</p><ul><li>分代算法</li></ul><p>对不同的内存区域，使用上述不同的回收算法</p><ol><li>新生代内存 采用复制算法</li></ol><p>原因： 新生代垃圾回收时，对象死亡率高，则仅复制少数存活对象即可</p><ol start="2"><li>老年代 采用 标记-清除 || 标记-整理算法</li></ol><p>原因： 老年代垃圾回收时，对象死亡率低，仅清除少量死亡对象即可</p><h2 id="对象的分配">对象的分配</h2><p>● 对象优先在eden区 分配</p><pre><code>对象优先在eden区分配，eden区没有足够空间时，触发 Minor GC虚拟机发起 【Minor GC】 = {          情况1 ： eden 已使用内存 &lt; suvivor内存            eden 内对象  转移到 suvivor内存        情况2 : eden 已使用内存 &gt; suvivor内存            eden 内对象 转移到 老年代 } FULL GC 触发条件 = {        新生代对象总空间 &gt; 老年代剩余连续空间         Minor GC 平均晋升空间大小 &gt; 老年代连续剩余空间，则触发FULL GC }</code></pre><h2 id="大对象进入老年代">大对象进入老年代</h2><p>避免 剩余较多内存空间 时，直接触发GC</p><h2 id="长期存活对象进入老年代">长期存活对象进入老年代</h2><p>对象在Eden出生， 每经历一次minor GC 并被移动到survivor区，则age++</p><p>年龄增加到一定程度(15岁)，则进入老年代。</p><p>此外 当suvivor区中一般以上对象年龄相同，则&gt;=该年龄的对象进入老年代。</p><h2 id="判断对象死亡-的方法">判断对象死亡 的方法</h2><ul><li>引用计数法<br>每当对象被引用，则计数器++;</li></ul><p>每当引用失效,则计数器–;</p><p>计数器值=0时，标记对象可回收</p><p>【存在问题】 ： 两个对象相互引用，则无法被回收</p><ul><li>可达分析算法</li></ul><p>从GC roots对象 向下搜索，如果没有路径到达目标对象。则标记目标对象可回收。</p><p>GC roots 对象:</p><ol><li>虚拟栈中 引用对象</li><li>方法区 静态属性的引用对象</li><li>方法区 常量引用的对象</li></ol><ul><li>二次标记</li></ul><p>标记可回收的对象，并非立刻回收。他们加入一个队列中进行二次标记。如果在二次标记前，对象产生引用则不会被回收。</p><h1>垃圾收集器：</h1><h2 id="1、CMS">1、CMS</h2><p>四个阶段：初始标记、并发标记、重新标记、并发回收</p><p>缺点：</p><ul><li>【cpu资源敏感】 ： 并发期间，GC程序占用CPU资源，导致用户程序吞吐量低。</li><li>【无法处理浮动垃圾】 ： 并发清除 阶段，GC和用户程序并发，在该阶段仍会产生垃圾。这些垃圾仅能在下一次GC中回收。</li><li>【标记-清除】算法，造成 大量【不连续】空间碎片</li></ul><h2 id="2、G1">2、G1</h2><h3 id="特点：">特点：</h3><p>提供规整的内存</p><p>可预测的停顿，能够控制回收时间在 N 毫秒内</p><p>以 Region 为单位，适合大内存的服务器</p><p>使用额外的空间来保存对象的引用关系，会占用额外的空间，内存碎片少</p><h3 id="关键字">关键字</h3><p>逻辑上仍然有新生代、存活代、老年代，但物理上是以 region 为单位的</p><p>在新生代：Yong GC 模式</p><p>在老年代：Mixed GC 模式<a href="https://blog.csdn.net/m0_63437643/article/details/122601042">https://blog.csdn.net/m0_63437643/article/details/122601042</a></p><h4 id="三色标记：（对对象进行可达性分析）">三色标记：（对对象进行可达性分析）</h4><ul><li>黑色：已被检查，对象成员也被检查了</li><li>灰色：被检查了，但是对象成员还未被全部检查</li><li>白色：对象还未被检查（若全部检查结束后，还是白色，则表明是不可达对象）</li></ul><h3 id="Region-组成">Region 组成</h3><ul><li>每个 region 1-32M （2 的 n 次幂大小）</li><li>伊甸园、新生代、老年代</li><li>Humongous 区：用来存放大对象（超过了 region 的一半大小）<br><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240831/0b8205dd08314237aecc50566e939cbf.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVM-垃圾回收-G1-Region组成"></li></ul><h4 id="Card-Table-卡表">Card Table 卡表</h4><h4 id="RSet：hash-表">RSet：hash 表</h4><ul><li>key：引用本 region 内对象的其他 region 起始地址</li><li>value:被引用的对象在 card table 中的索引位置<br>作用：解决跨代引用的问题</li></ul><h4 id="CollectionSet">CollectionSet</h4><h3 id="gc-过程">gc 过程</h3><h4 id="五个阶段：">五个阶段：</h4><p>初始标记（STW）、根Region扫描、并发标记、重新标记、并发回收（STW)</p><h3 id="YGC：">YGC：</h3><p>MixedGC：两大步骤</p><ol><li>全局并发标记</li><li>拷贝存活对象</li></ol><h3 id="对象丢失问题：">对象丢失问题：</h3><p>并发标记过程中，动态对象没有被标记，因为被误认为是垃圾对象而回收<br>解决：<br>1、增量更新:CMS使用<br>2、STAB：G1 使用<br>再加上写屏障捕获对象修改</p><h2 id="3、ZGC">3、ZGC</h2><p>特点</p><ol><li>全程并发</li><li>超低的停顿时间（10ms）</li><li>暂时没有分代的概念</li><li>仅支持64位系统（因为要用64位的指针）</li></ol><h3 id="组成">组成</h3><ul><li>Page<br>分三种类型：小型、中型、大型</li></ul><p>容量分别是 2M、32M、存放 4M 以上大对象的不固定大小容量</p><ul><li>染色指针<br>让指针存储额外的信息</li></ul><p>linux 只使用前 46 位（linux 只支持 64T 的内存）</p><p>表示当前对象处于 ZGC 的哪个阶段</p><p>更细颗粒度的停顿（不用STW，而是用读屏障）</p><p>指针关键字：<br>finalizable、remapped、marked1、marked0</p><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240831/f17db817dd3b420ea1e41b2723f5fb6a.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVM-垃圾回收-ZGC-指针"></p><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240831/134df1ca8c9f48928067c5a386a7f593.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVM-垃圾回收-ZGC-指针内容"></p><h4 id="NUMA（非统一内存访问）">NUMA（非统一内存访问）</h4><p>空间（虚拟内存）换时间</p><h3 id="GC-步骤">GC 步骤</h3><ol><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>重新标记</p></li><li><p>并发预备重分配</p><p>主要是处理软引用、弱引用、虚引用，重置 Page 的 Forwarding Table，收集待回收的 Page 信息到 Relocation Set 里</p></li><li><p>初始迁移</p></li><li><p>并发迁移</p></li><li><p>并发重映射</p></li></ol><h3 id="缺点：">缺点：</h3><p>单代吞吐量降低</p><p>会出现分配停顿的现象</p><p>并发GC，会导致CPU偏高</p><h3 id="内存泄露的例子">内存泄露的例子</h3><ol><li>单例模式</li></ol><p>对象长时间不使用，但是一直不释放<br>2. 容器内数据无用，但长时间不释放</p><h1>参考：</h1><ol><li><a href="https://juejin.cn/post/7216967809158299703#heading-11">https://juejin.cn/post/7216967809158299703#heading-11</a></li><li><a href="https://www.infoq.cn/article/3wyretkqrhivtw4frmr3">https://www.infoq.cn/article/3wyretkqrhivtw4frmr3</a></li><li><a href="https://ata.atatech.org/articles/12020228482?spm=ata.23639746.0.0.412218baqi4KiS">https://ata.atatech.org/articles/12020228482?spm=ata.23639746.0.0.412218baqi4KiS</a></li><li><a href="https://cr.openjdk.org/~pliden/slides/ZGC-OracleDevLive-2020.pdf?spm=ata.21736010.0.0.781310ceXcXP5Y&amp;file=ZGC-OracleDevLive-2020.pdf">https://cr.openjdk.org/~pliden/slides/ZGC-OracleDevLive-2020.pdf?spm=ata.21736010.0.0.781310ceXcXP5Y&amp;file=ZGC-OracleDevLive-2020.pdf</a></li><li><a href="https://ata.atatech.org/articles/11000199497?spm=ata.23639746.0.0.412218baqi4KiS">https://ata.atatech.org/articles/11000199497?spm=ata.23639746.0.0.412218baqi4KiS</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础-类加载过程</title>
      <link href="/2024/08/31/JVM%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/08/31/JVM%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>类加载过程</h1><ul><li>加载</li><li>验证</li><li>准备：为变量分配空间，赋零值</li><li>解析：符号引用转为直接引用</li><li>初始化：执行 static 的内容，为变量赋程序定义的初始值</li><li>使用</li><li>销毁</li></ul><p>若URLClassLoader加载的jar中，有内部一类的jar，且一起打包在一起了，则无法直接加载，可以通过使用!/ 的方式，将内部的文件读取出来，写到本地，在通过file文件文件流，再次手动加载，且不能在使用过程中关闭，否则，可能报找不到类</p><p>参考：<a href="https://blog.csdn.net/feinifi/article/details/130165703">https://blog.csdn.net/feinifi/article/details/130165703</a></p><p><a href="https://blog.csdn.net/a18602320276/article/details/129925935">https://blog.csdn.net/a18602320276/article/details/129925935</a></p><h1>双亲委派模型</h1><ul><li>【BootStrap】启动 类加载器</li><li>【Extension】扩展 类加载器</li><li>【Application】应用程序 类加载器</li><li>【User】自定义 类加载器</li></ul><p>自底向上 检测类是否被加载</p><ul><li>已被加载，则直接返回类对象</li><li>未被加载，则委派父类加载器加载(父类未加载，则向上循环)</li></ul><h2 id="双亲委派机制【优点】">双亲委派机制【优点】</h2><ul><li>（1） 避免类的重复加载</li><li>（2） 类加载器 加载 自己管理【范围】内的类</li></ul><h2 id="如何打破">如何打破</h2><h3 id="自定义类加载器：">自定义类加载器：</h3><p>重点：</p><ul><li>1、继承URLClassLoader，parent设置为null</li><li>2、在调用方法的时候，设置Thread.getClassLoader = 自定义的classloader，调用完毕后，在恢复</li></ul><p>避免目标类中的第三方依赖不隔离<br>如使用Thread.currentThread.getContextClassLoader()</p><h2 id="实际应用场景">实际应用场景</h2><h3 id="热部署">热部署</h3><p>热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为</p><p>方法</p><p>创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。</p><p>热部署步骤：</p><ul><li>1、销毁自定义classloader(被该加载器加载的class也会自动卸载)；</li><li>2、更新class</li><li>3、使用新的ClassLoader去加载class</li></ul><h1>参考</h1><p>1、<a href="https://www.cnblogs.com/aspirant/p/7200523.html">https://www.cnblogs.com/aspirant/p/7200523.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM/JVM-元空间</title>
      <link href="/2024/08/31/JVM-%E5%85%83%E7%A9%BA%E9%97%B4/"/>
      <url>/2024/08/31/JVM-%E5%85%83%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1>整体结构图</h1><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240831/e1b89e3a39e840d9bc33525bb32ebb54.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVM-元空间结构"></p><pre><code>Virtualspace +- Committed: 已提交的空间, 会被划分成一个个MetaChunk |   +- Took: 已经被划分成MetaChunk的空间 |   |   +- MetaChunk in Used: 一个被使用的MetaChunk |   |   |   +- Head: MetaChunk头部, 64位上占40个字节 |   |   |   +- Metaspace Object: 分配在Metaspace中的对象, 对象类型在下文介绍 |   |   |   +- Private Free Block: 可重复利用的Block, 但是只能被关联的ClassLoaderData所使用 |   |   |   +- Unusable Block: 暂时无法重新利用的Block, 只有等到ClassLoaderData能被回收才会释放 |   |   |   +- Wait To Free Object: 分配在Metaspace中的对象, 已经可以被回收了, 但是还未被回收 |   |   |   \- Private Free: MetaChunk中剩余的空间, 只能被关联的ClassLoaderData所使用 |   |   \- MetaChunk in Global Free List: 空闲的MetaChunk, 所有ClassLoaderData都能获取 |   \- Global Free: 还能继续被划分成MetaChunk的空间, 全局共享 \- Uncomitted: 未被提交的空间, 无法使用</code></pre><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240831/98dc056f4e984b9eb61b1f74941fa91f.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVM-元空间内容示意图"></p><h1>碎片化问题</h1><p>MetaChunk 会导致碎片化问题</p><h1>参考：</h1><p>1、ATA文章:<a href="https://ata.atatech.org/articles/11000102553?layout=%2Fvelocity%2Flayout%2Fblank.vm">https://ata.atatech.org/articles/11000102553?layout=%2Fvelocity%2Flayout%2Fblank.vm</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM整体</title>
      <link href="/2024/08/31/JVM%E6%95%B4%E4%BD%93/"/>
      <url>/2024/08/31/JVM%E6%95%B4%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1>整体结构</h1><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240831/ed564ad826fa41f98bedbda6252b3f16.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVM整体-整体结构图"></p><h1>运行时数据区域</h1><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240831/81640307c71b4600ac371375868d5964.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVM整体-运行时数据区域"></p><h1>参考：</h1><ul><li>1、<a href="https://juejin.cn/post/7040742081236566029?searchId=20240814093711080021B9089818535AC0">https://juejin.cn/post/7040742081236566029?searchId=20240814093711080021B9089818535AC0</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas技术原理-源码整体结构</title>
      <link href="/2024/08/03/Arthas%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/"/>
      <url>/2024/08/03/Arthas%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>预备知识</h1><pre><code>类似JVM中的AOPJava的agent机制</code></pre><h2 id="Instructation机制">Instructation机制</h2><pre><code class="language-text">使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。-- 百度百科</code></pre><p>instrument的底层实现依赖于JVMTI，也就是JVM Tool Interface，它是JVM暴露出来的一些供用户扩展的接口集合。<br>JVMTI是基于事件驱动的，JVM每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。<br><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/573821c2c6334946944bd6b002a8bdff.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="JVMTI机制"></p><p>使用instrument 的方式有两种，下面分别简单总结一下：</p><h2 id="premain方式（JVM启动前进行增强）">premain方式（JVM启动前进行增强）</h2><p>需要实现下面的方法</p><pre><code class="language-java">public static void premain(String args, Instrumentation instrumentation){    //在这里调用instrumentation 做增强操作}</code></pre><p>并在打包jar的时候，指定Premain-Class 的入口类</p><p>可以参考arthas中arthas-agent/pom.xml</p><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/dcd156b5b1dc448a9508c668071a59ff.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="实现premain的例子"></p><p>运行原理如下图：<br><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/def6dad5102b454f939d36890d62ef30.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="premain反射的运行原理"></p><p>在目标java程序启动运行前，通过-javaagent=agent.jar=paramsxxxx  的方式，可以在目标jvm运行前，进行字节码的修改</p><h3 id="常见的用法">常见的用法</h3><p>idea破解:使用agent的方式，替换加密的文件、证书</p><h2 id="agentmain方式（JVM运行中进行增强）">agentmain方式（JVM运行中进行增强）</h2><p>原理：使用attach机制，与目标jvm建立链接</p><p>使用步骤：</p><ul><li>1、编写agent实现类</li></ul><p>需要实现下面的方法</p><pre><code class="language-java">public static void agentmain(String args, Instrumentation instrumentation){}</code></pre><ul><li>2、打包为agent.jar</li></ul><p>并在打包jar的时候，指定Agent-Class 的入口类</p><p>可以参考arthas中arthas-agent/pom.xml</p><ul><li>3、编写注入程序，调用attach相关的api<br>使用时，需要先通过jvm的工具，获取jvm实例，然后调用</li></ul><pre><code class="language-text">com.sun.tools.attach.VirtualMachine.loadAgent(java.lang.String, java.lang.String)</code></pre><p>去给目标jvm注入agent.jar</p><ul><li>4、注入后，目标jvm就会运行上面定义的agentmain 方法，进而通过 Instrumentation 实例对jvm实例进行增强</li></ul><p>运行原理如下所示：<br><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/6cb9b98fb4bf4090948c76c2e2c7312e.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="agentmain方式运行原理"></p><h3 id="常见的应用案例：">常见的应用案例：</h3><p>arthas</p><h1>arthas核心模块的功能和流程</h1><p>arthas的核心模块不多，主要是以下几个：</p><h2 id="arthas-common">arthas-common</h2><p>类如下所示：<br><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/d3ed995b74d04d68a9a55fe0b7d295d8.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="arthas-common的类"></p><p>主要是存放公共类、工具类<br>如io相关的、文件相关的、反射相关的工具</p><h2 id="arthas-apy">arthas-apy</h2><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/b1e716806aa34c5d8d15e37b077635b9.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="arthas-spy模块的运行示意图"></p><p>只有一个类<br><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/53cb9cc70d4c4f0a97da9d07bb49b8f4.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="arthas-spy类截图"></p><p>定义此类，用于依附到目标jvm中，并实现目标jvm与arthas的类隔离，后续会深入研究</p><h2 id="arthas-client">arthas-client</h2><p>核心类是 com.taobao.arthas.client.TelnetConsole</p><p>对应入口函数是process(java.lang.String[], java.awt.event.ActionListener)</p><p>供arthas-boot使用，在boot的进程中起一个客户端线程，用于接收用户的输入、输出arthasc-core的输出内容</p><p>1、在com.taobao.arthas.client.IOUtil#readWrite 中会起两个线程，</p><ul><li>一个reader线程：用于读取用户在本地「终端」的输入，将其输出到远程的输出流中</li><li>一个writer线程：用于读取远程的输入流，将其输出到本地「终端」的输出流中</li></ul><p>上面的 本地「终端」，指的是标准输入输出</p><p>上面的 远程，指的是通过attach机制注入到目标jvm后，启动的监听端口所产生的连接</p><p>此外，连接远程的时候，会使用 org.apache.commons.net.telnet.TelnetInputStream 这个Runnable 去启动一个线程</p><h2 id="arthas-boot">arthas-boot</h2><p>使用 java -jar arthas-boot.jar 的方式启动arthas的时候，启动的就是本模块下的com.taobao.arthas.boot.Bootstrap的main 方法</p><p>启动后，会在做一下几件事情</p><ul><li><p>1、java版本的判断，做一些准备</p><ul><li>检查jdk版本的兼容性</li><li>检查telnet端口是否已被占用</li></ul></li><li><p>2、列出本机上存在的jvm进程和对应的pid，让用户选择要监听的jvm进程</p></li><li><p>3、选中要监听的jvm的pid后，会检查依赖的一下几个jar是否存在</p><p><em><strong>“arthas-core.jar”, “arthas-agent.jar”, “arthas-spy.jar”</strong></em></p></li></ul><p>若相关依赖不存在，则会去官网上下载</p><ul><li><p>4、若依赖存在，且telnet端口没有被占用，则会在此去检查telnet端口是否被占用</p><ul><li>若存在，则忽略</li><li>若不存在，则通过 <em><strong>com.taobao.arthas.boot.ProcessUtils#startArthasCore</strong></em> 方法，对目标jvm启动arthas-core<ul><li><p>使用ProcessBuilder ，构造一个进程，然后使用命令行的方式，调用 com.taobao.arthas.core.Arthas#main</p></li><li><p>继续调用 com.taobao.arthas.core.Arthas#attachAgent</p></li><li><p>最终调用<em><strong>com.sun.tools.attach.VirtualMachine.loadAgent(java.lang.String, java.lang.String)</strong></em></p><p>将agent注入到目标jvm中</p><p><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/392356d425a645c08448319c2b010efc.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="加载agent到目标jvm"></p></li></ul></li></ul></li><li><p>5、通过反射的方式，调用com.taobao.arthas.client.TelnetConsole#main，启动本地「终端」</p></li></ul><h2 id="arthas-core">arthas-core</h2><p>arthas的核心模块，被attach到目标jvm后，会执行一系列的动作</p><p>入口在 com.taobao.arthas.agent334.AgentBootstrap#agentmain</p><p>该模块比较复杂，会是后续研究的重点</p><p>ps：<br>也可以在IDEA中全局搜索pom.xml中的关键字「Agent-Class」，来确定attach的入口</p><h1>参考</h1><ul><li>1、<a href="https://www.cnblogs.com/zhenjingcool/p/16577979.html">https://www.cnblogs.com/zhenjingcool/p/16577979.html</a></li><li>2、【Java Agent探针技术探秘】<a href="https://ata.atatech.org/articles/11000162316?spm=ata.23639746.0.0.47507c90Fcc4f4">https://ata.atatech.org/articles/11000162316?spm=ata.23639746.0.0.47507c90Fcc4f4</a></li><li>3、【Arthas原理简析及应用】<a href="https://ata.atatech.org/articles/11000249240?spm=ata.23639746.0.0.47507c90Ce5mJD#LMKWsXKY">https://ata.atatech.org/articles/11000249240?spm=ata.23639746.0.0.47507c90Ce5mJD#LMKWsXKY</a></li><li>4、【Java Attach API】<a href="https://www.cnblogs.com/756623607-zhang/p/12575509.html">https://www.cnblogs.com/756623607-zhang/p/12575509.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arthas </tag>
            
            <tag> jvm底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas技术原理-源码调试环境搭建</title>
      <link href="/2024/08/03/Arthas%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/08/03/Arthas%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1>环境准备</h1><h2 id="源码下载">源码下载</h2><p>github 速度较慢，使用 gitee 的仓库</p><p><a href="https://gitee.com/arthas/arthas">https://gitee.com/arthas/arthas</a></p><p>下载源码</p><pre><code>git clone https://gitee.com/arthas/arthas.git</code></pre><h2 id="导入到-IDEA-中">导入到 IDEA 中</h2><p>源码基本模块<br><img src="/../drawioSources/arthas/arthas%E6%BA%90%E7%A0%81%E6%A8%A1%E5%9D%97%E6%88%AA%E5%9B%BE.png" alt="arthas源码模块截图"><br>找几个核心的模块讲一下</p><ul><li>arthas-agent<br>比较简单，就两个类<ul><li>AgentBootstrap：核心入口类（动态 attach 到目标 jvm 的入口）</li><li>ArthasClassloader：自定义的类加载器，为了实现 arthas 中依赖的类库与目标 jvm 中的隔离</li></ul></li><li>arthas-common</li><li>arthas-core</li></ul><p>使用java -jar arthas-boot.jar 的方式启动 arthas，就会使用此模块中的Bootstrap 方法，进而启动一系列的动作</p><ul><li>arthas-client</li></ul><p>客户端，即输入命令、执行 arthas 操作的客户端，基于 netty 实现了网络通信的功能</p><ul><li>arthas-spy</li></ul><p>用于对目标 JVM 进行插装的接口，仅一个类；在运行时会依附到目标 jvm 的进程中，并存在目标进程的 classloader 内</p><ul><li>math-game</li></ul><p>一个简单的计算大数分解的程序，用于演示 arthas 的功能</p><h3 id="模块的依赖关系">模块的依赖关系</h3><p><img src="/../drawioSources/arthas/%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="核心模块依赖关系"></p><h3 id="IDEA-的-arthas-插件">IDEA 的 arthas 插件</h3><p>插件名称：arthas idea</p><p>搜关键字 arthas 即可，如图</p><p><img src="/../drawioSources/arthas/idea%E7%9A%84arthas%E6%8F%92%E4%BB%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="arthas插件示意图"></p><p>安装后可以在 idea 中快捷生成 watch、trace 等常用的 arthas 命令，非常有用</p><h1>Hello world</h1><p>arthas 源码内，有一个用于演示的实例程序：math-game</p><p>在 idea 内 Debug 运行 Math-game，并添加 arthas 的断点</p><p>demo.MathGame#main</p><p>效果如下：<br><img src="/../drawioSources/arthas/%E8%BF%90%E8%A1%8Cmath-game%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="运行math-game效果图"></p><h2 id="在-idea-中运行-arthas-boot">在 idea 中运行 arthas-boot</h2><p>1、运行 arthas-boot</p><p>注意：在idea中运行arthas-boot的时候，需要选择jdk8，否则会报错</p><pre><code class="language-text">java: 程序包sun.misc不存在</code></pre><p>com.taobao.arthas.boot.Bootstrap#main<br><img src="/../drawioSources/arthas/%E8%BF%90%E8%A1%8Carthas-boot%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="运行arthas-boot效果图"></p><p>2、对 Math-game 的 jvm 进行远程调试<br><img src="/../drawioSources/arthas/%E8%BF%90%E8%A1%8Carthas%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95.png" alt="运行arthas进行调试"></p><p>3、进入断点，表明源码环境搭建成功</p><p><img src="/../drawioSources/arthas/%E8%BF%9B%E5%85%A5attach%E7%9A%84%E6%96%AD%E7%82%B9.png" alt="进入attach的断点"><br>4、尝试对 math-game 的函数进行 watch 操作</p><p><img src="/../drawioSources/arthas/%E6%89%A7%E8%A1%8Carthas%E5%91%BD%E4%BB%A4.png" alt="执行arthas命令"><br>输出结果：</p><p><img src="/../drawioSources/arthas/watch%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA.png" alt="watch命令输出"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arthas </tag>
            
            <tag> jvm底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch原理学习</title>
      <link href="/2024/08/03/ElasticSearch%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/03/ElasticSearch%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>基本概念</h1><h2 id="基本组件">基本组件</h2><h3 id="集群：">集群：</h3><p>由不同节点组成。整个 Elasticsearch 集群的核心就是对所有的分片执行分布存储，索引，负载，路由的工作。</p><h3 id="节点：">节点：</h3><p>单个服务器，用于保存数据、搜索文档</p><h3 id="索引：">索引：</h3><p>类似 数据库，可以定义多种类型的映射，映射到一个或多个主分片中，可以有 0 个、多个副本分片</p><h3 id="文档：">文档：</h3><p>类似数据库中的一行数据，可以有不同的结构（字段）</p><h3 id="分片（Shard）-：">分片（Shard） ：</h3><p>分片的个数在索引创建时被定义，不能动态修改。<br>每个分配都是单独的 lucene 实例，多分片可以分散数据和负载，增加并行度和吞吐量<br>是集群数据的容器，Index（索引）被分为多个文档碎片存储在分片中，分片又被分配 到集群内的各个节点里。<br>当需要查询一个文档时，需要先找到其位于的分片。也就是说，分片是 Elasticsearch 在集群内分发数据的单位。<br>每个分片都是一个 Lucene 索引实例，您可以将其视作一个独立的搜索引擎，它能够对 Elasticsearch 集 群中的数据子集进行索引并处理相关查询。</p><h4 id="主分片（Primary-Shard）：">主分片（Primary Shard）：</h4><p>分片的类型，负责写入数据<br>默认为 1 个</p><h4 id="副本分片（Replica-Shard）：">副本分片（Replica Shard）：</h4><p>是主分片的副本，提供搜索、返回文档的服务。支持横向扩展，增大数量有利于增加吞吐量<br>主分片出异常的情况下，会从副本分片中自动进行选举出新的主分片<br>默认为 0 个，但生产环境上，最少为一个</p><h3 id="路由（Route）">路由（Route）</h3><p>默认情况下， 在 es 中存放数据时会根据文档 id 平均存放到所遇到分片中。导致查数据的时候，需要查所有的分片才能得到结果。<br>默认情况的分片算法：</p><pre><code class="language-text">shard_num = hash(_routing) % num_primary_shards</code></pre><p>为了避免扫描全部分片，因此需要自定义路由规则，将文档放到指定的分片上去，查询的时候，只查指定的分片即可得到结果</p><h2 id="集群的节点类型：">集群的节点类型：</h2><ul><li>主节点（Master-eligible node） ：集群层面的管理，例如创建或删除索引、跟踪哪些节点是集群的一部分，以及决定将哪些分片分配给哪些节点。任何不是仅投票主节点的合格主节点都可以通过主选举过程被选为主节点。</li><li>专用备选主节点（Dedicated master-eligible node） ： Elasticsearch 集群中，设置了只能作为主节点的节点。设置专用主节点主要是为了保障集群增大时的稳定性，建议专用主节点个数至少为 3 个。</li><li>仅投票主节点（Voting-only master-eligible node）: 仅参与主节点选举投票，不会被选为主节点，硬件配置可以较低。</li><li>数据节点（data node） ：数据存储和数据处理比如 CRUD、搜索、聚合。</li><li>预处理节点（ingest node） ：执行由预处理管道组成的预处理任务。</li><li>仅协调节点（coordinating only node） ：路由分发请求、聚集搜索或聚合结果。</li><li>远程节点（Remote-eligible node） ：跨集群检索或跨集群复制。</li></ul><h2 id="Luence-的关键概念">Luence 的关键概念</h2><ul><li>term：关键字</li><li>postings list:位置表<br>即包含所有关键字的文档id集合，被处理为整形id</li></ul><p>luence 的写入流程</p><p><img src="/../imgs/elasticSearch%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png" alt="img.png"></p><h2 id="索引原理：">索引原理：</h2><h3 id="倒排索引：">倒排索引：</h3><p>字典树 Trie，树状结构，hash 树的变种</p><p>有限状态转移机</p><h3 id="索引压缩、优化">索引压缩、优化</h3><h4 id="分段存储">分段存储</h4><h4 id="延时写策略">延时写策略</h4><h4 id="段合并">段合并</h4><h1>关键流程</h1><h2 id="写入流程">写入流程</h2><p>如下图</p>        <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;<mxfile host=\&quot;Electron\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/24.7.5 Chrome/126.0.6478.183 Electron/31.3.0 Safari/537.36\&quot; version=\&quot;24.7.5\&quot;>\n  <diagram name=\&quot;lucene原理\&quot; id=\&quot;keEPGWgsJUl2ciSjORj3\&quot;>\n    <mxGraphModel dx=\&quot;2558\&quot; dy=\&quot;1775\&quot; grid=\&quot;0\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;0\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; background=\&quot;#ffffff\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;>\n      <root>\n        <mxCell id=\&quot;0\&quot; />\n        <mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; />\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-139\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-129\&quot; y=\&quot;-331\&quot; width=\&quot;603\&quot; height=\&quot;484\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-137\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-632\&quot; y=\&quot;-172\&quot; width=\&quot;373\&quot; height=\&quot;281\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;container=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-3\&quot; y=\&quot;-290\&quot; width=\&quot;350\&quot; height=\&quot;288\&quot; as=\&quot;geometry\&quot;>\n            <mxRectangle x=\&quot;-3\&quot; y=\&quot;-290\&quot; width=\&quot;50\&quot; height=\&quot;44\&quot; as=\&quot;alternateBounds\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-128\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 7px;&amp;quot;&amp;gt;每秒更新，写入commit point&amp;lt;/font&amp;gt;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.25;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-115\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-116\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-115\&quot; value=\&quot;内存缓存\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#1ba1e2;fontColor=#ffffff;strokeColor=#006EAF;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry x=\&quot;16\&quot; y=\&quot;78\&quot; width=\&quot;67\&quot; height=\&quot;23\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-130\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-116\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-129\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-116\&quot; value=\&quot;Segment File\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#1ba1e2;fontColor=#ffffff;strokeColor=#006EAF;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry x=\&quot;13\&quot; y=\&quot;142\&quot; width=\&quot;197\&quot; height=\&quot;21\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-120\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-119\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-115\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-121\&quot; value=\&quot;写入内存缓存\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-120\&quot;>\n          <mxGeometry x=\&quot;-0.2086\&quot; y=\&quot;3\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;-14\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-119\&quot; value=\&quot;\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry x=\&quot;91\&quot; y=\&quot;15\&quot; width=\&quot;19\&quot; height=\&quot;19\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-123\&quot; value=\&quot;translog 日志文件\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry x=\&quot;102\&quot; y=\&quot;78\&quot; width=\&quot;124\&quot; height=\&quot;22\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-124\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.555;entryY=0.045;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-119\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-123\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;169\&quot; y=\&quot;25\&quot; />\n              <mxPoint x=\&quot;169\&quot; y=\&quot;56\&quot; />\n              <mxPoint x=\&quot;171\&quot; y=\&quot;56\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-125\&quot; value=\&quot;同时写入日志\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-124\&quot;>\n          <mxGeometry x=\&quot;0.1142\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-129\&quot; value=\&quot;OS Cache\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fillColor=#1ba1e2;fontColor=#ffffff;strokeColor=#006EAF;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry x=\&quot;60.75\&quot; y=\&quot;191\&quot; width=\&quot;101.5\&quot; height=\&quot;24\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-133\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.787;entryY=-0.023;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-123\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-116\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-134\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 8px;&amp;quot;&amp;gt;每30分钟刷新一次&amp;lt;/font&amp;gt;\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-133\&quot;>\n          <mxGeometry x=\&quot;-0.3655\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-117\&quot; value=\&quot;Disk&amp;lt;div&amp;gt;translog&amp;lt;/div&amp;gt;\&quot; style=\&quot;shape=cylinder3;whiteSpace=wrap;html=1;boundedLbl=1;backgroundOutline=1;size=15;fillColor=#60a917;fontColor=#ffffff;strokeColor=#2D7600;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry x=\&quot;267\&quot; y=\&quot;118.5\&quot; width=\&quot;71\&quot; height=\&quot;59.5\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-126\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-123\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-117\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-127\&quot; value=\&quot;刷新到日志文件\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-126\&quot;>\n          <mxGeometry x=\&quot;-0.101\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-118\&quot; value=\&quot;Disk&amp;lt;div&amp;gt;segment file&amp;lt;/div&amp;gt;\&quot; style=\&quot;shape=cylinder3;whiteSpace=wrap;html=1;boundedLbl=1;backgroundOutline=1;size=15;fillColor=#60a917;fontColor=#ffffff;strokeColor=#2D7600;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry x=\&quot;252\&quot; y=\&quot;211\&quot; width=\&quot;84\&quot; height=\&quot;57\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-131\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-129\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-118\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;112\&quot; y=\&quot;258\&quot; />\n              <mxPoint x=\&quot;178\&quot; y=\&quot;258\&quot; />\n              <mxPoint x=\&quot;178\&quot; y=\&quot;240\&quot; />\n              <mxPoint x=\&quot;252\&quot; y=\&quot;240\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-132\&quot; value=\&quot;fsync\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-131\&quot;>\n          <mxGeometry x=\&quot;-0.6107\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-135\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.75;entryY=1;entryDx=0;entryDy=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-116\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-116\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-136\&quot; value=\&quot;定期合并\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-135\&quot;>\n          <mxGeometry x=\&quot;0.0664\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-103\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-102\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-95\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-105\&quot; value=\&quot;1、发出写入请求\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-103\&quot;>\n          <mxGeometry x=\&quot;-0.5295\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-65\&quot; value=\&quot;内存中\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-72\&quot; y=\&quot;237\&quot; width=\&quot;170\&quot; height=\&quot;310\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-64\&quot; value=\&quot;磁盘上\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;138\&quot; y=\&quot;237\&quot; width=\&quot;320\&quot; height=\&quot;320\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-26\&quot; value=\&quot;Term Index\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;fillColor=#d5e8d4;strokeColor=#82b366;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-42\&quot; y=\&quot;277\&quot; width=\&quot;120\&quot; height=\&quot;240\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-27\&quot; value=\&quot;Term Dictionary\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;fillColor=#5fa1ee;fontColor=#ffffff;strokeColor=#001DBC;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;148\&quot; y=\&quot;277\&quot; width=\&quot;120\&quot; height=\&quot;240\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-67\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-28\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-66\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-28\&quot; value=\&quot;Postings List\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;fillColor=#5fa1ee;fontColor=#ffffff;strokeColor=#001DBC;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;308\&quot; y=\&quot;277\&quot; width=\&quot;120\&quot; height=\&quot;240\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-37\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-29\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-31\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-45\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-29\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-43\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-29\&quot; value=\&quot;\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;13\&quot; y=\&quot;327\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-38\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-31\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-32\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-51\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;curved=1;dashed=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-31\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-47\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;18\&quot; y=\&quot;367\&quot; />\n              <mxPoint x=\&quot;86\&quot; y=\&quot;367\&quot; />\n              <mxPoint x=\&quot;86\&quot; y=\&quot;327\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-31\&quot; value=\&quot;L\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;13\&quot; y=\&quot;347\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-39\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-32\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-33\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-32\&quot; value=\&quot;U\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-7\&quot; y=\&quot;367\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-40\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-33\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-34\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-53\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-33\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-52\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-33\&quot; value=\&quot;C\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;3\&quot; y=\&quot;392\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-41\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-34\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-35\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-34\&quot; value=\&quot;E\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-32\&quot; y=\&quot;417\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-35\&quot; value=\&quot;N\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;3\&quot; y=\&quot;437\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-50\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;curved=1;dashed=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-36\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-49\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-36\&quot; value=\&quot;E\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;13\&quot; y=\&quot;457\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-42\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.175;entryY=0.55;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-35\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-36\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-43\&quot; value=\&quot;M\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-22\&quot; y=\&quot;347\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-44\&quot; value=\&quot;N\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;48\&quot; y=\&quot;347\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-46\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.675;entryY=0.075;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-29\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-44\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-60\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-47\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-55\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-47\&quot; value=\&quot;Li\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;173\&quot; y=\&quot;317\&quot; width=\&quot;70\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-61\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-48\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-56\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-48\&quot; value=\&quot;Lucy\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;173\&quot; y=\&quot;357\&quot; width=\&quot;70\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-49\&quot; value=\&quot;Luncene\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;173\&quot; y=\&quot;402\&quot; width=\&quot;70\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-52\&quot; value=\&quot;Y\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;aspect=fixed;fontSize=6;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;38\&quot; y=\&quot;412\&quot; width=\&quot;10\&quot; height=\&quot;10\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-54\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.004;entryY=0.407;entryDx=0;entryDy=0;entryPerimeter=0;curved=1;dashed=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-52\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-48\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-55\&quot; value=\&quot;[1,2,3,4,6,11]\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;318\&quot; y=\&quot;314.5\&quot; width=\&quot;100\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-56\&quot; value=\&quot;[1,3,45,23,123]\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;318\&quot; y=\&quot;354.5\&quot; width=\&quot;100\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-57\&quot; value=\&quot;[2,43,23423,2345]\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;318\&quot; y=\&quot;399.5\&quot; width=\&quot;100\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-63\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-58\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-59\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-58\&quot; value=\&quot;...\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;173\&quot; y=\&quot;447\&quot; width=\&quot;70\&quot; height=\&quot;20\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-59\&quot; value=\&quot;...\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;318\&quot; y=\&quot;444.5\&quot; width=\&quot;100\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-62\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.03;entryY=0.463;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-49\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-57\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-66\&quot; value=\&quot;&amp;lt;div style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;&amp;lt;br style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;&amp;lt;br style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;优化：&amp;lt;div style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;1、FOR:存储压缩（保存为相比前一个文档id的增量，大数变小数）&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;2、block分区&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 10px;&amp;quot;&amp;gt;3、&amp;lt;span style=&amp;quot;background-color: rgb(255, 255, 255); color: rgb(33, 37, 41); font-family: system-ui, -apple-system, &amp;amp;quot;Segoe UI&amp;amp;quot;, Roboto, &amp;amp;quot;Helvetica Neue&amp;amp;quot;, &amp;amp;quot;Noto Sans&amp;amp;quot;, &amp;amp;quot;Liberation Sans&amp;amp;quot;, Arial, sans-serif, &amp;amp;quot;Apple Color Emoji&amp;amp;quot;, &amp;amp;quot;Segoe UI Emoji&amp;amp;quot;, &amp;amp;quot;Segoe UI Symbol&amp;amp;quot;, &amp;amp;quot;Noto Color Emoji&amp;amp;quot;; font-size: 10px; font-weight: bolder;&amp;quot;&amp;gt;roaring bitmap：用于filter cache&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;verticalAlign=top;rounded=1;fontSize=10;align=left;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;273\&quot; y=\&quot;617\&quot; width=\&quot;223\&quot; height=\&quot;160\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-68\&quot; value=\&quot;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;联合查询技术&amp;lt;/font&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;&amp;lt;font style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;（多个条件的结果，取交集、并集）&amp;lt;/font&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;1：使用skip list，对多个list求交集&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;font-size: 11px;&amp;quot;&amp;gt;2、结合Postings list的FOR压缩，可以跳过不需要的解压&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;align=left;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-102\&quot; y=\&quot;647\&quot; width=\&quot;320\&quot; height=\&quot;110\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-107\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;curved=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-95\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;-22\&quot; y=\&quot;-74\&quot; as=\&quot;targetPoint\&quot; />\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;-183\&quot; y=\&quot;-113\&quot; />\n              <mxPoint x=\&quot;-183\&quot; y=\&quot;-268\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-108\&quot; value=\&quot;2、路由到对应的主分片\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-107\&quot;>\n          <mxGeometry x=\&quot;-0.2765\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;3\&quot; y=\&quot;-40\&quot; as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-146\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-95\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-102\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-147\&quot; value=\&quot;7.1 返回写入结果\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-146\&quot;>\n          <mxGeometry x=\&quot;0.1151\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-95\&quot; value=\&quot;主分片\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-532\&quot; y=\&quot;-153\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-109\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.25;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-99\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;9.645451438183954\&quot; y=\&quot;-38.74839908530953\&quot; as=\&quot;sourcePoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-110\&quot; value=\&quot;4.1写入副本\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-109\&quot;>\n          <mxGeometry x=\&quot;-0.0152\&quot; y=\&quot;1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-111\&quot; style=\&quot;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.75;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-100\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint x=\&quot;62.368307963182815\&quot; y=\&quot;-37.44753805522555\&quot; as=\&quot;sourcePoint\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-112\&quot; value=\&quot;4.1 写入分配\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-111\&quot;>\n          <mxGeometry x=\&quot;-0.3605\&quot; y=\&quot;-1\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-97\&quot; value=\&quot;副本分片\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-608\&quot; y=\&quot;-62\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-98\&quot; value=\&quot;副本分片\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-460\&quot; y=\&quot;-59\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-140\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;curved=1;entryX=0.365;entryY=1.004;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-99\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;22\&quot; y=\&quot;63\&quot; />\n              <mxPoint x=\&quot;22\&quot; y=\&quot;61\&quot; />\n              <mxPoint x=\&quot;125\&quot; y=\&quot;61\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-141\&quot; value=\&quot;4.2 返回写入成功\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-140\&quot;>\n          <mxGeometry x=\&quot;-0.1917\&quot; y=\&quot;2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-99\&quot; value=\&quot;\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-117\&quot; y=\&quot;61\&quot; width=\&quot;58\&quot; height=\&quot;25\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-142\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.569;entryY=1.005;entryDx=0;entryDy=0;curved=1;exitX=0.026;exitY=0.658;exitDx=0;exitDy=0;exitPerimeter=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-100\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;247\&quot; y=\&quot;93\&quot; />\n              <mxPoint x=\&quot;247\&quot; y=\&quot;25\&quot; />\n              <mxPoint x=\&quot;196\&quot; y=\&quot;25\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-143\&quot; value=\&quot;4.2 返回写入成功\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-142\&quot;>\n          <mxGeometry x=\&quot;0.2004\&quot; y=\&quot;-65\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-100\&quot; value=\&quot;\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;367\&quot; y=\&quot;69\&quot; width=\&quot;51\&quot; height=\&quot;36\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-104\&quot; value=\&quot;\&quot; style=\&quot;group\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-746\&quot; y=\&quot;-363\&quot; width=\&quot;122\&quot; height=\&quot;151\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-102\&quot; value=\&quot;\&quot; style=\&quot;ellipse;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-104\&quot;>\n          <mxGeometry width=\&quot;122\&quot; height=\&quot;151\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-101\&quot; value=\&quot;Actor\&quot; style=\&quot;shape=umlActor;verticalLabelPosition=bottom;verticalAlign=top;html=1;outlineConnect=0;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-104\&quot;>\n          <mxGeometry x=\&quot;45\&quot; y=\&quot;40\&quot; width=\&quot;30\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-144\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.919;entryY=0.797;entryDx=0;entryDy=0;entryPerimeter=0;curved=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-114\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-95\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <Array as=\&quot;points\&quot;>\n              <mxPoint x=\&quot;-77\&quot; y=\&quot;-268\&quot; />\n              <mxPoint x=\&quot;-77\&quot; y=\&quot;-89\&quot; />\n            </Array>\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-145\&quot; value=\&quot;6.1 返回结果\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-144\&quot;>\n          <mxGeometry x=\&quot;-0.5808\&quot; y=\&quot;3\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-148\&quot; value=\&quot;写入流程\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=33;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;-463\&quot; y=\&quot;-407\&quot; width=\&quot;286\&quot; height=\&quot;94\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot; value=\&quot;\&quot; style=\&quot;group\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;1\&quot;>\n          <mxGeometry x=\&quot;730\&quot; y=\&quot;-346\&quot; width=\&quot;610\&quot; height=\&quot;395\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-11\&quot; value=\&quot;Shard\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;verticalAlign=top;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot;>\n          <mxGeometry width=\&quot;610\&quot; height=\&quot;395\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-12\&quot; value=\&quot;Segment&amp;lt;div&amp;gt;保存最多2^31个文档&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot;>\n          <mxGeometry x=\&quot;10\&quot; y=\&quot;155\&quot; width=\&quot;160\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-18\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-14\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-17\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-20\&quot; value=\&quot;定期合并\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-18\&quot;>\n          <mxGeometry x=\&quot;-0.14\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-14\&quot; value=\&quot;Segment\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot;>\n          <mxGeometry x=\&quot;220\&quot; y=\&quot;155\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-15\&quot; value=\&quot;。。。\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot;>\n          <mxGeometry x=\&quot;10\&quot; y=\&quot;235\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-19\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot; source=\&quot;owNHDJ87eFbLBp3wyVCf-16\&quot; target=\&quot;owNHDJ87eFbLBp3wyVCf-17\&quot;>\n          <mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-21\&quot; value=\&quot;定期合并\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-19\&quot;>\n          <mxGeometry x=\&quot;-0.0405\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;>\n            <mxPoint as=\&quot;offset\&quot; />\n          </mxGeometry>\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-16\&quot; value=\&quot;Segment\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot;>\n          <mxGeometry x=\&quot;350\&quot; y=\&quot;155\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n        <mxCell id=\&quot;owNHDJ87eFbLBp3wyVCf-17\&quot; value=\&quot;Segment\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;owNHDJ87eFbLBp3wyVCf-149\&quot;>\n          <mxGeometry x=\&quot;280\&quot; y=\&quot;255\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; />\n        </mxCell>\n      </root>\n    </mxGraphModel>\n  </diagram>\n</mxfile>\n&quot;}"></div>        <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script><h1>常见问题</h1><h2 id="如何保存数据一致">如何保存数据一致</h2><h3 id="通过版本号使用乐观锁控制，确保新版本不会被旧版本覆盖">通过版本号使用乐观锁控制，确保新版本不会被旧版本覆盖</h3><p>写操作：</p><p>三种分布式一致性级别</p><p>读操作：</p><p>可设置 replication</p><ul><li><p>= sync（默认同步），来使主分片和副本分片都返回结果，才返回给客户端</p></li><li><p>= async 是，可以设置查询 参数来确保数据为最新的</p></li></ul><h2 id="如何与-mysql-保持数据同步">如何与 mysql 保持数据同步</h2><p>全量、增量、增全量、binlog 同步</p><h1>参考：</h1><ul><li>1、【Elasticsearch 如何做到快速检索 - 倒排索引的秘密】<a href="https://segmentfault.com/a/1190000037658997">https://segmentfault.com/a/1190000037658997</a></li><li>2、【关于Lucene的词典FST深入剖析】<a href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/">https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/</a></li><li>3、【科普文：深入理解ElasticSearch体系结构】<a href="https://blog.csdn.net/Rookie_CEO/article/details/140088756">https://blog.csdn.net/Rookie_CEO/article/details/140088756</a></li><li>4、<a href="https://www.cnblogs.com/jajian/p/11223992.html">https://www.cnblogs.com/jajian/p/11223992.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web-HTTPS(加密原理）</title>
      <link href="/2024/07/01/HTTPS(%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%EF%BC%89/"/>
      <url>/2024/07/01/HTTPS(%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Https：加密原理<br>TODO 待完善</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web基础 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web-安全</title>
      <link href="/2024/07/01/Web-%E5%AE%89%E5%85%A8/"/>
      <url>/2024/07/01/Web-%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1>跨站请求伪造CSRF</h1><h2 id="CSRF攻击原理">CSRF攻击原理</h2><p>攻击者诱导用户点击，获取用户的session，并假装用户本身，提交请求到目标网站。</p><p>根本原因：目标网站无法验证请求是不是用户“自愿”发起的，只能验证是不是用户发起的</p><h2 id="防范方式：">防范方式：</h2><p>在请求中添加攻击者难以制造的信息</p><p>1、随机化Token</p><p>每次刷新页面时，都需要新的Token</p><p>使用hidden field的方式，将Token添加到表单中提交</p><p>2、Referer检查</p><p>3、Cookie SameSite属性：</p><p>4、限制Cookie操作：不在Cookie中添加敏感信息，避免Cookie外泄</p><p>3、限制HTTP</p><p>http头：<font style="color:rgb(25, 29, 23);">X-Xsrf-Token:</font></p><p><font style="color:rgb(25, 29, 23);"></font></p><p><font style="color:rgb(25, 29, 23);"></font></p><h1>XSS攻击（Cross Site Scripting，跨站脚本攻击）</h1><h2 id="攻击原理">攻击原理</h2><p>在web页面中插入恶意脚本，在用户浏览的时候执行。</p><h2 id="font-style-color-rgb-25-29-23-分类-font"><font style="color:rgb(25, 29, 23);">分类</font></h2><ul><li>反射型、非持久性XSS：诱导受害者去访问恶意的URL</li></ul><p>如恶意链接</p><ul><li>存储新：将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面，就会触发恶意代码的执行</li></ul><p>如在博客的评论中，添加恶意代码</p><ul><li>DOM-Base型：</li><li>SQL注入：</li></ul><p>可以使用预编译语句PreparedStatement 防范</p><h2 id="防范策略">防范策略</h2><ul><li>cookie安全策略</li></ul><p>1、http-only</p><p>2、secure-only</p><p>3、host-only</p><ul><li>X-XSS-Protection设置</li><li>其他。。。</li></ul><h1><font style="color:rgb(25, 29, 23);">参考文档</font></h1><p>1、XSRF-TOKEN</p><p><a href="https://blog.csdn.net/m0_57236802/article/details/132259004">https://blog.csdn.net/m0_57236802/article/details/132259004</a></p><p>2、XSS攻击及防范：<a href="https://www.cnblogs.com/tugenhua0707/p/10909284.html">https://www.cnblogs.com/tugenhua0707/p/10909284.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Quick Start</title>
      <link href="/2024/07/01/Hexo%20Quick%20Start/"/>
      <url>/2024/07/01/Hexo%20Quick%20Start/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><pre><code class="language-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web-登录、鉴权</title>
      <link href="/2024/07/01/Web-%E7%99%BB%E5%BD%95%E3%80%81%E9%89%B4%E6%9D%83/"/>
      <url>/2024/07/01/Web-%E7%99%BB%E5%BD%95%E3%80%81%E9%89%B4%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1>cookie</h1><p>存储在客户端，大小有限制，只能保存字符串，有效期可以设置长写</p><p>服务端回复set-cookie后，浏览器会设置cookie，可以设置是否能被脚本访问到</p><h1>session</h1><p>存储在服务端，基于cookie，用cookie中的sessionId标识，</p><h1>Token</h1><p>可以避免cookie重放攻击</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1709599481075-aeff75cc-ee9d-41b2-a460-79c92e65bee2.png" alt=""></p><h1>对比</h1><table><thead><tr><th style="text-align:left"><strong><font style="color:rgb(25, 27, 31);">方式</font></strong></th><th style="text-align:left"><strong><font style="color:rgb(25, 27, 31);">特点</font></strong></th><th style="text-align:left"><strong><font style="color:rgb(25, 27, 31);">优点</font></strong></th><th><strong><font style="color:rgb(25, 27, 31);">缺点</font></strong></th></tr></thead><tbody><tr><td style="text-align:left"><font style="color:rgb(25, 27, 31);">cookie</font></td><td style="text-align:left"><font style="color:rgb(25, 27, 31);">1.存储在客户端。2.请求自动携带 cookie。3.存储大小 4KB。</font></td><td style="text-align:left"><font style="color:rgb(25, 27, 31);">1.兼容性好，因为是比较老的技术。</font><br><font style="color:rgb(25, 27, 31);">2.很容易实现，因为 cookie 会自动携带和存储。</font></td><td><font style="color:rgb(25, 27, 31);">1.需要单独解决跨域携带问题，比如多台服务器如何共享 cookie。</font><br><font style="color:rgb(25, 27, 31);">2.会遭受 CSRF 攻击。</font><br><font style="color:rgb(25, 27, 31);">3.存储在客户端，不够安全。</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(25, 27, 31);">session</font></td><td style="text-align:left"><font style="color:rgb(25, 27, 31);">1.存储在服务端。2.存储大小无限制。</font></td><td style="text-align:left"><font style="color:rgb(25, 27, 31);">1.查询速度快，因为是个会话，相当于是在内存中操作。</font><br><font style="color:rgb(25, 27, 31);">2.结合 cookie 后很容易实现鉴权。</font><br><font style="color:rgb(25, 27, 31);">3.安全，因为存储在服务端。</font></td><td><font style="color:rgb(25, 27, 31);">1.耗费服务器资源，因为每个客户端都会创建 session。</font><br><font style="color:rgb(25, 27, 31);">2.占据存储空间，session 相当于存储了一个完整的用户信息。</font></td></tr><tr><td style="text-align:left"><font style="color:rgb(25, 27, 31);">token</font></td><td style="text-align:left"><font style="color:rgb(25, 27, 31);">1.体积很小。2.自由操作存储在哪里。</font></td><td style="text-align:left"><font style="color:rgb(25, 27, 31);">1.安全，因为 token 一般只有用户 id，就算被截取了也没什么用。</font><br><font style="color:rgb(25, 27, 31);">2.无需消耗服务器内存资源，它相当于只存了用户 id，session 相当于存储了用户的所有信息。</font><br><font style="color:rgb(25, 27, 31);">3.跨域处理较为方便，比如多台服务器之间可以共用一个 token。</font><br><font style="color:rgb(25, 27, 31);">4、可以防止跨域请求伪造攻击</font></td><td><font style="color:rgb(25, 27, 31);">1.查询速度慢，因为 token 只存了用户 id，每次需要去查询数据库。</font></td></tr></tbody></table><h1>SSO（单点登录）</h1><h2 id="JWT（JSON-Web-Token）">JWT（JSON Web Token）</h2><p>json格式的，使用.分割不同的部分，可以在url上传递</p><h3 id="构成">构成</h3><p>头部、载荷、签名</p><pre><code class="language-json">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjpbeyJ1cmwiOiJodHRwczovL3Rvb2x0dC5jb20ifV0sImlhdCI6MTY0NjExMDgwNSwiZXhwIjoyNTU2MTE1MTk5LCJhdWQiOiIiLCJpc3MiOiJ0b29sdHQuY29tIiwic3ViIjoiIn0.NhUwqiPfYey9pKHSfrG-ptqEOamIQFK3-K7IrTeBFYU</code></pre><p>base64URl解码后</p><pre><code class="language-json">{  "alg": "HS256",  "typ": "JWT"}</code></pre><pre><code class="language-json">{  "data": [    {      "url": "https://tooltt.com"    }  ],  "iat": 1646110805,  "exp": 2556115199,  "aud": "",  "iss": "tooltt.com",  "sub": ""}</code></pre><p>可以使用加密算法，对头部 + 载荷进行加密，</p><h3 id="登录流程">登录流程</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2024/png/308915/1709561878041-118a43b2-557b-4519-a692-95cf29a758f1.png" alt=""></p><h2 id="JWS-JSON-Web-Signature">JWS(JSON Web Signature)</h2><p>对载荷内容进行签名，防止被篡改</p><h2 id="JWE-JSON-Web-Encrption">JWE(JSON Web Encrption)</h2><p>对内容加密后的载荷</p><h2 id="Oauth2">Oauth2</h2>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2024/06/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2024/06/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1>基于Redis</h1><table><thead><tr><th>方式</th><th>介绍</th><th>原理、机制、步骤</th><th>失效情况</th><th>缺点</th></tr></thead><tbody><tr><td>Set NX PX</td><td>基本操作</td><td>命令：</td><td></td><td></td></tr><tr><td>set key value NX PX 毫秒数</td><td>仅在redis单机模式下有效</td><td></td><td></td><td></td></tr><tr><td>集群模式下，会失效</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>lua脚本</td><td>进阶操作</td><td></td><td>仅在redis单机模式下有效</td><td></td></tr><tr><td>哨兵/集群模式下，会失效</td><td></td><td></td><td></td><td></td></tr><tr><td>原因是因为会有主从异步，异步传播的问题</td><td></td><td></td><td></td><td></td></tr><tr><td>可能主节点刚写入，还未同步到从节点，主节点就宕机了，此时其他线程也可能加锁成功</td><td>哨兵/集群模式下，会失效</td><td></td><td></td><td></td></tr><tr><td>RedLock</td><td>分布式加锁思想</td><td>1、用相同的key 和随机的value进行加锁</td><td></td><td></td></tr><tr><td>2、设置较短的过期时间</td><td></td><td></td><td></td><td></td></tr><tr><td>3、使用时需要计算各个机器上加锁的耗时</td><td></td><td></td><td></td><td></td></tr><tr><td>4、半数以上成功，且超时时间未到，才算加上成功</td><td></td><td></td><td></td><td></td></tr><tr><td>5、否则，认为加锁失败，逐个进行解锁缩放</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Redission</td><td>分布式锁框架中间件</td><td></td><td></td><td></td></tr><tr><td>大量使用lua脚本</td><td>加锁过程</td><td></td><td></td><td></td></tr><tr><td>先用exits判断是否已经加锁成功</td><td></td><td></td><td></td><td></td></tr><tr><td>可重入锁：若成功，则使用使用hincby，加锁次数+1</td><td></td><td></td><td></td><td></td></tr><tr><td>使用pexpire：设置过期时间</td><td></td><td></td><td></td><td></td></tr><tr><td>自动延长锁过期时间（watchdog机制）（本质是定时任务）</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1>基于Zookeeper</h1><p>参考：<br>1、<a href="https://blog.51cto.com/zhangxueliang/6315986">https://blog.51cto.com/zhangxueliang/6315986</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 开发实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试加密文章</title>
      <link href="/2024/06/29/%E6%B5%8B%E8%AF%95%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"/>
      <url>/2024/06/29/%E6%B5%8B%E8%AF%95%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>这个文章是用来测试访问需要密码的功能的</p><p>若看到此文字的时候，没有输入密码，则表示功能配置有误</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2024/06/29/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/06/29/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1>分布式事务综述 <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h1><h1>基础理论：CAP、BASE</h1><h2 id="分布式事务算法、思想">分布式事务算法、思想</h2><h3 id="2PC（强一致性）">2PC（强一致性）</h3><p>有数据阻塞、不一致的情况</p><h3 id="3PC（强一致性）">3PC（强一致性）</h3><p>有数据阻塞、不一致的情况</p><h3 id="TCC（最终一致）">TCC（最终一致）</h3><p>TCC分布式事务模型相对于XA协议，其特征在于它不依赖资源管理器对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。对于一个具体的业务服务，其需要业务系统提供三段业务逻辑：</p><ul><li>1.Try：完成所有业务检查，预留必须的业务资源；</li><li>2.Confirm：用于提交，真正执行业务逻辑，不做任何业务检查且只使用try阶段预留的业务资源。因此只要try操作成功，confirm也能成功；此外confirm还需要满足幂等性，保证分布式事务有且只有一次成功；</li><li>3.Cancel：用于回滚，释放Try阶段预留的业务资源，同样也需要满足幂等性。</li></ul><p>举例子来说，拿10元买一瓶水这一操作，Try阶段，查询钱包中是否有10元并锁住这10元，查询是否有水并锁住这一瓶水；如果try阶段失败则执行cancel，</p><p>释放10元和这一瓶水，保证幂等性；如果都成功则进行confirm，确认扣除10元和一瓶水，confirm失败会重试需要保证幂等性；</p><p>TCC实现的二阶段提交是在业务层面而不是在资源层面，有效避免了XA二阶段提交占用资源锁过长导致的性能低下问题。但是TCC模型对业务代码有很大的入侵，业务改造成本高。</p><h3 id="最大努力通知方式（最终一致）">最大努力通知方式（最终一致）</h3><p>BEN（Best Effort Notification），它是一种不保证强一致性的方法，通过异步通知（常见的是消息中间件实现）来达到事务的一致性，</p><p>即尽力保证事务成功，但不能完全保证，主要应用在金融交易场景中。</p><p>具体来说，分布式事务最大努力通知通常用于以下场景：</p><ul><li>1、异步通知：当某个服务需要通知其他服务或组件进行后续操作时，可以采用异步通知的方式，发出通知后即可继续自身的操作，而不需要等待被通知的服务的响应。</li><li>2、最终一致性：在分布式系统中，因为网络延迟、故障等原因，无法保证所有相关的服务或组件都能够及时收到通知。因此，采用最大努力通知的方式来处理事务，可以更好地适应分布式系统的不确定性，最终保证系统达到一致的状态。</li></ul><p>在实际应用中，分布式事务最大努力通知可能会导致以下情况：</p><ul><li>通知失败：由于网络故障、接收方服务不可用等原因，通知可能会失败。</li><li>重复通知：为了确保通知的可靠性，可能需要定时重试通知操作，这可能导致接收方收到重复的通知。</li></ul><p>为了应对这些情况，通常需要在接收方设计幂等性的接收机制，以确保即使接收到重复的通知，也不会对系统状态产生额外影响。</p><p>总的来说，分布式事务最大努力通知是一种在分布式系统中处理事务的方法，它通过异步、灵活的通知机制来适应分布式系统的复杂性，但同时也需要考虑通知可能失败和重复通知等情况。</p><p>对于时间不敏感的业务，短信、邮件通知等。尽最大努力进行推送消息保证事务数据的最终一致性。</p><h1>分布式事务解决方案</h1><h2 id="XA协议">XA协议</h2><p>全称eXtended Architecture，它是一个分布式事务协议，通过二阶段提交来保证强一致性。XA协议通常实现在数据库资源层，直接作用于资源管理器，且大部分数据库支持XA协议。</p><ul><li>优点：<br>由于其作用于资源管理器上，所以基于XA协议实现的分布式产品对业务几乎没有入侵；</li><li>缺点：<br>资源被锁定时间长，性能低，不适用高并发场景；</li></ul><h2 id="本地消息表">本地消息表</h2><p>本地消息表是将分布式事务分解成多个本地事务，通过本地消息表跟消息中间件连接起来最终实现分布式事务。再该模型中分为事务主动方和事务被动方，事务主动方需要建立并维护本地消息表，该消息表记录事务进行的状态。</p><p>事务流程如下：</p><ul><li>1.事务主动方首先进行自己的业务处理并将后续处理写入消息表，这两步在同一个本地事务中保持一致性；</li><li>2.事务主动方轮询消息表，向消息中间件发送消息；</li><li>3.消息被动房消费消息，处理本地事务并将结果写会消息中间件；</li><li>4.事务主动方监听消息中间件更新本地消息表；</li><li>5.各个步骤可能会出现异常，可以会导致消息重复等问题，所以要保证幂等性。</li><li></li></ul><h3 id="缺点：">缺点：</h3><ul><li>1.写本地消息表和业务处理耦合在一起，难以做成通用性；</li><li>2.本地消息表是通过写在数据库中进行实现，需要做额外的磁盘的IO操作，不适用高并发；</li></ul><h2 id="RocketMQ消息事务">RocketMQ消息事务</h2><p>RocketMQ中采用的消息事务。RocketMQ消息事务需要在发送消息时进行两段提交，保证发送消息和本地事务的原子性；此外RocketMQ本身提供存储功能，相当于是对本地消息表的一个内部封装，对事务消息提供持久化支持。</p><p>消息事务流程如下：</p><ul><li><ol><li>实现发送消息的二阶段提交，首先消息生产者预发送消息（half message），若收到成功回复则执行本地事务；若失败则直接取消后续操作；</li></ol></li><li><ol start="2"><li>若消息生产者本地事务处理成功则向服务端（MQ broker）发送commit请求，此时消息便在broker中生效，消费者可进行消费；若消息失败则回滚；此外，因为网络原因或其他情况broker一直未收到commit或者rollback请求则会主动问询事务状态，并根据问询结果进行commit或者rollback；</li></ol></li><li><ol start="3"><li>事务被动方消费消息，进行本地事务；若事务被动方本地事务失败则会不断重试，达到一定次数后触发报警由人工介入处理。若事务成功则整个分布式事务处理完成。</li></ol></li></ul><p>事务消息不仅适用于上游事务对下游事务无依赖的场景，还可以与一些传统分布式事务架构相结合，而 MQ 的服务端作为天生的具有高可用能力的协调者，使得我们未来可以基于MQ提供一站式轻量级分布式事务解决方案，用以满足各种场景下的分布式事务需求。</p><p>不采用的原因：需要强依赖中间件的能力，耦合较深，不易迁移，性能较差</p><h2 id="Ali的TXC中间件">Ali的TXC中间件</h2><p>TXC（Taobao Transaction Constructor）是一款高性能、高可靠、接入简单的分布式事务中间件，用于解决分布式环境下的事务一致性问题。2014年的</p><p>TXC特点：</p><ul><li>最终一致性（牺牲部分一致性和隔离性，可通过配置更改性能与隔离性之间的平衡点）</li><li>代码入侵少（不需要程序员改造业务逻辑，通过注解形式便可实现，开发便捷）</li><li>跨多应用事务（与HSF结合）</li></ul><h3 id="三种模式：">三种模式：</h3><ul><li>标准模式（AT模式）</li><li>自定义模式（MT模式）</li><li>重试模式（RT模式）</li></ul><h2 id="开源版TXC：Seata">开源版TXC：Seata</h2><p>官网链接：</p><p><a href="https://seata.apache.org/zh-cn/docs/overview/what-is-seata/">https://seata.apache.org/zh-cn/docs/overview/what-is-seata/</a></p><h3 id="事务模式">事务模式</h3><p>提供了四种事物模式： AT、TCC、SAGA 和 XA</p><ul><li><p>AT</p></li><li><p>TCC</p></li><li><p>Sega</p><p>Saga 模式是分布式事务中长事务的一种解决方案，Seata 中 Saga 模式的理论基础是 Hector &amp; Kenneth 在 1987 年发表的论文 Sagas。下图（来自官网）是 Seata 中 Saga 模型：<br><img src="/../imgs/sega%E6%A8%A1%E5%9E%8B.png" alt="sega模型"></p><p>在 Saga 模式中，如果一部分分支事务已经提交成功，当其中一个分支事务提交失败，状态机就会触发所有提交成功的分支事务进行回滚。</p><p>分支事务中提交和回滚的逻辑需要由业务代码来实现。</p></li><li><p>XA</p></li></ul><p>历史<br><img src="https://wanglikang-github-io.oss-cn-hangzhou.aliyuncs.com/images/20240804/8d2e879b3688455aa597af7887d129e4.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_50/format,jpg" alt="测试上传oss"></p><p><img src="/../imgs/XA%E7%9A%84%E5%8E%86%E5%8F%B2.png" alt="XA的历史"></p><h1>参考：</h1><p>1、【最大努力通知-实现分布式事务】<br><a href="https://blog.csdn.net/Fireworkit/article/details/135174577">https://blog.csdn.net/Fireworkit/article/details/135174577</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AboutMe</title>
      <link href="/2024/06/06/AboutMe/"/>
      <url>/2024/06/06/AboutMe/</url>
      
        <content type="html"><![CDATA[<h1>关于我</h1><p>姓名： 王利康</p><ul><li>18年本科毕业于郑州大学，信息工程学院，软件工程专业</li><li>21年硕士毕业于北京航空航天大学，软件学院，软件工程专业</li></ul><h1>兴趣爱好</h1><ul><li>撸铁健身 🏋️‍♂️️</li><li>撸猫</li><li>听歌</li></ul><h1>工作经历</h1><p>21年毕业加入菜鸟<br>21.3 - 22.3:    负责风控平台基础能力建设<br>22.3 - 23.3:    负责风控事件中心的重构升级、上线<br>23.4 - 至今:     采购业务中风险合规平台<strong>的0到1</strong> 的搭建</p>]]></content>
      
      
      
        <tags>
            
            <tag> AboutMe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之JIT</title>
      <link href="/2023/12/12/JVM%E4%B9%8BJIT/"/>
      <url>/2023/12/12/JVM%E4%B9%8BJIT/</url>
      
        <content type="html"><![CDATA[<h1>JIT 即时编译</h1><h2 id="作用">作用</h2><pre><code>对访问频繁的方法，进行native编译，提升执行效率</code></pre><h2 id="优化内容">优化内容</h2><h3 id="方法内联">方法内联</h3><h3 id="逃逸分析">逃逸分析</h3><h3 id="锁消除">锁消除</h3><h3 id="标量替换">标量替换</h3><h3 id="未完待续">未完待续</h3><p>占坑</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构系统上线总结</title>
      <link href="/2023/07/04/%E9%87%8D%E6%9E%84%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/04/%E9%87%8D%E6%9E%84%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>设想这样的场景：对一个运行中的系统，需要重构某一个功能模块，或需要整体进行系统重构，且涉及上下游调用比较多。</p><p>如何在保障业务正常运行的情况下，进行功能模块的上线运行？</p><p>如何保障重构后的数据库中的数据和原系统/功能模型一模一样 或 完美兼容？</p><p>如何保障用户体验前后一致？</p><p>…</p><h1>准备阶段</h1><h2 id="需求分析（功能梳理）">需求分析（功能梳理）</h2><p>对现有的系统进行业务流程层面的理解，尽量梳理每一个流程的细节、当时这样设计的原因，最好能产出业务流程图。</p><p>对现有的代码模块有一个整体的了解，评估一下现有系统的Server个数、Class个数、涉及的数据库表个数、涉及的业务流程个数等等，越细越好，最好能产出一份Server服务的全量统计表格</p><p>此阶段主要是为了粗估工作量</p><h2 id="功能模块拆解（详细分析）">功能模块拆解（详细分析）</h2><p>针对不同的业务流程，使用数据流图（的思想），梳理不同数据的流转逻辑、不同服务的关键入参、关键出参，关键实体对象的字段变化逻辑，关键实体对象的状态机等<br>针对现有的代码，最好能做到通读一遍，对所有的类、服务、逻辑，做到心中有数</p><h2 id="新功能、优化功能链路设计">新功能、优化功能链路设计</h2><p>针对重构过程中提出的新流程、新方法、新技术，在系统架构图中，标识出来，用于和老系统进行区分<br>针对旧的功能链路，确保功能前后一致</p><h1>实施阶段</h1><h2 id="功能开发">功能开发</h2><p>根据新系统的概要设计、详细设计，进行编码、自测</p><h2 id="切流逻辑开发">切流逻辑开发</h2><h3 id="切流开关">切流开关</h3><p>by 业务场景、by 用户、by 来源系统、by 时间等，进行切流，当符合灰度的时候，才走新链路；否则，仍走旧链路</p><h2 id="切流日志">切流日志</h2><p>通过日志系统，将新链路中的流量入口信息，进行打印，并通过日志监控系统，进行监控，观察日志。</p><p>若出现大量的报错、异常情况，可以及时切回旧链路，及时止血</p><h2 id="补偿逻辑开发">补偿逻辑开发</h2><p>针对可能出现的异常情况，提供补偿逻辑，如重推、重试、作废、状态订正等，减少异常情况发生后补救的成本</p><h1>切流上线阶段</h1><h2 id="上下游、用户通知">上下游、用户通知</h2><p>在切流前，对必要的参与者、上下游调用方、前台用户，进行通知，告知可能出现的风险、反馈途径、紧急话术、补救措施等</p><h2 id="小部分切流">小部分切流</h2><h2 id="大范围切流">大范围切流</h2><h2 id="全量切流">全量切流</h2><h1>收尾阶段</h1><h2 id="停止、下线旧接口、旧服务">停止、下线旧接口、旧服务</h2><h2 id="清理切流期间的测试数据、灰度数据">清理切流期间的测试数据、灰度数据</h2><h2 id="清理、删除旧代码、旧数据库表">清理、删除旧代码、旧数据库表</h2>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践经验 </tag>
            
            <tag> 软件开发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
